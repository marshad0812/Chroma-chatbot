Table of Contents
Introduction        12
01. About Odoo        13
Odoo Versions and Editions        13
Odoo Community(Open-source)        13
Odoo Enterprise(Licensed)        13
Odoo Enterprise Vs. Odoo Community        13
Odoo Apps        17
Sales        17
CRM        17
Point of Sale        17
Sales        18
Finance        18
Invoicing        18
Accounting        18
Website        18
Website        18
Ecommerce        18
Marketing        19
Email Marketing        19
SMS Marketing        19
Marketing Automation        19
Services        19
Project        19
Timesheet        19
Field Service        19
Help Desk        19
Inventory & MRP        20
Inventory        20
Manufacturing        20
Purchase        20
Odoo runbot        20
How to access Odoo runbot.        20
Odoo Forum        23
Git        25
Basic Git Commands        25
Odoo Repositories        27
Odoo Documentation        28
OCA(Odoo Community Association)           29
02. Setup Development Environment        30
PyCharm        30
Getting Started:        30
PgAdmin        32
Getting Started:        32
Parameters:-        34
Developer Mode        39
Activate through the URL:        39
Activate through Settings:        40
Utilize the command palette to activate:        41
Activate through a browser extension:        41
Adding and Installing New Addons        42
03. Creating Odoo Modules        46
Module Structure        46
__manifest__.py        47
Models        48
Views        48
Data        48
Demo        48
i18n        48
Security        48
Controllers        48
Static        49
Wizard        49
Reports        49
Adding Models        49
Abstract Model        50
Transient model        50
Creating models        51
Adding Menus and Views        52
Setting access right        56
Setting Access Rights        56
Field Attributes        57
Attribute        57
String        57
Required        58
Help        58
Index        58
Default        59
Readonly        59
Translate        59
Groups        59
States        59
Model Attributes        60
Scaffold command        61
Data fields        63
Float fields        68
Decimal accuracy        68
Relational fields        71
Many2one fields:        72
One2many fields:        72
The syntax for writing the One2many field:        72
The values of fields behave like a list. Therefore we can access the data using a loop.        72
Many2many fields:        73
Constraints        74
SQL Constraints:        75
Python Constraints:        75
Computed Fields        76
Dependencies:        77
Usually, the values of other fields affect the values of computed fields. Therefore, using the decorator depends(), we can define those requirements on the compute method. At runtime, the computation function performs dynamic calculations. We must avoid from recalculating the value inefficiently.        77
Inverse Function        78
Related Fields        78
Reference Fields        79
Abstract Model        80
Main super-class for regular database-persisted Odoo models.        80
Transient model        80
Model super-class for transient records, intended to be only temporarily persistent, that are regularly vacuum-cleaned.         80
Inheritance        81
Classical Inheritance:        81
Prototype Inheritance:        82
Delegation Inheritance:        83
View Inheritance:        83
04. Server-Side Development        84
Model Methods and Decorators        84
Decorators.        85
@api.autovaccum        85
@api.constrains(*args)        85
@api.depends        85
@api.depends_context(*args)        86
@api.model        87
@api.model_create_multi        87
@api.onchange(*args)        87
@api.ondelete(*, at_uninstall)        88
@api.returns(model, downgrade=None, upgrade=None)        89
Working With env Variable        90
env.ref(xml_id, raise_if_not_found=True)        91
Env.user        91
env.lang        91
env.company        91
env.companies        92
Altering the Environment        92
with_user(user)        92
with_company(company)        92
with_env(env)        93
sudo([flag=True])        93
SQL Execution        93
invalidate_cache(fnames=None, ids=None)        94
Creating Records        94
Updating Records        95
Searching Records        97
Filtering Records        100
Sorting Records        100
Extending create() method        101
Overriding _name_search()        102
Traversing through Recordset:        104
Working with read_group()        106
Extending Methods        109
Raw SQL Queries:        112
Onchange with Compute Method        114
Model Based on SQL View        116
Onchange Methods        118
Init Hooks        119
Wizard        121
Custom Settings        125
05. Data management        129
Data Loading        129
Xml Files        129
CSV Files        131
No Update        131
Force Create        132
External IDs and Namespaces        133
Delete Data from XML        134
Using XML ID        134
Using Search Domain        135
Function Call from XML        136
Invoking function without parameters        136
Invoking function with parameters        137
06. Views        140
Menu Action        140
Menu:        140
Sub Menu        141
Menus from The UI:        142
Widgets        144
2. Status bar        145
3. Percentpie        145
4. Guage        145
5. Progressbar        146
6. Many2many Tags        146
7. Handle        146
8. Many2many Binary        146
9. Selection        147
10. Radio        147
Buttons        147
1. Form Buttons:        147
2. Smart Button        150
Context & Domain        151
1. To pass default values for fields:        151
2. Setting default filters and groups by records        152
3. In Window actions        152
4. Python has a function        153
5. In search view and filters        153
Domain:        153
1. In a search view filter        154
2. In record rule        154
3. fields_view_get() method        155
4. To filter relational object fields records        155
5. To display specific records        155
List Views        156
Search View        158
Filters and Group By:        159
View Inheritance        161
Form Style        163
1. Header Element        163
2. Sheet Element        163
3. Smart buttons        164
4. Prominent fields        164
5. Notebook        164
6. Chatter widget        165
Kanban view        165
Graph view        167
Pivot view        169
Cohort view        171
Dashboard view        173
Gantt view        175
Activity view        177
Map View        178
Menu Action        180
Menu:        180
Sub Menu        181
Menus from The UI:        183
Widgets        185
2. Status bar        186
3. Percentpie        186
4. Guage        186
5. Progressbar        187
6. Many2many Tags        187
7. Handle        187
8. Many2many Binary        188
9. Selection        188
10. Radio        188
Buttons        188
1. Form Buttons:        188
2. Smart Button        192
Context & Domain        193
Domain:        195
List Views        197
Search View        199
Filters and Group By:        200
View Inheritance        202
Form Style        204
1. Header Element        204
2. Sheet Element        204
3. Smart buttons        204
4. Prominent fields        205
5. Notebook        205
6. Chatter widget        205
Kanban view        206
Graph view        208
Pivot view        210
Cohort view        212
Dashboard view        214
Gantt view        216
Activity view        218
Map View        219
07. Security        221
Access rights        221
Record rules        222
Groups        224
08. Internationalization        229
Import language and set user preferences         229
Import Language        229
Set user preferences:        230
Configure settings in the language        232
Export translation        234
Gettext Tools        235
Import Translation        239
09. Web Development        243
Controllers        243
Http route        246
Serving static resources        247
Custom widgets        248
Qweb templates        251
RPC calls        254
New view creation        255
Mobile app javascript        257
10. Website Development        259
Static Assets        259
Managing Static Assets        259
Asset types        259
         259
1. Script (JavaScript files)        259
2. Style (CSS or SCSS files)        260
3. Templates (XML files)        260
Bundles        261
1. web.assets_common:        262
2. web.assets_backend:        262
3. web.assets_frontend:        262
4. web.assets_qweb:        262
5. web.qunit_suite_tests:        262
6. web.qunit_mobile_suite_tests:         262
Operations        262
1. append           263
2. prepend        263
3. before           263
4. after           264
5. include         264
6. remove           264
7. replace           265
Dynamic Routes        265
Snippets          267
Input from website users        271
Managing Sitemaps for the Odoo Website        277
Visitor information        284
Marketing campaign        285
Multi Website        289
Redirect Old URL        292
Manage website record        294
11. Odoo Web Library (OWL)        296
OWL COMPONENT        296
User Actions        298
Life Cycle        301
Reactive OWL Component        304
OWL Field        307
12. Test Cases        313
Python Testing        313
Adding Python Test Cases        313
Tagged Python test        316
Head Less Test        319
Qunit Test        322
Adding Qunit Test Cases        322
Tour Test Cases        326
Client-Side Test Cases        329
Running QUnit test cases from the UI        329
Running tours from the UI        330
Video/Screenshots For Failed Test Cases        331
13. Odoo .SH        333
Basic Concepts        333
Manage Branches        335
Development        335
Staging        336
Production        336
Merging        336
Debugging        336
Branch history        337
Mail catcher        337
Web shell        338
Backups Instances        339
Builds        340
Other.SH options        345
Branch Settings        345
Shell Commands - Merge, fork, clone, and more actions may be performed with Git commands.        346
Submodules: Other modules that rely on a different repository than our repository can be used. We have the idea of submodules for this. The dependent modules may be added to our repository branch as a submodule.        347
Project Settings        348
The setting allows you to control some of the most crucial aspects of your project.        348
14. Remote Procedure Calls (RPC)        350
XML RPC        350
JSON-RPC        357
Search/ Read Records        360
Create Records        363
Update Records        365
Delete Record        366
Calling Method        366
Odoo RPC library (OCA)        367
15. Performance Optimisation        373
Prefetch Patterns        373
ORM Cache        377
ormcache        378
ormcache_context        379
Ormcache multi        379
Least Recently Used (LRU)        380
Create and update multiple records        381
Generate records through database query        383
Grouped data        385
Image Generation With Different Sizes        388
16. Emails        391
Incoming Email Configuration        391
Outgoing Email Configuration        392
Chatter        395
How to Add Chatter to the Form View        399
Activity        401
Send Emails Using Qweb Template        405
Email Alias        407
Periodic Digest Emails        410
17. Point Of Sales        414
Custom Javascript Files in POS        414
How it works        415
Custom POS UI        415
Customize Customer Receipts        418
18. IOT Box        424
Connect IoT box to a network        424
Connect IoT box with Odoo        428
Load Drivers        431
List Connected Devices        433
Access IoT box with SSH        436
POS Configuration        438
19. Others        441
How to create Qweb-based pdf reports        441
Report Action:         441
Report Templates:        442
Manage kanban stages        443
Kanban Cards        447
Create server actions        456
Python code server actions        465
Automated actions on time conditions        467
Automated actions on event conditions        468
Dynamic record stages        471




















Odoo 16 Development Book
Introduction
Odoo 16 Development book is an essential guide for developers and consultants who want to build sophisticated and reliable business applications using Odoo 16. Written by experts at Cybrosys Technologies, this book provides a comprehensive overview of Odoo development and covers the most important topics. It is a perfect resource for developers, consultants, and business owners who want to develop robust business applications using Odoo 16. 
This book starts with a brief introduction to the Odoo framework and its development tools. It then dives into topics such as Odoo models, views, business logic, security, web services, and integration. It also explains how to develop custom modules and create powerful reports. 
In addition, the book provides detailed instructions on how to install and configure Odoo 16 and the various components of the framework. It also covers the topics such as debugging, performance optimization, and deployment. 
By reading this book, you will learn how to extend existing Odoo applications to customize the system for your company. With numerous code examples, detailed explanations, and step-by-step instructions, this book will help you create robust, reliable, and efficient applications with Odoo 16. Whether you are a novice or an experienced Odoo developer, this book provides all the information you need to successfully develop and manage custom Odoo applications. It is also an invaluable resource for everyone looking to get the most out of Odoo 16. You can quickly understand the fundamentals of Odoo 16, its architecture, and the new features introduced in the version.


01. About Odoo
Odoo Versions and Editions
Odoo is customizable and a fully integrated open-source business management software that helps your business operations like Sales, Accounting, E-commerce, CRM, Purchase, etc. There are two versions of Odoo: Odoo Community and Odoo Enterprise.
Odoo Community(Open-source)
The Open Source version of Odoo is called Odoo Community.  It is available for free. The community version only offers limited features. It helps to integrate the free and third-party apps into the community version of Odoo.
Odoo Enterprise(Licensed)
The paid version of Odoo is called Odoo Enterprise. It offers more Odoo features and functionalities that are provided by the Odoo community. Marketing Automation, Maintenance, Sign, Studio, and Subscription these modules are only available in the Odoo enterprise edition.
Odoo Enterprise Vs. Odoo Community


Edition
	Odoo Enterprise
	Odoo Community
	General
	

	

	Desktop(web browser)
	Yes
	Yes
	Mobile(android & ios)
	Yes
	No
	Public or Private Cloud Hosting
	Yes
	No
	Version Upgrades
	Yes
	No
	

User Interface
	

	

	Unlimited Functional Support
	Yes
	No
	

Multi-Language
	Yes
	Yes
	

Odoo Studio
	

	

	Apps Creation
	Yes
	No
	Menus Editor
	Yes
	No
	Report Designer
	Yes
	No
	Screen Customization
	Yes
	No
	Finance
	

	

	Accounting
	Yes
	No
	Invoicing
	Yes
	Yes
	Payroll
	Yes
	No
	Sign
	Yes
	No
	Sales
	

	

	CRM
	Yes
	Yes
	Sales
	Yes
	Yes
	Point of Sale
	Yes
	Yes
	Subscriptions
	Yes
	No
	Rental
	Yes
	No
	Amazon Connector
	Yes
	No
	HelpDesk
	Yes
	No
	Field Service
	Yes
	No
	Amazon Connector
	Yes
	No
	Websites
	

	

	Website Builder
	Yes
	Yes
	Ecommerce
	Yes
	Yes
	Blog, Forum,eLearning
	Yes
	Yes
	Live Chat,
	Yes
	Yes
	Project
	

	

	Timesheet & Tasks
	Yes
	Yes
	Forecasts
	Yes
	No
	Human Resources
	

	

	Employees,
	Yes
	Yes
	Referrals
	Yes
	No
	Appraisals
	Yes
	No
	Time Off
	Yes
	Yes
	Marketing
	

	

	Email Marketing,
	Yes
	Yes
	Social Marketing
	Yes
	No
	SMS Marketing
	Yes
	Yes
	Marketing Automation
	Yes
	No
	Inventory & MRP
	

	

	Inventory Management
	Yes
	Yes
	Purchase Management
	Yes
	Yes
	PLM
	Yes
	No
	Quality
	Yes
	Yes
	Barcode
	Yes
	Yes
	Odoo Apps
Odoo apps enclose various open-source business applications such as Sales, Services, Accounting, Inventory, Manufacturing, Website, Marketing, Human Resources, Productivity, and Customization that cover all the needs of your company.


 https://lh3.googleusercontent.com/8IgF46mQZOhUxoqeg1B57PPaE_gIAxV6huJ1aQJB10w7Opc0F0SqUm8-9XgUTDfRKUiJHvrqh-yff3IQKYl4vS_QbE85-BVP-00pX2eI81Zy6XVRTOmCUEcDjApFjK6jVG1uWJJPpNHYt7575ruXTmk 

Sales
CRM
The activities of Sales, such as Activity scheduling and Lead tracking, are managed by Client Relationship Management(CRM).
Point of Sale
It is a smart interface for any retail company and is capable of working even when you are offline.
Sales
The complete management of the sales department is provided by Sales applications such as the Creation of sale orders, sending out sales quotations, and managing the sales team and salesperson.
Finance
Invoicing
Management of payment like creating invoices, sending them to customers, and payments.
Accounting
It is an accounting application with advanced features such as batch operations, payment automation, warnings, quick reconciliation, automated synchronization, automated alerts, and many more.
Website
Website
Create and design your website simply by drag-and-drop building blocks.
Ecommerce
Ecommerce permits us to conduct online sales operations and integrate inventory, sales, and invoices.
Marketing
Email Marketing
It permits you to create, send and track emails.
SMS Marketing
Permits for creating SMS messages and assisting with planning. It also allows for organizing and tracking campaigns.
Marketing Automation
Lets in for the creation of automatic, target-oriented advertising campaigns.
Services
Project
Project module allows you to create and manage your projects.
Timesheet
The timesheet application Helps to analyze and track employees' working time.
Field Service
Mainly for performing customer field service tasks. Allows to plan, assign and access these tasks.
Help Desk
Organization and tracking of all support tickets provided by the Help Desk.
Inventory & MRP
Inventory
Warehouse management is controlled by Inventory.  It helps to manage traceability, lead times, and advanced routing (drop shifting and cross-docking).
Manufacturing
Manage, schedule & plan, and process the manufacturing orders lead by manufacturing application.
Purchase
The Purchase module allows you to create purchase orders with the management of suppliers.
Odoo runbot
Odoo runbot is an environment for testing Odoo. The runbot server will provide all installed versions of Odoo, which may include editions or branches. Both enterprise and community editions can be hosted on the server. Odoo runbot is an open platform, so anyone can use it to execute and also test Odoo's features.
On this platform, almost all the latest buildup of all versions are available. 
If there is any error that occurred at the time of developing locally, check it on the Odoo runbot; if the runbot also shows the same issue, it will be the bug of Odoo. Otherwise, the error is from the developing module or copy of Odoo.
How to access Odoo runbot.
Just browse Odoo runbot and pick the link shown on the browser. Then you can see the view below. Then you can access runbot.
Runbot
 https://lh5.googleusercontent.com/puXtbuc_A0qW6IDKNBDJzVJ9kHAaSLU1NjcrOO2966HSX8fYQdhFM58b0zI9aW5Wq-M62QcPuO-DH7TolQ5SJxbWjp01Q3snfSFwZmy0vV7C36z6eFLc902cK389pX6jqx1DpFflxUerLAEb8ACEifA 



This is the home page of runbot, where you can see the green or red color highlighting squires to suggest whether the build is active or not. You can use the green, It is an active build, and the other is not active yet.
We can open the required Odoo version by clicking the blue button in the rows, and we also prefer community or enterprise.
 https://lh5.googleusercontent.com/Km3RcLJqSJ8rEgXW3WFSLPDhamxnkEB1h8e1y61fQDKRC07V0Ey81R7AgfwGTBGrUBy7suHRZ8yp6FRG26O04BpZShGGCjVbJ5GPzIgr3RFRLVxLvVx-izbVgXtab8nRxl-i5m2rTReqpNfnXrueAxM 

Two databases are available; they are  'all' and 'base.’Every module will be installed in the 'all' database, and demo data will be stored. But in the 'base' database, no modules will be installed.
Runbot provides the newest build features with Odoo. You can see data of other people using the system at the same time as you because so many individuals from all over the world can utilize the instances concurrently. Runbot supports a multi-user system.
Let’s see the log file showing the Build errors by clicking the gear button of non-active branches.


 https://lh5.googleusercontent.com/q3dxcnMU5c4K5MBORbrKokXzeGcKSRPfwbjp12Ghy3DnTJaYwNCU1FAXhbx_tXpWBF90p_H3qi7trTKyXGYvJAV9TqkVAbCayULj-E2_v-uSZKzxYoaDfW37aYVUlXQ75yAUOU-oKk7OHcae-HiyEjc 











Below is a log file showing the error from non-active branches.
 https://lh5.googleusercontent.com/iiMLO0-PtSicr50Hr_LKgQ6wAASK3jSGlsG4eRsN4jaOtdDvoeC5SXGro4Y_NSwlj3COregGGsI6F9azeT3HgJ9NLi66TwnQ0dtXA1O4dVZDAkr3_p_4Jc5I9Qvb8yVXP1VBHrc0wpsJssKnSFODEZA 

Odoo Forum
Odoo forum is a network of questions and answers for programmers, professionals, and enthusiastic users. Using this option, people can ask questions, discuss, examine, share technical knowledge, and do lots of extras. It helps people to discover the answers once they need them.
Post Your Questions and Answers
Anyone can post any questions related to Odoo.
Discover the answer to your questions fast.
Browsing the content related to your question leads to all related Odoo Forums. The green tick indicates the best-answered forum, which will show at the top to optimize the search. 
 https://lh5.googleusercontent.com/mVcg-f7JdY3_fJ_1ctycTXSfYh-yrSqT54YJTedIE26_EfrQVFJXAxGwed7WpD8LompBxZkULFyQLPmdYloEkyNM66UXl6yiVlVwZgolQCzMak3OG4PyicswZGJzcaTrS8LPoSSrx0hXVGcwsQSY6Iw 



Git
Git is generally utilized in software program improvement for source code management. It is a disbursed version control system, which means that each developer's laptop has got admission to the complete codebase and history, creating branching and joining simply. It is organized to handle a wide scope of jobs with speed and efficiency.
Git allows and facilitates the creation of several local branches completely separate from one another. It just brings seconds to create, merge, and delete.
After the installation of git, you can install any code from git.
Using the below command, you can install git.
sudo apt-get install git
	

Then you can get the latest development version via Git itself:
git clone https://github.com/git/git
	

Through Git, we can track the changes in source code. It enables collaboration among several developers.
Basic Git Commands
Create Repositories
Create a local repo -
git init
	Make changes
Add a file to staging -
git add
	Commit all staged files to git -
git commit
	List new or modified files not yet committed -
 git status
	parallel development
Add a file to staging -
git add
	Merge all commits into one new commit-
git merge:
	Rebase a branch onto another-
git rebase
	sync repositories
Upload local content to the remote repo -
git push
	Fetch the remote repo's copy of the current branch -
 git pull
	add default upstream repo -
 git add origin
	Odoo Repositories
All code of Odoo is hosted on GitHub. You could put up bugs/issues for strong versions right here. We get the right to access the codes from that repository, whether or not that is a private repo. You can additionally submit Pull Requests to signify a new feature (PR). We will create pull requests in preference to push immediately to GitHub.There are many repositories in Odoo. Let’s see some records on the central repositories of Odoo.
Odoo git It is a public repository that is a community edition of Odoo.  Anyone can access the repository to refer to the codes for development.
Odoo Enterprise It is a private repository, an enterprise edition of Odoo.  Only the authentic Odoo companions can get entry to the repository.
Odoo Dev It is an ongoing development repository. It's miles a public repository so that everybody can get the right of entry to it.
Odoo releases a new version every year. And there may be one major version and some minor versions. The minor versions are specifically used for the SAAS offerings. The main variations are 13.0, 14.0, 15.0,16.0, and so on. The minor versions like saas-14.1, saas-14.2, and so on. We are able to download the code for a specific version on the corresponding branches
Odoo Documentation
The theoretical form of Odoo is Odoo documentation; it is going to be like a user manual. The document includes everything about Odoo with detailed examples. We can refer to the documents if we have any doubts at the time of development. On that four categories of things.
* User docs: We can discover the Odoo guide to help you use and configure the platform by user docs.
* Install and maintain: Through this, we can learn how to install, deploy and upgrade Odoo on-premise or on Odoo.sh.
* Developer: We can learn the development of Odoo by reading the framework references and programmer tutorials. There are also tutorials available.
* Contributing: On contributing, you want to help Odoo but aren't positive about which to start. The lessons and tips are designed to assist you in enhancing Odoo.
Anyone can access and learn by Odoo Documentation this link, it is public. This is the access link for Odoo 16 documentation. All versions of Odoo are available here.
OCA(Odoo Community Association)   
The Odoo Community Association, or OCA, is a non-profit organization. The Association is helping members to create lower-cost, more successful Odoo. Moreover faster solutions, with easy access to high-quality apps and open upgrades. 
https://github.com/OCA OCA's official GitHub repository is a public repository, which means that anyone can use it.
The members of OCA will maintain the members of the Odoo Community. All OCA modules are free of cost, and also these modules are available in the Odoo app store. The third-party developers create OCA Modules. They paintings in tandem with the network version. Module authors are answerable for OCA modules. The normal Odoo policies do no longer observe to them.




















02. Setup Development Environment 
PyCharm
PyCharm is dedicated to the Python integrated development environment(IDE). It offers a large variety of crucial tools for Python inventors. Python programming is heavily emphasized in PyCharm, which also includes PEP8 error checking. It aids in the creation of clear and acceptable laws. The built-in legal recommendations and law examination decrease the time needed for scribbling down and debugging laws. New plugins can be added to make programming simpler. A genuinely helpful IDE for the development of Odoo in PyCharm.


Getting Started:
Professional Edition and Community Edition are PyCharm's two primary editions. The premium Professional Edition has more features than the free Community Edition. PyCharm can be downloaded instantly from the program's official website or the terminal. Use the command to launch the Linux system.


sudo snap install pycharm-community --classic
	

 https://lh3.googleusercontent.com/4pq0ZtIp0XnnNuTFNS_GWuG4Nj4IsIE3tfKF9DRPFpdbkZNHh76mN-ArT5sF0GKdFYS-mV6oEDfn7dR4AWb4qgr7kldV0kt3HvTqrQXDUwZ0uhuXcs_MAtYOH2gNFLGk5-Lm552O03BqTslosgL0fIM 

After installation, open the PyCharm and go to File->Open to open a file/ project 


 https://lh6.googleusercontent.com/4hpHdKzoLduVnpucwmtIp3ULhd3Dcr6X-WwkrtQaB3oBgI3uru4b2YdLSk4qibFOtbshO8bRKn38jPLvaRmwwoxiy6EbAd0phZhomxBW5XW4VZd1L6LWmhI5y0TN7zVh-puBJICdns-OkiNXk1U_M7Q 




PgAdmin
pgAdmin is a web-based GUI tool that can be used to connect to the Postgres databases and perform any database-related operations in it using pgAdmin. It provides a powerful graphical user interface for databases  and simplifies the creation and maintenance of database objects.
Getting Started:
We can download pgAdmin from its official website: pgadmin Download
 
 https://lh6.googleusercontent.com/mnOtOZt18tzbN2SK2IkmSv40TIJRGNu6KHiFJbycwrLSR7z8vQ1yYIQKi0u8oG7Q-FwVL52sz8WApzyx89rDEpN3eQE5gNTGqT22O43ESMpiDWHZ6DW4heRHNJFEV0E7UcicKGnNxPoj-QC2AlkTTDo 



We can run these commands in the terminal to download and install pgAdmin in the Linux system
sudo curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
	

sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
	

sudo apt install pgadmin4
	

In the terminal to set up the required configurations and install pgAdmin 4. Most of the data related to Odoo is stored in the Postgres database. So, we can use pgAdmin to check or verify any data in the database. 


 https://lh4.googleusercontent.com/dshxfv49A3crr6x-JjZ9d4xUWblMzxYPj0n0dAg1GCULs7HziV3raakvS3PfoH_kwuGpVWgT2sZ4gkPnVo_uID8cdmELjhIXh1X1_DDtlOzUfYdrTXqL6TvD7X1Wq2WdMAdbpZotvg0VdwW4nGxEfHk 



Conf File
Conf file or configuration file is the most important file in Odoo. It is used to set the initial parameters to run the Odoo.


Parameters:-
* addons_path: defines the addons path folders, which are added in priority order.
* admin_passwd: Names the Master password, which can also be changed from the front end. The master password for Odoo will be hashed and saved in the conf file when it is set or modified.
* csv_internal_sep: Specifies the separator to use in the CSV file.
* data_dir: specifies the path to the directory containing the filestore for data linked to Odoo.
* db_host: Specifies the database host. Localhost is set by default.
* db_maxconn: specifies the maximum number of PostgreSQL physical connections.
* db_name: Names the database specifically. The default setting is False. If a database name is specified, only the Odoo database selector and manager will display that database.
* db_password: Specifies db user's database password. None is the default value.
* db_port: The database port is specified. None is the default value.
* db_user: The name of the database user is specified. None is the default value.
* dbfilter: Makes use of REGEXP to filter the database.
* db_template: Template0 is the default value.
* email_from: Gives the SMTP email address that should be used to send emails.
* http_port: Specifies the HTTP port for Odoo.
* import_partial: Used to import large amounts of data. We can carry on in the existing state even if the process fails. We can give a filename to save any intermediate import states that we may have.
* limit_memory_hard: Defines the strict upper limit for virtual memory. Any worker that exceeds the limit will be terminated right away without waiting for the current request processing to finish.
* limit_memory_soft: Specifies the most virtual RAM that a worker is permitted to use. Any worker who goes over this cap will be killed and recycled at the conclusion of the current request.
* limit_request: Specifies how many requests a worker can handle before recycling and beginning over.
* limit_time_cpu: When the worker uses more than the allotted amount of CPU seconds to process the request, the worker will stop.
* limit_time_real: If a worker takes more than the allotted number of seconds to complete a request, the worker will be terminated.
* list_db: True/ False. If False, hides the database list.
* log_db: True/False. If True, also write log to the 'ir_logging' table in the database.
* log_level: Any of the following values can be assigned: info, debug rpc, warn, test, critical, debug sql, error, debug, and debug rpc answer.
* log_handler: Chooses a value pair from the available "module:log level" pairings. The default value is ':INFO', which means all modules' default logging level is 'INFO'
* logfile: Specifies the log filename. If not set, use stdout.
* logrotate: True/False. If True, keep up to 30 log files and make one every day.
* interface: provides the IP address that the server will bind to (or localhost). If it is empty, it will bind to all interfaces. It is, by default, left empty.
* port: Indicates the TCP port that the server will listen on
* secure: Sets whether HTTPS should be used to launch the server.
* secure_cert_file: The certificate file to utilize for SSL connections is specified.
* secure_pkey_file: Provides information about the private key file that is used for the SSL connection.
* longpolling_port: Specifies the TCP port that is utilized in multiprocessing or gevent mode for long-polling connections. The 8072 default value. In the default mode, it is not utilized (threaded mode).
* max_cron_threads: Defines the number of employees who are assigned to cron jobs.
* osv_memory_age_limit: Sets a maximum age for records stored in the OSV memory virtual table that is enforced. The default value for this floating-point number in hours is one hour.
* osv_memory_count_limit: Sets a maximum record count for the osv memory virtual table that will be strictly adhered to. False, the default value, denotes the absence of a record limit.
* pidfile: The file mentioned here will house the server pid. The default value is False. The init script creates the PID.
* proxy_mode: When deploying our application behind a proxy, we can set this to true. True is the default setting
* server_wide_modules: Specifies a comma-separated list of server-wide modules. The default value is ‘web’.
* smtp_password: contains the SMTP password needed to send the email. The default value is False.
* smtp_port: Specifies the SMTP port.
* smtp_server: Names the SMTP server that will be used to send mails. The default value is 'localhost'
* smtp_ssl: True/ False. If True, SMTP connections are encrypted using SSL (STARTTLS).
* smtp_user: Specifies the SMTP user to send emails to. The default value is False.
* syslog: true/false, log in system event log: syslog.
* test_enable: True/False, enable YAML and unit testing.
* test_file: Used to run a test file in Python or YML. The default value is False.
* test_report_directory: Specifies the location where samples of all reports should be saved. The default value is False.
* test_commit: Utilized to publish database alterations made by YAML or XML tests. The default value is False.
* translate_modules: Specifies modules to export. Use in combination with --i18n-export. Default value is ['all'].
* unaccent: Indicates whether to use the unaccent feature. Default is false.
* Without_demo: It is utilized to prevent demo data loading before modules are installed. Modules can be listed with commas separating them, and "all" can be used to apply all modules. False is the default setting.
* workers: Specifies the number of workers. The default value is 0.
* xmlrpcs: It manages the on/off state of the XML-RPC security protocol. To turn it off, set it to False.
* xmlrpcs_interface: XML-RPC protocol TCP IP address specified by xmlrpc interface. The empty string can be used because it binds to all interfaces.
* xmlrpcs_port: The XML-RPC protocol's TCP port is specified via the xmlrpc port variable.
* xmlrpc: It is used to turn on or off the XML-RPC protocol. Set to False to disable it.
* xmlrpc_interface: Specifies the TCP IP address for the XML-RPC protocol. We can use the empty string, which binds to all interfaces.
* xmlrpc_port: Specifies the TCP port for the XML-RPC pr.’ocol.
* timezone: Specifies the server's reference timezone. Berlin is one example of Europe. False is the default setting.
 https://lh6.googleusercontent.com/kq16DBY4KBLYrnolax7vFQpe8uR2FA6Wr7o2Q0KLGYZZ78sikbOrNgeVMYh8edy4Aw6dQ7sac1tbkJQ6rSzdFmojlNPt-dGgXCXOG9cCwxohSl-FxlPaMaJtti6ZN9SDjIEpw2LOx_P3CDhkrWKoEJc 

           
 Developer Mode
Developer mode offers us admission to more outstanding technical capabilities and superior tools. After allowing developer mode, we can get admission to personalize views, reports, templates, fields, menus, and consumers get admission to filters, actions, etc. We can set off developer mode in special ways:
Activate through the URL:
In the URL, add ?debug=1or ?debug=true after /web to activate developer mode.
 https://lh3.googleusercontent.com/imiO45V3vittScWql2ZF4PKBx_AZyInzKbNczQWoHAJ7xOIKPDkyMG1gLxGKAs0z85usVZHQF0f7V4HvUU6xK4QMBiWO5aJoN2Pj_ZQFuqMCEykuxdUTNoDbXjOozwJHpgoVokbpwEJzRyd8nHJC29s 



Add ?debug=0 or ?debug=false after /web to deactivate the developer mode.
 https://lh3.googleusercontent.com/mMZcVw8IkB2jDfinIhAcrWIRNKSSCKY4qnCppXKm7sCO7bL1UR6s_xluFiWmF6RVr2c49fJwlLj8gRaWA6TTW14yjmRWTE4JaCGuDt3fqSYB3ZubeC_zHXHpeeVyzus3ZdN_-SyrdN1NfnKIP9FE8Uo 

Activate through Settings:
Click the link after navigating to Settings->Developer Tools. To run developer mode, activate developer mode.
 https://lh4.googleusercontent.com/g9neDZmn4NMjAeXnyyQ8bJ05Vp5VHiLrulSqrjJvMf70yHEmqqMtoNQL8THbE6REnuJmpWGJtx6ffI5rROebBTzyhbr72YlPlHh2vMsh-h4QGj_lJaeoZCwjX7wRO1_k98ERFccx9-tFGvVOGxg9uWY 

Click the link after navigating to Settings->Developer Tools. To turn off the developer mode, press the appropriate button.
 https://lh4.googleusercontent.com/vihiz4f3DOgJGuOVXpgFBFEB3cKF0pF-le-fk8E-2IpwdNv4q1M3TdwTQChyB_lfKHQDTqPW0ICsNBMFAjWyZpaiPGCaIkwAO21GqcOCrhzRxDOOSBGEMY7SrpfpXgxnKNDi0WNoDrrHIfpoDHzAUQs 



Utilize the command palette to activate:
Make use of the keyboard shortcut (ctrl + k) to launch the command palette. When you type "debug," the option to turn on developer mode will appear.


 https://lh3.googleusercontent.com/gSNqhu87n06CpZXK3F5u07zkfsGaE5ehIQHDxLWaO4rR_IqJ0G76oeDdWQGsnsZQeWDrT-I2kqJ1F0l8XXIysSCL6SDzYU08rDVtdE8lko2BXmHxXVp67h7iQIwBMHk2_ELbYuOt5BIBHVSdZk636I8 



The option to disable developer mode will be displayed when you open the command palette and type "debug."
 https://lh4.googleusercontent.com/DvtFien6NynWurbp2iH9xEybt6p5sOHpRr36Qm0tSJY_rnETL9TQywJvEo7tFOkZiMX9x0jxeBO6f8cP07M07xCN9shQUAOehXMTWp9FZN2us8WFcocHhspdSVE9_ulK6xB5CyKZQsE-XHeP0UKVd7U 

Activate through a browser extension:
To install the extension in the browser, go to the extensions menu in the browser's settings and type "Odoo Debug." We may see an extension icon alongside the other extensions in the browser after installing the extension. Developer mode can be activated with a simple click on the icon.


 https://lh3.googleusercontent.com/ud16DTmwBJ_e_56zXMfVBvFmbeR9j0mOPbeqiGcTihns4Oaq-qBH-WDZvGuua1vcGunHsrArkOzeWxWYPtFqoxi9NUUrywogJYuertYx_GAT3ZoLerjXJosq7VOYE6BPQDhm0XVnl1yCEHu3zfvLDRo 



When developer mode is active, a single click on the icon will make it inactive.



 https://lh6.googleusercontent.com/9QLLTmDwR6Y7glrZutb9ij6zL1PoCWRTc03O5P0Fs-A5d2XoMWkgK7nu5PnA5mr5YcDi-iXgnAsSwUQGrW5i6Pje9Y795FbGv0gzHtKMbQa7Fn2XNNGeB_YbOOTlEn6p0QuopGekTIxipuAGy65yuKY 





Adding and Installing New Addons
We have the Odoo network add-ons and the agency add-ons in case; we're using the agency edition. If we must do any customizations or if we want to feature extra apps or modules, then we will upload them to Odoo via means of including them in a custom folder in the task directory. In the screenshot, a module from Odoo Apps is introduced withinside the custom_addons folder that's created in the task directory.


 https://lh4.googleusercontent.com/5z71Xyh9iODGRzdws6WggDdF612f7Jx1McbKo0vjPv7fjic7MACPITuEtLvYt8xYivGHvZu7nGHiWK2jSalTOMFgy-F9RRpUbpwZeJlxL45bqUtyLhWZUJc2kUq9oLUH6SVEYBLyJEw9X10aA8uHB3g 

The absolute path to the new directory must be added to the addons path in the Odoo conf file in order to use the new addon in Odoo.
 https://lh5.googleusercontent.com/x9qx4TdIjME9TXIm5nuZUt357hrN7EJ0tirnj8pGy9_KkwYWUxiAWM8-G6CYhseCYm7tAZ2-vIJ8h2aZD_LPAyNbxGXULeMhpJk7IhvnQY3z8lHSfl-LC3QmzDE6voNIyafi3aWOS2oS7IPyOSLRhK0 

We can replace the addons_path withinside the conf report at the server via the terminal. Suppose the conf report is placed at /etc/odoo.conf, then we are able to open it via means of walking the command sudo nano /etc/odoo.conf and including the route to the custom addons. Suppose the custom addons are placed at /opt/odoo/custom, then upload the route to addons_path withinside the conf report with the opposite addons.
E.g.: addons_path = /opt/odoo/addons, /opt/odoo/enterprise, /opt/odoo/custom
Open Apps and turn on developer mode to install the recently introduced module. After activating developer mode, certain new menus will be accessible within Apps. To load the recently added Apps and modules, use the Update Apps List menu option.
 https://lh4.googleusercontent.com/W0oFe2sOnACqoW3L0QyS7g0tDIFc7TgN6phg1I1IU4SBIuFPOb-F0PJDDCJMfmyao_WKdbF_w6MEwtp6bTXaJmTluq9xmXE6dBOQ_piU2241TrWC_s9urd7H9LL2V_-Bcv3l7Mzlyt5QqEZGRzqoZ6M 

Click on the Install button to install the app/module.
 https://lh5.googleusercontent.com/0WwcunXMDbHpWGk3YHr_7gjcOss0ho4e4O5UcAxACEY8LkhFxbWtsE0d6OltT4kv6C0mUxPFLC6UMU3LEXyHcebm9vJkvpv5OD9Ap3yVZjXO87QbIEpfv-eaMzYuF1wiauAFpj-U9B4jIlCVNS1emCA 
By using the install button, we can install our module and use our module features








03. Creating Odoo Modules
Module Structure
The most important thing while developing a module is its structure. When we create a module, it has its own structure, and we should always make sure that we follow the module structure. A module consists of  different components such as models, views, security, etc.
Mainly an Odoo module is declared by its manifest.
Each module requires a python file and a manifest file that are __init__.py file and __manifest__.py file. The basic structure of the module is given below.


 https://lh5.googleusercontent.com/ZC0iFONPWNHuAjcvDKRa-hQZicOHoD7eg5XXSjGDtQH8OI3F9jkI98p_utG3h1R4dn5Zdm2bgi6Ih6GAyObU3JB7sadXG4E0eLDr4DeUFhi642uUZQIdlXr0qgAJ1GyG360bqUXC2tpkBUFBCa3wIEk 

A module is also a Python package that consists of __init__ .py file that includes import instructions for the module's numerous Python files. For example, if the module has a single pythonfile.py file, then its  __init__.py file contains:
from . import pythonfile
__manifest__.py
We can describe the name of the module, author name, version, description, company, category, etc., in the manifest.
Name - Name of the module.
Description - Brief description of the module.
Version- Here, we can specify the module version.
License - Specify the distribution license
Author - Author name of the module.
Website -  Module author’s website URL.
Category - Specify the category name.
Depends - Here, we can specify  the list of modules that must be installed before installing the module.
Data - With the installation of the module, these files are installed or updated.
Demo - In active demonstration mode, the data files that are installed or updated.
The module has directories. It includes models, views, demos, static, security, data, wizards, etc.
Models
The model file consists of  __init__.py file, which imports all python files on that model's directory.
Views
Views file consists of XML files for the user interface, with the actions and views like forms, lists, etc. The format of creating an XML file is “demo.xml”
Data
Data file contains all data files along with the module's initial data.
Demo
It consists of data files with demonstration data, which is very useful for testing, training, or module evaluation.
i18n
The i18n file contains the translation files, which include .po and .pot files. These files are not required to mention on the manifest file.
Security
It consists of XML files that generate access groups and record rules for security and data files that define access control lists, such as the ir.model.access.csv file.
Controllers
The Controllers folder consists of code files that provide that functionality for website controllers.
Static
All assets are expanded inside the static directory. Files in this directory are public and accessible without a username and password. This directory contains JavaScript, style sheets, images, and other items that aren't listed in the module manifest but need to be referenced in the web template.
Wizard
Wizard contains all files related to wizards. Wizards are used to holding intermediate data in Odoo.
Reports
Odoo helps us to generate pdf documents such as invoices and sales orders. The report directory consists of all the files related to reports.

Adding Models
A model is a class that maps to a data relation. It will include all the necessary fields and behaviors for the data you will be storing. The _name attribute is most required as it defines the name of the model. In many cases, every model is associated with a single database table.
Three types of models are:
1.  Models
2. Abstract model
3. Transient model




Models
In the model itself, model fields are defined as attributes. 
From . import models, fields
class ExampleModel(models.Model):
        _name = "model.name"
        Field = fields.Char(string="field's label")
	Abstract Model
Main super-class for regular database-persisted Odoo models.
All models in Odoo are created by inheriting from this class.
from . import models, fields
class AbstractModel(models.AbstractModel):
  _name = "model.name"
  Field = fields.Char(string="field's label")
	Transient model
Model super-class for transient records, they are vacuum-cleaned on a regular basis and are intended to be only temporarily persistent.
It has simplified access rights management. All users can create new records. But, they can only access the records they have created. Without  any restrictions, all Transient Model records are accessible to the superuser.
from . import models, fields
class TransientModel(models.Transientmodel):
        _name = "model name"
        Field = fields.Char(string="field label")
	Creating models
In order to create a new model, we should add a python file describing it and then upgrade the module. The path which is used is relative to our add-on module’s path.
1. In the model directory, add a python file
example: Let us create a module named visa in that add a  python file named visa_application.py
from . import models, fields
class TransientModel(models.Transientmodel):
        _name = "model name"
        Field = fields.Char(string="field label")
	

2. Add a python initialization file and load the python file to it.
I.e., Add the below code to the __init__.py file
from . import visa_application
	I.e., from . import filename
3. In order to have the models directory loaded by the module, edit the module’s python initialization file.
from . import models
	4. From the apps menu in the user interface, upgrade the Odoo module. We can check if the model is added by activating the developer mode and going to General Settings > Technical > Database Structure> models and search for our model “demo.model” on that.
Adding Menus and Views
The main attraction of Odoo is that menu and sub-menu can be created using both code and UI. This makes Odoo more user-friendly.
Let us construct a menu using XML or code.
For that, create a view directory on the visa module, which we have already created.
In order to add a view, we have to add an XML file to the module containing its definition.
1. To store the data records for the UI Views, create an XML file > visa_application.xml
2. Add XML file to the data in the __manifest__.py
'data': ['views/visa_application.xml'],
	

3. Add an action for the view.
<record id="record_action" model="ir.actions.act_window">
  <field name="name">Visa Application</field>
  <field name="type">ir.actions.act_window</field>
  <field name="res_model">visa.application</field>
  <field name="view_mode">tree,form</field>
  <field name="help" type="html">
      <p class="o_view_nocontent_smiling_face">
          Create a new record!
      </p>
  </field>
</record>
	

name - Name of the action.
res_model - the name of the model.
view mode – Various view modes. By the preceding action, this mode must be defined.
view_id - when the action is invoked, the default view that must be loaded is view id.
4. Add a menu item to the visa_application.xml file to be visible to the users.
<record id="record_action" model="ir.actions.act_window">
  <field name="name">Visa Application</field>
  <field name="type">ir.actions.act_window</field>
  <field name="res_model">visa.application</field>
  <field name="view_mode">tree,form</field>
  <field name="help" type="html">
      <p class="o_view_nocontent_smiling_face">
          Create a new record!
      </p>
  </field>
</record>
	

id - id of the menu
name - Name of the menu. 
sequence - Sequence in which menu is to be displayed.
action - id of the window action created in the previous step is given here.
parent - the identifier for the parent menu item.
5. Add a view to the file
<record id="visa_application_form" model="ir.ui.view">
  <field name="name">visa.application.form</field>
  <field name="model">visa.application</field>
  <field name="arch" type="xml">
      <form>
          <sheet>
              <group>
                  <field name="name"/>
                  <field name="age"/>
                  <field name="gender"/>
                  <field name="date_of_birth"/>
              </group>
          </sheet>
      </form>
  </field>
</record>
	

name: To identify the view. 
model: Identify the target model.
arch: This is the architecture view, where its structure is defined.
<record id="visa_application_tree" model="ir.ui.view">
  <field name="name">visa.application.tree</field>
  <field name="model">visa.application</field>
  <field name="arch" type="xml">
      <tree>
          <field name="name"/>
          <field name="age"/>
          <field name="gender"/>
      </tree>
  </field>
</record>
	











07. Check on the UI.
 https://lh4.googleusercontent.com/k6hb0Zay5qXL4U77Ulk_8D-YMIK2VZuHw1c6laNTZgFdVIVlEuqHkxPsK2B98KKhGjOZz4ij0tyFNE0XiHr2Lu3Re7qEODrpjq_WsHt6r5qPm73mzI90yWWAFn4GvoF-2CgXH9kUF_5Mgi6rMhl86Js 

Here we can see the menu Visa Application created.
 https://lh6.googleusercontent.com/wg711zMjHagYKLoih_xBbVvLD_bq9bl6RWLWeyOlOkDltktMxXaWcQKhCe7bwO0XRRO9vrwgblYLHlKi8SFV8wSNgDFSwWab7A_PkZZcp9y2ktOFjXesj_aEEIt7UJPP2KPX2qGw5YlFDTaYRqEaaGU 

The form view of the visa application is shown above.
 https://lh4.googleusercontent.com/cEaEO9FoUuANJfr3uOgdkyioe71VSijBIfjo4wQdnmA5JmmcZJ2UJAMTYHcXElAi1HdpqC0kCaPNRfbK_dd5NPT1PjVzeliyl1y1uXrGAw7RgZz9f6crsGo5GYxwgA1UfsU5SirnH2vOEflamIbXngY 

The above image shows the tree view of visa application.
Similarly, we can create menus, actions, and views in Odoo.
Setting access right
We need to define who can create, read, update and delete records on adding a new data model. This includes defining a new user group when we create a new app. Odoo will not display our menus and views if we don’t have access rights.

In Odoo, we can add as many users as we need, and only the user has access to the database. We can also decide the type of information the user can access by giving access rights.
 
Odoo has two major data-driven approaches in order to regulate or restrict data access. Both are assigned to specific users via groups. A user can be a member of any number of groups, and the security mechanism is related to groups, which allows security mechanisms to be applied to users.
Now let us create a security directory on the module and add the ir.model.access.csv file to that.
Scenarios are
* All can see every record.
* Admins are a new group of users. They have to create, read, update, and delete the records.
Setting Access Rights
In order to create access rights, consider the following steps 
1. Create a file security > groups.xml
<record id="new_user_group" model="res.groups">
   <field name="name">user</field>
   <field name="users" eval="[(4, ref(base.group_user'))]"/>
</record>
	2. Add a file security> ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_visa_application,access.visa.application,model_visa_application,,1,1,1,1
3. Add the files into the __manifest__.py
'data': [
  'security/ir.model.access.csv',
  'security/group.xml',
],
	
Field Attributes
Attribute
Attributes are the properties. Every object has some attributes. In Odoo, each model, field, etc., has some properties that are attributes. Here we will be discussing some model attributes.
The most common attributes for a model are String, Required, Default, Readonly,  Help, Index, etc.
String
The common attribute used for every field is String.
name = fields.Char(string="Field name")
Here, “name” is the variable name, “Char” is the field type, and string is the attribute. The string values are always added in single or double quotes. That value will be shown on the UI.
Required
By default, required is false. We can add required=True, which will make them as mandatory field
name = fields.Char(string="Field name", required=True)
Values that can be gi           ven to required fields are True or False.
Help
Provides help tooltips for users in the UI.
name = fields.Char(string="Name", help="Enter the description")
 https://lh6.googleusercontent.com/CQqg4sVjviin9G3fQoDTCsnddr3q1Z_UHuk9y5PGN_TkdtSXs-RRDa9DuPR3O_J2xmmaXIF0VnaZHs3CT4pgCSwcwzYpxeI6mjOrdtxLMEASrfy23oy7_DH0QW4MYktZ5j6zhShN8PpUs69tdXApv-Y 

Here, I have given the help attribute to the name field.
Index
Requests that Odoo creates a Database Index on the column.
name = fields.Char(string="Record name", index=True)
The values that can be given to the index attribute are True or False. By default, the value is False.
Default
We can assign default values for the fields by using the default attributes.
name = fields.Char(string="Field name", default='John')
The default value of the name field will be the value of the default.
Readonly
If we make a field as a read-only field, then we cannot change the field value manually.
name = fields.Char(string="Name", readonly=True)
Readonly has two values, True and False, readonly=True means that the value of the field cannot be changed.
Translate
When the translate attribute is set to true, it makes the field translatable.  Depending on the user interface language, it can hold different values.
name = fields.Char(string="Name", translate=True)
Groups
It is used to make the field only available for some user groups.
name = fields.Char(string="Name", groups=”base.user_group”)
States
It helps the user interface to assign value for the necessary, readonly, and invisible attributes dynamically based on the state field's value.
Model Attributes
These are the features that are defined during the time of the creation of a new model or using the model which are already existing. Let us see the model attributes in Odoo
_auto = false - Whether we create a new database table that is set to False, override init() to create the database table. It automatically defaults to True for models and Transient models and False for Abstract models.
_log_access - Whether the ORM should automatically generate and update the Access Log Files. Defaults to whatever value was set for _auto.
_table = None - if _auto, it is the SQL table name used by the model.
_sequence = None - SQL sequence, which is used for an ID field.
_sql_constraints = [] - SQL constraints [(name, sql_def, message)].
_register = False - registry visibility by default is false.
_abstract = True - To check whether the model is an abstract model.
_transient = True - To check whether the model is a Transient model.
_name = None - the name of the model.
_inherit = () - we use the inherited attribute when we want to use a model that is already in the database.
_description = None - informal name of the models.
_inherits = {} - dictionary {‘parent_model’: ‘m2o_field’} mapping the _name of the parent objects to the names of the corresponding foreign key fields to use.
_rec_name = None - used for labeling records. By default, it is the name of the record.
_order = ‘id’ - Default order field for searching results.
_check_company_auto = False - On write and create, call _check_company to ensure companies consistency on the relational fields having check_company=True as an attribute.
_parent_name = ‘parent_id’ - The many2one field used as parent field
_parent_store = false - Set to True to compute parent_path field.
_date_name = ‘Date’ - used for default calendar view.
_fold_name = ‘fold’ - used to determine folded groups in kanban views.




Scaffold command
In Odoo, it is the process of creating a skeletal structure for a module. We can automatically design module structures using Odoo scaffolding. It saves lots of time. A module is usually a directory within a module directory. The addons path specifies the module path. Let us see how it can be done. For that, first, let us build a new module under /opt/odoo/custom add-ons, such as custom add-ons. In order to create a module structure, first of all, we must go to the Odoo-bin location using the terminal.
Enter the scaffold command to create a sample module structure. The command is given below.
./odoo-bin scaffold module_name folder_name
	module_name: Name of the module
folder_name: Directory name inside which you want to create the module.
Normally, Within a module directory, a module is a directory. The addons path specifies the module path. In order to begin, create a new module in /opt/odoo/custom addons, For example, custom addons. For creating a module structure, we must first go to the odoo-bin location using the terminal. In order to automatically generate a module structure, run the following command given below:
./odoo-bin scaffold module_name folder_name
	

By executing the above command, it creates a new module with some directories.
 https://lh4.googleusercontent.com/sEMDMbB0L0miu9VNAaZh5xkooaHdm-rYbOC4cIqs_MzzYrQ9gpd9nVGXxaddIiakWR8-Orttr5LNrscHpKvAg6W6qsA56zt_XgcgwbvjIM6rhCa7ZOwm78Fa-_fy7jcseXUjod7nsqJiSIUr9NN-Z4A 

Expanded view of the module.
 https://lh5.googleusercontent.com/t95_SM03bh66KBm_iGGitXUIkYJsBugSd-GpUBjuvhalQBfZLRUSPJ07URtHjAtbLi8wb1rpWbhsDDQQQlctejuOGfFt1LaFTwSdYAytbcXCfIi4gRtk1SxYmhH_ekuaf6YRtLB8bUEedrBDvCz2fKw 

Each module contains two required python files i.e., ‘__init__.py’ and ‘__manifest__.py’ files.
As we can see in the above image, each directory inside the module will be created by itself. It is possible to make changes to the content that is required.
1. The python files contained within the module are models.
2. Views are the XML files that help to display the records.
3. Data consists of demo data that are needed in the module. It contains XML that creates/updates databases.
4. The security file consists of configured files of access rights.
5. The __init__.py file imports all the python files defined in the module.
6. We use controllers when we need to render data to the website.
Data fields
A Model is a class that maps to the data relation (table), and it includes all of the fields and their behaviors for the data you'll be storing. Here we can discuss the type of data stored on a field and how to add them to a model.


We need to create a python file in the directory models to define the basic model.
models > school_student.py
1. Use some simple python code to add the patient details and we need to create a new model for that.
from datetime import date, timedelta
from odoo import models, fields, _, api


class SchoolStudentDetails(models.Model):
  _name = "school.student"
  _rec_name = 'admission_no'
  _description = "Student Details"

  name_id = fields.Many2one('res.partner', string="Name", required=True)
  admission_no = fields.Char(string='Admission No:', required=True,
                             copy=False,
                             readonly=True, default=lambda self: _('New'))
  b_date = fields.Date(string='DOB', related='name_id.dob')
  age = fields.Integer(string="Age", compute='_compute_age')
  father_name = fields.Char(string="Father's Name")
  mother_name = fields.Char(string="Mother's Name")
  mobile = fields.Char(string='Mobile', related='name_id.mobile')
  phone = fields.Char(string='Phone', related='name_id.phone')
  gender = fields.Selection([
      ('other', 'Other'),
      ('male', 'Male'),
      ('female', 'Female'),
  ], srting='Gender', default='other')
  blood_grp = fields.Selection([
      ('a+', 'A+'),
      ('b+', 'B+'),
      ('ab+', 'AB+'),
      ('ab-', 'AB-'),
      ('o+', 'O+'),
      ('o-', 'O-'),
  ], string="Blood Group")
  nationality = fields.Many2one('res.country', string='Nationality')
  class_history_ids = fields.One2many('school.class.history', 'student_id', string='Class History')


class SchoolClassHistory(models.Model):
  _name = "school.class.history"
  _description = "Class History"

  student_id = fields.Many2one('school.student')
  class_id = fields.Integer("Class")
  academic_year_id = fields.Date('Academic Year')
  division = fields.Char('Division')
	

The Fields are defined in the model class as the attributes, and also it is used to define where they are stored and what the model can store. The non-relational types of fields are as follows.
* Char - It is used for string values
* Text - It is used for multi-line string values
* Selection - This field is used for a selection list, and allows for dynamically generated lists of options
* Binary - It is used for storing binary field
* Html - It is similar to HTML fields
* Boolean - Store True or False values
* Date - It store date values and, it has some utilities that are:
- fields.Date.to_date(string_value): It will convert string to date object
- fields.Date.to_string(date_value): It will convert date to string value
- fields.Date.today(): Current date in string format
- fields.Date.context_today(record, timestamp): It will return the day of the timestamp in a string format 
* Datetime - It is used to store date time values (dd/mm/yyyy HH:MM:SS), and have some utils
- fields.Datetime.to_datetime(string_value): It will convert String into DateTime object
- fields.Datetime.to_string(datetime_value): It will convert the DateTime object to a string
- fields.Datetime.now(): It is the current DateTime value
- fields.Datetime.context_timestamp(record, timestamp): Converts a timestamp-native DateTime object into a zone-aware DateTime object
* Float - To Store the Float values
* Monetary - To Store amount in a certain currency
The relational field types are as follows.
* Many2one - The Many2one fields relate the many records of the co-model, which is the second model, to the current model’s record.
* One2many - The One2many field relation is the inverse of the Many2one relation. It relates one record of the co-model to many records of the model. 
* Many2many - The Many2many fields are bidirectional multiple relationships. It means that the number of records in one direction will be directed to the number of records in the other direction.
2. Here, we added the new fields to the current model, and next, we need to set the form view on the user interface for the added fields. The below code is used to view the field on the user interface.


<?xml version="1.0" encoding="utf-8"?>
<odoo>
  <record id="patient_card_view_form" model="ir.ui.view">
      <field name="name">school.student.form.view</field>
      <field name="model">school.student</field>
      <field name="arch" type="xml">
          <form>
              <sheet>
                  <div class="oe_title">
                      <h1>
                          <field name="admission_no" readonly="1"/>
                      </h1>
                  </div>
                  <group>
                      <group>
                          <field name="name_id" widget="res_partner_many2one"
                                 context="{'res_partner_search_mode': 'customer', 'show_address': 1 }"
                                 options='{"always_reload": True}'/>
                          <field name="b_date"/>
                          <field name="age"/>
                          <field name="gender"/>
                          <field name="blood_grp"/>
                      </group>
                      <group>
                          <field name="nationality"/>
                          <field name="father_name"/>
                          <field name="mother_name"/>
                          <field name="mobile"/>
                          <field name="phone"/>
                      </group>
                  </group>
                  <notebook>
                      <page string="Class History">
                          <field name="class_history_ids">
                              <tree editable="bottom">
                                  <field name="class_id" required="1"/>
                                  <field name="division" required="1"/>
                                  <field name="academic_year_id" required="1"/>
                              </tree>
                          </field>
                      </page>
                  </notebook>
              </sheet>
          </form>
      </field>
  </record>
</odoo>
	













3. Then Upgrade the module, and we can see the form view in the user interface.
 https://lh5.googleusercontent.com/CWkKfhD6AOmlCG2UNsPcO7PcIRzrWibS-7AGK-McFz5kVKGMTp_GJkBUZN6G3Tiom2lmCr0ol_zfGU0Qqt-pNtFHzQyoR5fiRDSxsjsmf24aMox7-bkriG8TvcImS69qElZTIn-4YF3IDRA-8A3jJQI 

Float fields
The Float fields in Odoo are mainly used to store the numerical values or to store float values, and the null value is not supported. If there is no value for the field, then it returns 0.0.  We might want to give the end user control over the decimal accuracy when using float fields. Here, we may add a Cost Price field with user-configurable decimal accuracy to the Library Books model. Maintaining the precise value of the float values is difficult (for example, 125.325). Additionally, the value of this kind of value varies depending on the platforms and environments.
Decimal accuracy
A measurement tool called decimal accuracy enables the user to choose the floating location of various categories, such as a unit of measurement and pricing. Choosing how many values in each category should be shown as decimals is made much easier with the help of this feature.
Let's use an example to go through this.


 https://lh6.googleusercontent.com/8bBo2KvTv1iWFpMFEdK5IYE-8kdhuqBwk7Tkv9QdHkCiJF0F_a9y12ZkMhKNIlghbKGlEl47FbIN4p0iNxalYIJCEDeGEbPEv5fifvyteIUMuby_EL5II3rESM927Z0EKVcKFu-sph47wS5AJOgTSn8 



Here, we can see that the decimal accuracy of the product unit of measure is 2, and looking at the product unit of measure.
 https://lh4.googleusercontent.com/HjsCIjJO3slqFBLrbqvX46VSegPqNiIo2eCvlfGyIzLcZ3uA2fLSqE4-jBTw-JQcQxl1P6sTmCUI8P_9vfF3sj5CXt57qMoDwWQwe0nphoLClrcVZ267zUhpgJ5eVbw3pJzYuDq7_6WxDx0MUsDrBi4 

 
Here we can see the decimal points are 2; When we give the decimal accuracy as five.
 https://lh6.googleusercontent.com/ive5P9H0lYjn4PNX6h0YfeoGKfMKMUUiuX5rv9LVmFnVcgBA8mc1h0GQHrhAy1aOTjEtvZoTfj7PSjSVZM8oj9Ra5RX0g5VzxLQx-1NTDdSjUki5eNvwnkwRP4r9kZT9hwzgUR0qF0sI6MYH0_xZ1nk 

Here we can see the decimal point as 5.
 https://lh4.googleusercontent.com/QkpdFEi4Y5LieMQBQjnqsHwbBZdnTF1E4-1JDJgSE-s9_036vg3SLrfRuWfiyOm5ZEa4tPKdXQmEOCfUzEczENfXYC5K1EFeLFf3aUhNbDyFNiu01B9qDDG-8I6fPMtinJPaWHL1Ds-MxjKB3zJIfoU 

We can create the float fields by code using the code below. At default, the decimal accuracy will be 2.


fee = fields.Float(string='Fee')
	

The result is,


 https://lh5.googleusercontent.com/t1L8zkS6bKE0gXIsu4zreegL7k7XASpWy3IddvriCWp80diTb-4m8pgw-95vcMa0AnPXmEUcNy7K1dnCfrcine7l872cxTOBTrbcXJLlBSDxMf5TC9zyu6063gQJqxTrggV_yogBmaKSKDY9z7P52hk 

Odoo has some tools for determining the decimal location of a value. That is described further down.
1. float_compare(): The Odoo tools directory contains the float comparison function. This function is helpful when we need to compare two values.
2. float_is_zero(): This is a function that checks if a float is zero.  If the given value can be considered zero using the precision value and rounding digits specified, this Odoo function returns true.
4. float_round(): This is also defined in float utils.py, which is located in the Odoo tools directory. After rounding the input value using the specified rounding parameters, this function returns the value that was supplied.
5. float_repr(): This method returns the textual representation of the given value with the chosen decimal precision. This is used to get the value of an afloat string. Rounding isn't a term used to describe it. It's possible that the erroneous value will be returned as a result of this. You can instead use the float round function ().
6. float_split_str(): This function is useful when you need to divide a float value from both an integer and a fraction value. It divides the given value accurately into its decimal and unitary parts. The float value is first rounded using the float round() function, which was previously covered. The rounded number is subsequently converted to a string using the float repr function (). A tuple will then be returned after the value has been divided into its integer and fractional components.
7. float_split(): This function is similar to float split str(), but instead of string values, it returns integer values.
Relational fields
The relational fields in Odoo are used to link one model to another model. In any real business scenario, we must create relational links between different models to implement and develop our business as per the needs. The three types of relational fields in Odoo are
* Many2one field
* One2many field
* Many2many field
Many2one fields:
To connect the current object to another object, use the Many2one field. It is the parent of this object. It links a record from the current model to a record from the second model, also known as the co-model. The _id suffix appears in many2one fields.
field_id = fields.Many2one(‘comodel_name’, ‘Field Name’)
comodel_name: It is the name of the related model.
For example, if we want to link our model to the 'res.partner' model and call the field 'Contact,' we may create a Many2one field called 'partner_id,' which looks like this:
partner_id = fields.Many2one('res.partner', 'Contact')
	If we need to retrieve a contact's name, which is contained in the comodel as a character field called 'name,’ Then we can use partner_id.name
One2many fields:
The inverse of the Many2one relationship is the One2Many field relation. The relationships between the many rows of the parent and the child model can be created using this field. The usual,
One2many fields have the _ids suffix.
The syntax for writing the One2many field:
field_ids = fields.One2many('comodel_name', 'inverse_name', 'Field Name')
	comodel_name: It is the name of a related model.
inverse_name: It is the name of the inverse Many2one field in comodel.
The values of fields behave like a list. Therefore we can access the data using a loop.
for rec in self.field_ids:
  print(rec.name)
	For example, consider the order_line_ids field defined in the model ‘sale.order’
for rec in self.field_ids:
  print(rec.name)
	

Here, the ‘order_line_ids’ is the One2many field in the comodel ‘sale.order.line’, which has a Many2one field ‘order_id’, that is related to the ‘sale.order’ model. If you want to get the product of the ‘order_line_ids’, which is stored in the field called ‘product_id’ in the comodel, Then you can use:


for rec in self.field_ids:
  print(rec.name)
	Many2many fields:
Multiple bidirectional relationships between two separate models are created using Many2many fields. Each record on one side can be connected to any number of records on the other.
The _ids suffix is used in many2many fields by convention.
The syntax for writing the Many2many field:
field_ids = field.Many2many('comodel_name', 'Field Name')
	

comodel_name: which is the name of a related model. The values of fields behave like a list. Therefore we can access the data using a loop. 


for rec in self.field_ids:
print(rec.name)
	

Many2many fields have some optional attributes. Optional attributes are ‘relation,’ ‘column_1’, and ‘column_2’.
relation: It stores the relation in the database.
column_1: It is the column referring to our model records in the table ‘relation.’
column_2: It is the column referring to our comodels records in the table ‘relation.’
For example, consider the ‘tag_ids’ field defined in the model ‘sale.order.’
tag_ids = fields.Many2many('crm.tag', 'sale_order_tag_rel', 'order_id', 'tag_id', string='Tags')
	

Here, the ‘tag_ids’ is the Many2many field in the comodel 'crm.tag’, we can find a relational table called ‘sale_order_tag_rel’ in the database, having two columns ‘order_id’ and ‘tag_id.’
Constraints
Any real-world business scenario has a chance that users provide inaccurate data. Constraints allow us to stop users from submitting inaccurate data. In order to prevent inaccurate data from being recorded before the record is saved, constraints are limits set on the record.
Two approaches
The two tools given by Odoo for automatically validating invariants are Python Constraints and SQL Constraints.
SQL Constraints:
SQL Constraints are defined on the model using the class attribute _sql_constaints. This belongs to the part of PostgreSQL.
Syntax for writing SQL Constraints:
_sql_constraints = [(name, sql_def, message)]
name: SQL Constraints name.
sql_def: PostgreSQL syntax of the constraint.
message: error message.
For example,
tag_ids = fields.Many2many('crm.tag', 'sale_order_tag_rel', 'order_id', 'tag_id', string='Tags')
	This is the sql_constraints taken from the sale order. It aims to verify the confirmed sale order has a confirmation date. If the sql_constraints fails, then it will show an error message. The SQL constraint will always be specified in the field declaration section of the Python code; it is defined before entering the coding section.
Python Constraints:
Data consistency can be efficiently ensured using SQL constraints. To ensure data consistency in other situations, we might need to utilize more complicated tests. In such situations, we can use python constraints.
The Python constraint is a method decorated with constraints(). It is included on a record of the set. Decorators are used to specifying which fields are involved in the constraints. When a field is changed, these constraints are automatically considered.
For example,
@api.constrains('product_id')
def check_product_is_not_kit(self):
  if self.env['mrp.bom'].search(['|', ('product_id', 'in', self.product_id.ids), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', self.product_id.product_tmpl_id.ids),('type', '=', 'phantom')], count=True):
      raise ValidationError(_("A product with a kit-type bill of materials can not have a reordering rule."))
	

It is the sql_constraints that were taken from the warehouse, and it checks to make sure that any reordering rules cannot apply to a product with a kit-type bill of materials. If it doesn't work, an error message appears.
Computed Fields
In any real-world business scenario, there are some fields with values derived from other fields. The calculated values are either from the same records or from records that are connected to them. We can take advantage of computed fields in this situation. We can use an Odoo function to calculate the values for the fields.
Computed fields in Odoo have the same definition as other ordinary fields in Odoo. The attribute calculate, which is used to give the name of the function used for its computation, is the only exception. At runtime, computed fields are dynamically calculated. Unless you add such support directly by yourself, they are not searchable or writable.
A computed field has the same attribute ‘compute’ as other normal fields when it is declared. The name of the function as a string or as a function is the value for the compute attribute.
Dependencies:
Usually, the values of other fields affect the values of computed fields. Therefore, using the decorator depends(), we can define those requirements on the compute method. At runtime, the computation function performs dynamic calculations. We must avoid from recalculating the value inefficiently.
 Hence, it needs to be aware of the other fields that depend on it and must include those fields in the decorator depends ().
For example,
amount = fields.Float('Amount')
total = fields.Float('Total', compute="_compute_total")
@api.depends('amount')
def _compute_total(self):
  for rec in self:
      rec.total = 2.0 * rec.amount
	

Here, we can calculate the total by using the function _compute_total. By default, computed fields are not kept in the database. In order to store the record in the database, we can use the store property.
 We can use the store = True flag.
For example,
total = fields.Float('Total', compute="_compute_total", store=True)
	

So, rather than having to be recomputed at runtime, they may be obtained just like any other regular fields. The ORM will be able to determine when these stored values need to be updated and recalculated.
Inverse Function
We know that by default, the computed fields are read-only. Which means the user couldn’t set the value for the computed fields. In some cases, it might be useful to still be able to set a value directly. For that, Odoo provides the ability to use an inverse function:
amount = fields.Float('Amount')
total = fields.Float('Total', compute="_compute_total")
@api.depends('amount')
def _compute_total(self):
  for rec in self:
      rec.total = 2.0 * rec.amount
	 
	

The field is set by a compute method, and the field's dependencies are generated by an inverse method. When saving a record, the inverse method is called, and the compute method is activated whenever one of its dependencies changes.
Related Fields
We need to demonstrate the benefit of a field from a relational model to the current model in any real-world business scenario where we have some fields. In such a situation, we can use related fields. To do that, we need to specify the attribute related.
For example, we have a Many2one field partner_id, and its comodel is res.partners, and a related field is partner_name:
partner_id = fields.Many2one('res.partners')
partner_name = fields.Char('Name', related="partner_id.name")
	Related fields are read-only and not copied by default, nor are they stored in the database. Using the store = True attributes, we can store the field record in the database.
partner_name = fields.Char('Name', related="partner_id.name", store=True)
	Reference Fields
We have different types of relational models, many2one, one2many, and many2many. In relational models, we can create relationships between different models. A reference field helps us to create dynamic relationships between models. Relational models only permit the relationship between the two models by defining a related comodel in advance. However, if we utilize the reference field type, the user can select a related model from a list of options and a related record from that model.
We must first choose the target model before choosing the record in the reference field. For instance, let's say we need a field reference. We may sometimes need to choose a manufacturing order, sale order, or purchase order as a reference. We can use Reference fields in this situation.
reference_field = field.Reference(selection='', string='field name')
	For this, we use the selection parameter. We must assign the model and its name to this parameter.
For example,
reference = fields.Reference(selection="[('sale.order', 'Sale Order'), ('purchase.order', ' Purchase Order')]", string="Reference")
Here, we can choose a Sale Order or Purchase Order, from the same field. Also possible to selection from a function.
reference = field.Reference(selection="get_model")
@api.model
def get_model(self):
  models = self.env['ir.model'].search([])
  return [(model.model, model.name), for model in models]
	Returned values must be a list.
Abstract Model
Main super-class for regular database-persisted Odoo models.
All Odoo models are created by inheriting from this class:
from . import models, fields
class AbstractModel(models.AbstractModel):
  _name = "model name"
  Field = fields.Char(string="field label")
	Transient model
Model super-class for transient records, intended to be only temporarily persistent, that are regularly vacuum-cleaned. 
A temporary paradigm has made it easier to manage access rights. New records can be made by any user at any time. They can only access the records they have created, though. The superuser has unrestricted access to all Transient Model records
from . import models, fields
class TransientModel(models.Transientmodel):
        _name = "model name"
        Field = fields.Char(string="field label")
	Inheritance
There are some situations in every module customization that require us to inherit some models in order to meet our business needs.
We can use the _inherit properties to add new features to an existing model. Odoo has two inheritance techniques that allow you to modularly extend an existing model.


 odoo-crm 

Classical Inheritance:
The classic inheritance where we use both _name and _inherit attributes together. In addition, the new models get all methods and fields from their base.


For example: Parent model
class ParentModel(models.Model):
  _name = 'parent.model'
  name = fields.Char()
Child Model
class ChildModel(models.Model):
  _name = 'child.model'
  _inherit = 'parent.model'
  date = fields.Date()
	Here, we can access all functionality of the parent model from the child model.
Prototype Inheritance:
The prototype inheritance can be used to add a new field or a function to an existing model. We will only need the _inherit attribute for this type of inheritance. The new existing model is used in place of the child model.
For example: Parent model
class ParentModel(models.Model):
  _name = 'parent.model'
  name = fields.Char()
Child Model
class ChildModel(models.Model):
  _name = 'child.model'
  _inherit = 'parent.model'
  date = fields.Date()
	When we check the database, we can see that the model now includes the newly created fields. Additionally possible is the create and override of methods.
Delegation Inheritance:
Delegation inheritance allows us to sink another model to your existing model without changing the views. We use the _inherits attribute for this type of inheritance.
For example:
class ProductTemplate(models.Model):
 _name = "product.template"
class ProductProduct(models.Model):
 _name = "product.product"
 _inherits = {'product.template': 'product_tmpl_id'}
 Product_tmpl_id = fields.Many2one('product.template', 'Product Template', auto_join=True, index=True, ondelete="cascade", required=True)
	View Inheritance:
View inheritance can be used to replace an existing view. The content of their parent view can be added or removed by these extensions. We can expand the current view by using the inherit id field.
For example:
<record id="inherited_model_view_form" model="ir.ui.view">
      <field name="name">inherited.product.form.inherit.test</field>
      <field name="model">product.template</field>
      <field name="inherit_id" ref="product.product_template_form_view"/>
      <field name="arch" type="xml">
          <xpath expr="//field[@name=name]" position="after">
              <field name="new_field"/>
          </xpath>
      </field>
  </record>
	expr: expression for the parent view's single element selection Position: An operation that applies the matched elements, examples include operations that apply elements inside, outside, after, or before attributes.






04. Server-Side Development
Model Methods and Decorators


The class in Odoo models contains field declarations as well as business logic methods. The method defined for a button click is one example of a simple type of method.
For example, clicking the confirm button in a form view changes the state from 'Draft' to 'Confirmed.'
The function will first be declared from the XML:
button name="action_confirm" string="Confirm" type="object"/
	The form view will include a 'Confirm' button, whose python action is specified in the button's name attribute (action confirm).
state=fields.Selection([(draft,'Draft'),(confirmed,'Confirmed')],default='draft')
def action_confirm(self):
  self.state = 'confirmed'
	In this case, action confirm is a Python method with self as an argument.'self,' the first argument method of Odoo models, can take additional arguments.
Decorators.
Decorators allow you to change the behavior of a method. It simply adds functionality to a function before returning it.
@api.autovaccum
The daily vacuum cron job calls the methods decorated by this decorator (model ir.autovacuum). It is used for tasks that do not require a specific cron job.
@api.constrains(*args)
Fields from the particular model are the arguments given to the decorator. When any of the fields are altered, the function will be called.
@constrains only support field names, not dotted fields(related fields, Eg:partner_id.city).
@constrains will only be executed if the defined fields in the decorated method are used in the model's create or write function.
It implies that fields won't cause the function to be called during record generation if they don't exist in the view.
An override of create is required to ensure that a constraint is always active.


@api.depends
This decorator can be used to declare the field dependencies of the "compute" method.Each argument must be a string made up of a dot-separated list of field names:


pname = fields.Char(compute='_compute_pname')
@api.depends('partner_id.name', 'partner_id.is_company')
def _compute_pname(self):
    for record in self:
        if record.partner_id.is_company:
            record.pname = (record.partner_id.name or "").upper()
        else:
            record.pname = record.partner_id.name
	@api.depends_context(*args)
This decorator can be used to declare the context dependencies of a non-stored "compute" method. Each passed argument is a key in the context dictionary.


price = fields.Float(compute='_compute_product_price')
	

@api.depends_context('pricelist')
def _compute_product_price(self):
    for product in self:
        if product.env.context.get('pricelist'):
            pricelist = self.env['product.pricelist'].browse(product.env.context['pricelist'])
        else:
            pricelist = self.env['product.pricelist'].get_default_pricelist()
        product.price = pricelist.get_products_price(product).get(product.id, 0.0)
	

@api.model
Decorate a record-style method in which self is a recordset but the contents of its are irrelevant; only its model is.
@api.model
def method(self, args):
    //Add your method here
	@api.model_create_multi
Decorate a method with a list of dictionaries if it creates several records. It is referred to as a list of dictionaries.
record = model.create(vals)
records = model.create([vals, ...])
	

@api.onchange(*args)
The view's fields will be passed as arguments to the 'onchange' decorator. The method will be called when the view's field is modified. The method is called on a pseudo-record that contains the form's values. The field assignments on that record are automatically returned to the client.
@api.onchange('partner_id')
def _onchange_partner(self):
    self.message = "Dear %s" % (self.partner_id.name or "")
    return {
      'warning': {'title': "Warning", 'message': "What is this?",'type': 'notification'},}
	

@onchange only supports simple field names, relational fields are not supported(partner_id.city)
Because @onchange returns a recordset of pseudo-records, trying to call any of the CRUD methods (create(), read(), write(), unlink()) on this recordset results in undefined behavior, because the records may not yet exist in the database.
Instead, we could use the update() method or easily set the field as in this example.
Onchange cannot be used to modify a one2many or many2many field.
@api.ondelete(*, at_uninstall)
Mark a method to be executed during unlink().
The methods decorated with @ondelete should raise an error if certain conditions are met, as well as the method should be named either _unlink_if_<condition> or _unlink_except_ <not_condition>.
@api.ondelete(at_uninstall=False)
def _unlink_if_user_inactive(self):
    if any(user.active for user in self):
        raise UserError("Can't delete an active user!")
# same as above but with _unlink_except_* as method name
@api.ondelete(at_uninstall=False)
def _unlink_except_active_user(self):
    if any(user.active for user in self):
        raise UserError("Can't delete an active user!")


	Parameters:
at_uninstall (bool) – When the module that implements this function is uninstalled, this decorated method will be called. It should nearly always be False to prevent those errors from occurring upon module uninstalling.
@api.returns(model, downgrade=None, upgrade=None)
For methods that return model instances return a decorator.
Parameters
* model – For the current model, a model name or'self'
* downgrade – The fuction, downgrade(self, value, *args, **kwargs) that converts a record-style value to the traditional-style output.
* upgrade – A function upgrade(self, value, *args, **kwargs) is used to convert a traditional-style value to a record-style output.
The parameters self, *args, and **kwargs are passed to the method in the record style.
The decorator modifies the method's output to be in the api style: id, ids, or False for the traditional form style and the recordset for the record style.
@model
@returns('res.partner')
def find_partner(self, arg):
    # return some record
# output depends on call style: traditional vs record style
partner_id = model.find_partner(cr, uid, arg, context=context)
# recs = model.browse(cr, uid, ids, context)
partner_record = recs.find_partner(arg)
	It should be noted that the decorated method must satisfy to that convention.
Those decorators are automatically inherited: A method that overrides an existing decorated method will be decorated in the same way.@returns(model).
Working With env Variable
In the Environment, the ORM stores a variety of context data, including the database cursor (for database queries), the current user (for access permissions verification), the current context (for storing arbitrary metadata), and caches.
Every recordset has an environment, which can be accessed with env and provides access to:
* the current user (user)
* the cursor (cr)
* the superuser flag (su)
* or the context (context)
When a recordset is created from another recordset, the environment is inherited. Use Environment to get an empty recordset in a model and query that model.
>>> self.env['sale.order']
sale.order()
>>> self.env['sale.order'].search([('state','=','draft')])
sale.order(4,7,9,17,33,)
	env.ref(xml_id, raise_if_not_found=True)
The record matching the XML id will be returned:
Eg:
>>> self.env.ref('base.user_admin')
res.users(2,)


	

Env.user
The current environment user will be returned. The output that is returned will be a record from res.users.
env.lang
The language code for the current environment will be returned. The type will be str.
env.company
It will return the current company and will be a record of model res.company.
Fallback to the current user's main company if the context (allowed company ids) is not specified. When the allowed_company_ids context key content is invalid or unauthorized, it will generate an AccessError.
env.companies
Return a record set of the user's enabled companies.
Fallback to the current user's main company if the context (allowed company ids) is not specified. When the allowed_company_ids context key content is invalid or unauthorized, it will generate an AccessError.
Altering the Environment
with_context([context][, **overrides]) → records.
This method generates a new recordset with an additional context.
Eg:
# current context is  {'key1': True}
result1 = records.with_context({}, key2=True)
# result1._context is {'key2': True}
result2 = records.with_context(key2=True)
# result2._context is {'key1': True, 'key2': True}
	with_user(user)
If the user is not the superuser, return a new version of this recordset connected to the specified in non-superuser mode.
with_company(company)
Return a new instance of this recordset with altered context, such that:
result.env.company = company
result.env.companies = self.env.companies | company
	

Parameters:
company (res_company or int) – The primary company in the new environment.
If a current user is using an unauthorized company, accessing the company(ies) on the environment may result in an AccessError if not done in a sudoed environment.


with_env(env)
Return a new version of this recordset that is bound to the environment provided.
Parameters:
env (Environment)
sudo([flag=True])
Depending on the flag, returns a new version of this recordset with superuser mode enabled or disabled. The superuser mode has no effect on the current user and simply bypasses access rights checks.
SQL Execution
The cursor for the current database transaction is represented by the cr attribute on environments.
It allows you to run SQL directly rather than through the ORM, which is useful for queries that are difficult to define through the ORM. (e.g., complex joins) or for performance reasons:
self.env.cr.execute("some_sql", params)
	While all models are using the same cursor and the Environment includes a variety of caches, changing the database in raw SQL requires invalidating these caches or else further the model usage would become incoherent. Clearing caches is required when using CREATE, UPDATE, or DELETE in SQL, but not when using SELECT (which simply reads the database).


Caches can be cleared using the invalidate cache() function.
invalidate_cache(fnames=None, ids=None)
Invalidate the record caches after some records have been modified. If both fnames and ids are None, the entire cache is cleared.
Parameters
* fnames – The list of modified fields, or None for all fields.
* ids – The list of modified record ids, or None for all.
Creating Records
New records are created for a certain model using the create() function. The values from the list of dicts vals list and, if necessary, those from the default get() function are used to initialize the new records.
Parameters
Field values as a list of dictionaries for the model:
[{'field_name': field_value, ...}, ...]
Eg:
partner = self.env['res.partner'].create({
    'name':'Test Partner',
    'is_company':True
})
	

An AccessError will be raised
* If the user is not required to grant access to the requested item.
* If the user tries to bypass access rules for creating the requested object.
A ValidationError will be raised
* If a user attempts to enter a value that is invalid for a field that is not a selection.
A UserError will be raised
* If the operation results in the creation of a loop in an object hierarchy (such as setting an object as its own parent)
Updating Records
It may occasionally be necessary to update records by changing the values of some of their fields.
We can use the update() method of a model for this.
A field value can be assigned to a record in one of three methods.
1. Assi gning values directly to the attribute representing the field of the record.
- We can assign a value to a field directly.
self.test_boolean = True
	self is the object of the record of which the record’s field value is updating.test_boolean is a boolean field.
2.update() method
- To change the value of a field, we can use the update() method.
self.update({
  'start_date': fields.Date.today(),
  'test_boolean': True
})
	start date and test_boolean is the field which we need to update. We can pass to the update method a dictionary that maps the field names to the values you want to set.
3.write() method
- We can provide the update method with a dictionary that associates the field names with the values you want to set.
self.write({
  'start_date': fields.Date.today(),
  'test_boolean': True
})

	

- The last two options require one database call for each record and each field, whereas this method updates all records with the specified values in a single database operation and is applicable to recordsets of any size. It has some restrictions, though: If the records are not yet in the database, it does not work. When writing relational fields, also requires a special format similar to the one used by the create() method.
(0, 0, { values }) link to a new record that needs to be created with the given values dictionary.
(1, ID, { values }) update the linked record with id = ID (write values on it).
(2, ID) remove and delete the linked record with id = ID (calls unlink on ID, which will delete the object completely and the link to it as well).
(3, ID) cut the link to the linked record with id = ID (delete the relationship between the two objects but do not delete the target object itself).
(4, ID) link to existing record with id = ID (adds a relationship).
(5) unlink all (like using (3, ID) for all linked records).
(6, 0, [IDs]) replace the list of linked IDs (like using (5) then (4, ID) for each ID in the list of IDs).
Searching Records
For business logic methods to work, records must be searched based on certain criteria. In Odoo, we can accomplish this by using the search() method.
Let's look at an example: in this case, we're searching for partners whose 'company type' is 'company.'
domain = [('company_type','=','company')]
partner = self.env['res.partner'].search(domain)
>>>res.partner(1,2,3,6,9,10,13,15,16,17)


	

The domain will be returned by the search method. A domain is a collection of criteria, with each criterion consisting of a triple (either a list or a tuple) of (field_name, operator, value).
● field_name (str)
A current model's field name, or a relationship traversal through a Many2one using dot-notation,
 e.g. 'street' or 'partner_id.country'
● operator (str)
a comparison operator that compares the field_name to the value, Valid operators are:
= equals to
!=not equals to
>greater than
>=greater than or equal to
< less than
<= less than or equal to
=? equals to or unset (if the value is either None or False, returns true; otherwise, it acts like =)
=like - field_name is matched to the value pattern. In the pattern, an _underscore represents (matches) any single character; the percent sign %, which matches any string of 0 or more characters.
like - matches the field_name against %value% pattern. Similar to =like, but before matching, wraps the value in '%.'
not like - it doesn’t match against the %value% pattern.
ilike - case insensitive like.
not ilike - case insensitive not like.
=ilike - case insensitive =like.
not in-is unequal to all of the items from value.
child_of-Is a child (descendant) of a value record (value can be either one item or a list of items).
Takes the semantics of the model into account (i.e., following the relationship field named by _parent_name).
parent_of - Is a parent (ascendant) of a value record (value can be either one item or a list of items).
Takes the semantics of the model into account (i.e., following the relationship field named by _parent_name).
value
With the operator, the variable type must be comparable to the named field.
Domain criteria can be combined using prefix logical operators:
'&' - logical AND
'|'- logical OR
'!'- logical NOT
Note:
Mostly to negate combinations of criteria. Individual criterion generally has a negative form (e.g., = -> !=, < -> >=), which is simpler than negating the positive.
Example:
To search for partners named ABC, from Belgium or Germany, whose language is not English:
[('name','=','ABC'),
('language.code','!=','en_US'),
'|',('country_id.code','=','be'),
    ('country_id.code','=','de')
	This domain is interpreted as
(name is 'ABC')
AND (language is NOT english)
AND (country is Belgium OR Germany)
	In the search method, the other keyword arguments that match.
•offset=N: This is used to skip the first N records that match the query. Its default is 0.
• limit=N: This indicates that N records will be returned. By default, there is no limit.
• order=sort_specification: By default, the order is the _order attribute of the model class.
• count=boolean: If True, it will return the number of records in the recordset. The default is False
Note:
The search() method with the count attribute and search_count() function both give the same result.


Filtering Records
When we already have a recordset and only need a subset of it to satisfy certain requirements, we will occasionally use the filtered() method to remove the relevant entries from the recordset.
The filtered() function accepts parameters in the form of functions or dot-separated lists of field names. It will return the records that satisfy the condition, which may be empty.
# only keep records whose company is the current user's
records.filtered(lambda r: r.company_id == user.company_id)
# only keep records whose partner is a company
records.filtered("partner_id.is_company")
	Sorting Records
A recordset can be sorted using the sorted() method.
* The key is returned along with a self-ordered Recordset.
* The order attribute can be used in the function to sort the returned recordset if the recordset was retrieved using the search() method.
partner = self.env['res.partner'].search([(),order='id'])
	All of the partners will be returned, sorted by record 'id' in ascending order.
* The _order attribute of the model can also be used to sort the model's records.
* Use the sorted() method to sort a recordset.
partners = self.env['res.partner'].search([('company_type','=','company')])
partners.sorted(key='id')

	Internally, the sorted() method retrieves the data from the field specified as the key argument. It then returns a sorted recordset by using Python's native sorted method.
Reverse=True, another optional input, returns a recordset in reverse order.
partners = self.env['res.partner'].search([('company_type','=','company')])
partners.sorted(key='id', reverse=True)


	

Extending create() and write()
Extending create() method
To include any additional functionality while creating a record of the model, we can extend a model's create() function.
Let's use adding a "notes" field to the "sale.order" as an example.
In this case, editing the notes field will result in a "UserError" for users who are not members of the "Administration/Access Rights" group.
class SaleOrder(models.Model):
  _inherit = 'sale.order'
  notes = fields.Text(string='Notes')
  def create(self,vals):
      res = super(SaleOrder,self).create(vals)
      if 'notes' in vals and not self.env.user.has_group('base.group_erp_manager'):
          raise UserError(_("You cannot edit the field 'notes'"))
      return res


	

As an example of the write() method, we can do the same thing.
Before writing, we evaluate the group and occurrence of the field in the vals to write, and if there is a problem, we raise a UserError exception.
def write(self,vals):
  res = super(SaleOrder,self).write(vals)
  if 'notes' in vals and not self.env.user.has_group('base.group_erp_manager'):
      raise UserError(_("You cannot edit the field 'notes'"))
  return res


	Overriding _name_search()
By redefining name search, we can search for a record in the Many2one widget using any field in the model.
Let’s take an example: In the Many2one field, we can search for a partner  by name, phone number, or email.
class ResPartner(models.Model):
  _inherit = 'res.partner'
  @api.model
  def _name_search(self, name, args=None, operator='ilike', limit=100, name_get_uid=None):
      args = args or []
      domain = []
      if name:
          domain = ['|', '|', ('name', operator, name), ('phone', operator, name), ('email', operator, name)]
      return self._search(domain + args, limit=limit, access_rights_uid=name_get_uid)

	To begin, we must inherit the res.partner class and override the _name search() function.
Most of the arguments we receive are passed on in their original form to the method's super() implementation:
* name is a string containing the value that the user has typed thus far, the user input.
* As a prefilter for the potential records, args can either be None or a search domain. (It could be derived from the domain parameter of the Many2one relation, for instance.)
* operator is a string that contains the match operator. Generally, you will have 'ilike' or '='.Customizing how records are searched
* The maximum number of rows to retrieve is specified by limit.
* name_get_uid can be used to specify a different user when calling name_get() to compute the strings to display in the widget.
Traversing through Recordset:
A collection of related items or records can be referred to as a record set. A single record or a record set of length 1 makes it simpler to access any field value. If there are multiple records, accessing any field value of the record by simply referring to the field name is just not feasible. If the length of the record set is greater than one, an error will be generated when attempting to access any field value via the dot method. ( Eg: self.partner_ids.name).
Consider the model res.partner, which contains all of the Contact records saved in our Odoo Database. If we want to access a record that contains the name of a contact, then we can simply use partner.name if the partner variable holds a res.partner record. It is not feasible with more than one record in the partner record set.
A record set with more than one length can be traversed using the mapped() method.
Using an example, let's discuss the process.
Consider the two models, student.parent and student.student, which store the records of the students and parents of an educational institution.
from odoo import fields, models
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email")
  partner_id = fields.Many2one('res.partner', string="Partner", required=True)
  date = fields.Date(string="Date", default=fields.Date.today())
  parent_id = fields.Many2one('student.parent', string="Parent")



	

from odoo import fields, models
class Parent(models.Model):
  _name = "student.parent"
  _description = "Parent"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email")
  partner_id = fields.Many2one('res.partner', string="Partner", required=True)
  date = fields.Date(string="Date", default=fields.Date.today())
  student_ids = fields.Many2many('student.student', string="Students")


	

The Parent model includes a relational field to store all students related named student_ids. If the student_ids field contains a single student record, the name of the corresponding student can be obtained by referring to student_ids.name. It is, however, impossible if there are multiple student records in the student_ids field. To retrieve all the names of students we can define a method called get_student_name(). To retrieve all student names from a recordset of student.student, we can use the mapped() method.
def _get_students_name(self, parents):
  names = parents.mapped('student_ids.name')

	

Here, the mapped(path) method will traverse the fields of the recordset, where the path is a string containing the field name separated by dots. The mapped() method will create a new recordset that includes all the fields related to that field in the path to all elements in the current recordset. This recordset is created for each field given in the path. A new recordset will be created in this example for the fields name and student_ids.
names variable will contain a list of all names of students. A recordset can also be returned using this. Instead of returning any basic type field, the mapped() method will return a recordset if a relational field is provided as the path.mapped() will return a Python list in the case of a basic field.
One thing to keep in mind is that using mapped() may not be efficient because it operates in memory within the Odoo server by repeatedly traversing relations and thus making SQL queries. In such cases, using the search() method with an appropriate domain makes more sense.
Working with read_group()
We may occasionally need to aggregate records from a database in order to retrieve them. In such cases, the read_group() method can be used to obtain aggregate results. Using the read group() method, for example, we can obtain the average price of the previous month's purchases.
Using an example, let's talk about the method. Consider a model student.student who keeps track of all student records.
from odoo import fields, models
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email")
  category_id = fields.Many2one('student.category', string="Category")
  partner_id = fields.Many2one('res.partner', string="Partner", required=True)
  date = fields.Date(string="Date", default=fields.Date.today())
  total_grade = fields.Float(string="Total Grade")
	Create another model to save all Student Category records.
from odoo import fields, models
class StudentCategory(models.Model):
  _name = "student.category"
  _description = "Student Category"
  name = fields.Char(string="Name", required=True)
  description = fields.Text(string="Description")
	 
Define a new method _get_average_score(), to get the average score of students who use the read_group() method and are grouped by category.
def get_average_cost(self):
  grouped_result = self.read_group(
      [('total_grade', "!=", False)], #domain
      ['category_id', 'total_grade:avg'], #fields
      ['category_id'] #group_by
  )
  return grouped_result


	

The group_by() method retrieves data using SQL group by and aggregate functions. In the example method, three parameter values are passed.
* Domain: This domain was used to filter records based on this. Condition. Only students who have a value in the total_grade field are considered for rest operations in this example.
* Fields: List of fields to retrieve from the record. The field parameter's possible values are listed below.
   * field_name: The name of the field to be included in the final result. For the group_by parameter, all fields passed as a single field_name must also be added. Otherwise, an error message will be displayed.
   * field_name:agg: You can pass a field name as an aggregate parameter. This link will take you to a list of aggregate functions.postgresql
   * name:agg(field_name): This is the same as before. But, with this syntax, you can give the column aliases, such as average_grade:avg('total_grade')
* Group by: You can pass a list of fields as the group by argument. The result will be grouped using these fields. When working with date type or datetime type fields, there are some changes. To apply the date grouping based on the various time durations, like date release: month, you can pass the group by function for something like the date and datetime column. This will apply grouping based on the months.
There are a few more parameters that can be passed.
* Offset: The optional number of records can skip.
* Limit: Return a maximum number of records.
* Order by: Which field determines how the result is ordered.
* Lazy: Boolean type argument that can be passed, which is set as True by default. Its results are still only grouped by the first group by if true is passed, and the remaining group bys are stored in the __context key. If false, in one call, all the group bys are done.
Extending Methods
In some cases, it might be necessary to add some additional operations to an already existing Python method. This is known as extending methods. When we add new features or customize existing model classes, we will need to modify any existing business logic. As a result, in some cases, we will need to modify the existing methods to adapt to the new features.
Let's take a look at this use case by extending a custom function. Consider a model that stores all of an educational organization's student records.
from odoo import fields, models, api
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  partner_id = fields.Many2one('res.partner', string="Partner")
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email", required=True)
  status = fields.Char(string="Status")
	

Add a button to the form view of a student record that updates the student's status field value.


<header>
<button name="update_status" string="Update Status" class="oe_highlight"
type="object"/>
</header>
	

Define the update_status() method in the python file.The write method is used in this case to add a value to the student record set.


def update_status(self):
  self.write({
      'status': "Status Updated"
  })
	Consider whether it is necessary to inherit the current student model in order to add certain functionalities. To accomplish this, we can inherit the student model and add an extra date field date_status_last_updated, which will record the date the status was last updated. 


class StudentInherit(models.Model):
  _inherit = "student.student"
  date_status_last_updated = fields.Date(string="Status Updated Date")
	

The field value for date_status_last_updated must be updated by extending the update status() method. For that, define a method with the same name. This will help in extending an existing method. Then, all the operations specified in the parent class can be carried out using the super() method.
 Super is used to override a method that already exists in the same class.
In Odoo, supering create() or write() methods are common. It is important to remember that all arguments to the extending function must also be specified. You must specify any additional parameters from the parent function in the inherited class as well. The extended method is shown below, which will execute all of the parent method's steps first, followed by the additional steps.
def update_status(self):
  res = super(Student, self).update_status()
  self.write({
      'date_status_last_updated': fields.Date.today()
  })
  return res
	

We can add steps to an existing function without affecting its functionality by overriding the existing method.
Raw SQL Queries:
The search() method can typically be used for retrieving a record set based on conditions. The record is filtered based on condition using the domain. However, it is not always possible to use search() method to filter the required set of records. One reason is the difficulty in expressing the condition using the search domain.
This problem can be solved by using raw SQL queries.
Let's take a look at an example.
Consider a model student.student, which contains all of the student records.
from odoo import fields, models
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email")
  partner_id = fields.Many2one('res.partner', string="Partner", required=True)
  date = fields.Date(string="Date", default=fields.Date.today())
  total_grade = fields.Float(string="Total Grade")
	

Now, let's see if we can get the Name, Total Grade, and Email of all students, as well as the Partner name associated with the student whose Total Grade is greater than 50. Define a function get_top_score_students(self) and provide the raw SQL query that will select all required fields.


def get_top_score_students(self):
  sql_query = """ SELECT s.name, s.total_grade, s.email, p.name
                  FROM student_student AS s
                  JOIN
                      res_partner AS p ON p.id = s.partner_id
                  WHERE
                      s.total_grade > 50
  """
  self.env.cr.execute(sql_query)
  result = self.env.cr.fetchall()


	

Use self.env.cr.execute(sql_query) for executing the query.
To fetch the result, use self.env.cr.fetchall()
The result is printed here for easiness. Let's look at the output now. Create two simple student records to test the method.
 https://lh5.googleusercontent.com/kXdIwtEOvhEOOI2y5H_Kw8m06-BOkuB8zTnE3LWM6AWtHbrlkDqsicWmwk6hzZ2vvuJyOx2Lyk-iRqybX5wEiyJfepZUPJYKX4sVM85LUiL-2EyPfneJEv6tlR67Kzimh1zlRTctMUl63pZnbMJaQWU 

 https://lh4.googleusercontent.com/FETAG9njGZl1bOI00gcqafsb6WIqR5aRXydNz_DjhAsTKIwP9HRmUlNNVmX18WoIEwQT7avmHNBdlJhThPHhzY9mcTktspsc7oz7oXDaL8uwhuKY-AxayvQzfrDl-LQh4TlRUVycqwNoMuq8gtD2AHs 
Below is a printout of the results for these two records.


TOP SCORE: [(14, 60.0, 'azure@gmail.com', 'Azure Interior')]
	

AVERAGE SCORE: [(60, 30.0, 'waesyuilj@gmail.com', 'Brandon Freeman')]
	Onchange with Compute Method
Odoo's most commonly used techniques for achieving some kind of business logic is Onchange and compute logic. A field that uses values from other fields to calculate its value is known as a computed field. This method is used to compute the value of a computed field and is generally referred to as compute methods; onchange methods are methods triggered by a change in the field value.
Let's look at both scenarios using an example. Consider developing a business model for managing rental orders. Duration and price for the unit duration are used for calculating the amount for the total rent. For this purpose, let us define as in the following code a monetary field total_rent, which is a computed field, meaning that its value is determined by using the values of either one or more other fields.
from odoo import models, fields
    class VehicleRental(models.Model):
      _name = "vehicle.rental"
      _description = "Vehicle Rental"
      hour_rate = fields.Monetary(string="Hour Rate",)
      hours = fields.Integer(string="Hours")
      total_rent = fields.Monetary(string='Total Rent',
                                    compute='_compute_total_rent')
      def _compute_total_rent(self):
          for record in self:
              record.total_rent = record.hour_rate*record.hours
	The value of computed fields is usually dependent on other fields. Therefore, it is preferable to include the dependencies in the compute method. The ORM expects that the developer will declare these dependencies using the method's decorator depends(). When a change occurs in the dependent fields, ORM uses the provided dependencies to trigger the compute method.


from odoo import models, fields, api
    class VehicleRental(models.Model):
      _name = "vehicle.rental"
      _description = "Vehicle Rental"
      hour_rate = fields.Monetary(string="Hour Rate",)
      hours = fields.Integer(string="Hours")
      total_rent = fields.Monetary(string='Total Rent',
                                    compute='_compute_total_rent')
      @api.depends('hour_rate', 'hours')
      def _compute_total_rent(self):
          for record in self:
              record.total_rent = record.hour_rate*record.hours
	

With Odoo's Onchange mechanism, a field's value can be changed or updated if any updates are made to the values of the other fields. Additionally, the onchange is only activated in the form view and is triggered whenever one of the specified fields is modified in that view. In the given example, the Reference for the rental order is achieved from a method. The onchange() decorator allows the feature to call the onchange method whenever the value of the form's vehicle_id field changes.


from odoo import models, fields, api
    class VehicleRental(models.Model):
      _name = "vehicle.rental"
      _description = "Vehicle Rental"
      name = fields.Char(string="Ref.")
      vehicle_id = fields.Many2one('fleet.vehicle', string="Vehicle")
      @api.onchange('vehicle_id')
      def _onchange_vehicle(self):
          self.name = "Rental Order for %s" % self.vehicle_id.name
	

Model Based on SQL View
Most often, we create a model class with defined fields. Odoo will map this to a set of database tables. In some circumstances, we might need to combine the data from various models into a single table. This could be useful for creating dashboards or reports. This will be able to create a read-only model backend by using a postgresql view rather than a database table by utilizing the postgresql database engine in Odoo.
Let's talk about it using an example. Consider a model student.student, which stores all of an educational organization's student information.
1. Make a new model and set the _auto attribute to False.
class StudentLeaveStatistics(models.Model):
      _name = 'student.leave.statistics'
      _auto = False
	

2. Define model fields and set the read-only attribute to False so that the Views do not enable changes that you will be unable to save because PostgreSQL Views are read-only.
student_id = fields.Many2one('student.student', string="Student",
                                readonly=True)
leave_count = fields.Integer(string="Leave Count", readonly=True)
	

3. The next step is to define the init() method for creating the view. When the auto attribute is set to False, this method is responsible for creating the table. Otherwise, nothing will happen. The view creation query must generate a view with column names that correspond to the Model's field names.
def init(self):
      tools.drop_view_if_exists(self._cr, 'student_leave_statistics')
      self._cr.execute("""
          create or replace view student_leave_statistics as (
              select
                  min(sl.id) as id,
                  sl.student_id as student_id,
                  count(sl.id) as leave_count,
              from
                  student_leave as sl
              join
                  student_student as s ON s.id = sl.student_id
              where
                  sl.state = 'done'
          )""")

	4. For a new model, you can now define the Views. To explore the data, a pivot view is incredibly useful.
Onchange Methods
When the value of a field id is changed in the user interface, usually in a form view, a onchange method is invoked. Let us illustrate this with an example. Consider a model that stores all student records.
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  partner_id = fields.Many2one('res.partner', string="Partner")
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email", required=True)
	Now, for the field partner_id, let us define an onchange method that will update the email and phone field values. We can write the student's email and phone number based on the partner selected in the partner_id field.
@api.onchange('partner_id')
def _onchange_partner_id(self):
  self.write({
      'email': self.partner_id.email,
      'phone': self.partner_id.phone
  })
	The field passed as a parameter and the api decorator onchange() are used in an onchange method. As a result, the method specified will be used whenever the user interface changes the value of that field. For the onchange() decorator, more than one field may be supplied as an argument.


Init Hooks
The manifest file's init hook can be used to perform any operation you desire. This section demonstrates how to use the init hook to generate some records.Post_ init_hook is used for this.
We are generating records using the student.student model.
from odoo import fields, models
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email", required=True)
	By using the key register the hook in the __manifest__.py file, this is the first step. Post_init_hook. Odoo will look for the corresponding method in the init file and execute it after the module has been installed.


'post_init_hook': 'create_student',
	

In the init file, add the create_student() method. In this method, we use the create method to create a sample student record.
 In a real-time scenario, we can implement complex business logic here.
from odoo import api, SUPERUSER_ID
def create_student(cr, registry):
  env = api.Environment(cr, SUPERUSER_ID, {})
  env['student.student'].create({
      'name': 'Student 1',
      'phone': '+7865 6675 2341',
      'email': 'student1@student.com'
  })
	Additionally, Odoo supports two more hooks.
Those are pre_init_hook hook and uninstall_hook. The pre_init_hook will be called before the module installation. The uninstall_hook is called at the time of module installation.
Wizard
Odoo wizards are used to create interactive sections with users. Such interactive sections are extremely beneficial to any business flow. Transient and Abstract models are the most commonly used model classes in Odoo for wizard creation. However, the most common mode is the transient mode. This provides all of the characteristics of a model class except that the data in a Transient model is deleted on a regular basis, hence the name Transient. Wizards are commonly used to perform database persistent model operations.
Let's look at an example of a use case. Consider a model student.student for managing all of an educational organization's student records
from odoo import fields, models, api
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  partner_id = fields.Many2one('res.partner', string="Partner")
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email", required=True)
  status = fields.Char(string="Status")
  leave_ids = fields.One2many('student.leave', 'student_id', string="Leaves")
	For recording all of the student's leaves taken, there is an one2many type field. Let's make the model student.leave the required fields.
class StudentLeave(models.Model):
  _name = "student.leave"
  _description = "Student Leave"
  student_id = fields.Many2one('student.student', string="Student")
  date = fields.Date(string="Date")
  reason = fields.Char(string="Reason")
	The wizard model will then be developed, allowing the user to select a date and add a reason for leave. For this wizard model, we use the transient model class.
from odoo import api, fields, models
class StudentLeaveWizard(models.TransientModel):
  _name = 'student.leave.wizard'
  _description = 'Student Leave'
  student_id = fields.Many2one('student.student', string="Student",
                                readonly=True)
  date = fields.Date(string="Date")
  reason = fields.Char(string="Reason")
	Add a button for creating a leave record inside the student form view.
<header >
  <button name="create_leave" string="Leave" class="oe_highlight"
          type="object"/>
</header>
	In the student model, write a Python function for the button action. Let us return a widget where the user can enter the date and reason for leaving. Create a new leave record for the student using the widget values. Create a new record in the widget model with the student_id field set to the current student. Then, in the button click, return that object.
def create_leave(self):
  wizard = self.env['student.leave.wizard'].create({
      'student_id': self.id
  })
  return {
      'name': _('Student Leave'),
      'type': 'ir.actions.act_window',
      'res_model': 'student.leave.wizard',
      'view_mode': 'form',
      'res_id': wizard.id,
      'target': 'new'
  }
	The next step is to create a form view for the wizard that includes buttons for performing actions on the record. For the wizard view, two buttons named CREATE and CANCEL are added, each with the functionality indicated by the name.
<record model="ir.ui.view" id="leave_wizard_form_view">
      <field name="name">Leave</field>
      <field name="model">student.leave.wizard</field>
      <field name="arch" type="xml">
          <form string="Leave">
              <sheet>
                  <group>
                      <group>
                          <field name="student_id"/>
                      </group>
                      <group>
                          <field name="date" required="1"/>
                      </group>
                  </group>
                  <separator string="Reason"/>
              <field name="reason" required="1" nolabel="1" placeholder="Give leave reason"/>
              </sheet>
              <footer>
                  <button type="object" name="create_leave_from_wizard" class="btn btn-primary"
                          string="CREATE"/>
                  <button string="CANCEL" special="cancel"/>
              </footer>
          </form>
      </field>
</record>
	On button click, this will return the widget form.
 https://lh4.googleusercontent.com/nUTcVOSJquY0sneAQ0T2C_oW0QQtVz-05l24OwEC-JSNzYUbSIdkJqxqHcqVtIUNNUGW9hZN6irpOTkkggnaNIKVEFUVL1yQ3je9anYF1aypxVYNwV1tM5XfsO_cYM41iTACBIAYdjLX48hrOHgOTbY 



Now inside the create_leave_from_wizard method, it will perform the required action. Inside the wizard mode, this method has to be written. Create a new record in the model student.leave using the widget value on the button click.
def create_leave_from_wizard(self):
  self.env['student.leave'].create({
      'student_id': self.student_id.id,
      'date': self.date,
      'reason': self.reason
  })
	Upgrade the module after making all the necessary changes, then verify that the student's new leave record was successfully created.
This is how a wizard is made, which enhances the user experience in general.
Custom Settings
The option to configure certain settings may occasionally be needed by the user. In Odoo, there are currently more settings options available. In this section, let's discuss how to add a custom setting for our custom module.
Consider a model that maintains a complete student record database for that. Some organizations might demand that you email them when a student is created. However, not all of them might require the same thing. Let's design a setting that allows us to choose whether to enable or disable the feature. To do that, first make a model to store student records and a module called education_organisation.
from odoo import fields, models
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email", required=True)
	The student model only adds the most fundamental fields. Now, in order to add a custom settings option, we want to inherit the res.config.settings model.
class ResConfigSettings(models.TransientModel):
  _inherit = 'res.config.settings'
  # mail send configurator
  send_mail = fields.Boolean(string="Notify Student", default=True,
                              help="Check to Send a mail to Student on "
                                  "creating a Student")
	Under the Configuration menu, add a new menu called Settings and specify the action.
Action record
<record id="res_config_settings_menu_action" model="ir.actions.act_window">
  <field name="name">Settings</field>
  <field name="type">ir.actions.act_window</field>
  <field name="res_model">res.config.settings</field>
  <field name="view_id" ref="res_config_settings_view_form"/>
  <field name="view_mode">form</field>
  <field name="target">inline</field>
  <field name="context">{'module' : education_organisation}</field>
</record>
	One thing to remember when creating action record is the context. It is necessary to pass {'module' : education_organisation} in the context of action.
Now let's see how we can inherit the form view of res.config.settings to show the custom field.




<record id="res_config_settings_view_form" model="ir.ui.view">
  <field name="name">
      res.config.settings.view.form.inherit.organisation
  </field>
  <field name="model"> res.config.settings</field>
  <field name="priority" eval="10"/>
  <field name="inherit_id" ref="base.res_config_settings_view_form"/>
  <field name="arch" type="xml">
      <xpath expr="//div[hasclass('settings')]" position="inside">
          <div class="app_settings_block" data-string="Edu Organisation" data-key="education_organisation"
               string="Edu Organization">
              <h2 groups="website.group_multi_website">Notify Student</h2 >
              <div class="row mt16 o_settings_container" id="org_management" >
                  <div class="col-12 col-lg-6 o_setting_box" id="notify_student" >
                      <div class="o_setting_left_pane">
                          <field name="send_mail"/>
                      </div>
                      <div class="o_setting_right_pane" >
                          <label for="send_mail"/ >
                          <div class="text-muted" >
                              Check to Send a mail to Student on creating a Student
                         </div>
                     </div>
                 </div>
             </div>
         </div>
     </xpath>
 </field>
</record>
	

	

Adding the new boolean field to the form involves inheriting the current view. However, only our custom field will be visible under our menu when we access the view. You have to provide the model name to the data-key attribute in order to make this possible. If not, the same settings options that are displayed under the main settings option will be displayed.
 https://lh5.googleusercontent.com/2Y6989CPkh3BH2_KavhC6Hpu524l-NpViY_hkqhHuM3Z40Bfrl3n7_JZlodxvKYO5BEumkIU6_ryd4Vh8IEFT_Dx_-KiW54hFpr0NsXEQuTMz9Jmc3wSaBxzo5TDSc3ODpD6VN6B6GwC_RqPNWK_BaI 



The model res.config.settings is a transient model, so keep that in mind. That is, the data in the model are not database persistent. Therefore, we will need to create a few additional functions for storing and retrieving data for the view.
05. Data management
Data Loading


Odoo is mainly data-driven, and most operations greatly depend on data. In this section, we are going to discuss how to load data on module installation - the different ways and more operations related to Odoo data. There are two ways to load data in Odoo
* Using XML files
* Using CSV files 


Xml Files


Data records can be defined in Odoo using XML files. For that data XML files are to be placed. First, we have to create a directory inside the module called data. data.xml files are commonly created inside the directory data. Let’s discuss how to create partner data using XML files. For that, let us create a new module called custom_contacts, inside which creates a new directory called data. Inside the data directory, create an XML file named res_partner_data.xml.The record data can be loaded using an XML file by following the syntax below.


<record model="model_name" id="record_id">
            <field name="field_name">field_data</field>
</record>
	

For creating a record, it is necessary to give values for all required fields. We can create a partner record using the below XML code. The record is created using the record tag. Two attribute values can be set for the record tag: id and model. ‘Id’ is the unique identifier for this XML record. ‘Model’ specifies in which model the record is being created. In this example, we are creating a new record in the Contacts model; hence the model is given as res.partner. Inside the record, each field value is given using the field tag as given below. The Name specifies the technical name of the field, and after that, the field value is given.


<odoo>
  <data>
      <record id="partner_1" model="res.partner">
          <field name="name">Aby Wills</field>
          <field name="phone">9865432344</field>
          <field name="email">aby@example.com</field>
      </record>
  </data>
</odoo>
	

After creating this data.xml file add this inside __manifest__.py file as follows.


'data' : [
        'data/res_partner_data.xml'
]
	

After configuring this, install the module custom_contacts. A partner data with the specified values will be created in the database after installing the module.
CSV Files


CSV files are used in case of large data loading, as using XML files may not be suitable. In Odoo source modules itself, the usage of CSV files can be seen. Mainly they are used to define access rights. There are some important points to remember when using CSV files.
* This file's name should be model_name.csv."ir.model.access.csv," for instance.ir.model.access is the model name for the access permissions.CSV files are also added inside the manifest.
* The first row of the CSV file will have the fields that need to be written into, and we also have a field id for the external ID (used for creation or updation)
Let’s see this with the use of an example. For that, consider the account.tax.group.csv.


id,name,country_id/id
tax_group_0,TVA 0%,base.lu
tax_group_3,TVA 3%,base.lu
tax_group_6,TVA 6%,base.lu
tax_group_8,TVA 8%,base.lu
tax_group_10,TVA 10%,base.lu
tax_group_12,TVA 12%,base.lu
tax_group_14,TVA 14%,base.lu
tax_group_15,TVA 15%,base.lu
tax_group_17,TVA 17%,base.lu

	

The first row specifies the fields and is followed by values. Hence on installing the module consisting of this CSV file, the corresponding records inside the model account.tax.group will be created.
No Update


Odoo features a property named No Update for the <data> element. The values in the XML file will be produced again whenever a module is altered or upgraded according to this parameter value. In some cases, the data files' contents can not be changed. At that moment, the noupdate property value can be set to 1.


<odoo>
  <data noupdate="1">
      <record id="partner_1" model="res.partner">
          <field name="name">Aby Wills</field>
          <field name="phone">9865432344</field>
          <field name="email">aby@example.com</field>
      </record>
  </data>
</odoo>
	

Consider the above example. Since the noupdate attribute value is set to 1, any changes in this xml record will not be effected during the further upgrade process of the custom_contacts module. All the properties will be only effected at the time of the installation process. Hence using the noupdate attribute, we can make sure during the development process that the record created using the XML file is not updated frequently.
Force Create


Like noupdate, the forcecreate is also an attribute of the <record> tag. By using this attribute, we can make sure that the record is being created if it doesn’t exist. The forcecreate attribute is true by default. This also requires an external ID of the record. Consider the example given below.


<record forcecreate="True" id="decimal_payment" model="decimal.precision">
  <field name="name">Payment Terms</field>
  <field name="digits">6</field>
</record>
	

Here, if there is no record found in the model decimal.precision with external id decimal_payment, a new record will be created.
External IDs and Namespaces


An External ID can be simply defined as a unique identifier used to specify XML records defined. They are also called as XML IDs.These are records of the model ir.model.data which are imported in the case of importing data in Odoo.
When we are importing data using XML IDs, it initially checks for the existence of a record with the same identifier. If there is an existing record with the XML ID, then the UPDATE process will be worked. Otherwise, the CREATE operation will be processed. Usually, XML IDs will be the combination of the record ID and the module name.
E.g., sale.mail_act_sale_upsell
We can update any XML record if the external ID is known. Consider the below as an example.


<?xml version="1.0" encoding="utf-8"?>
<odoo>
  <data noupdate="1">
        <record id="base.main_company" model="res.company">
  <field name="name">My Company (San Francisco)</field>
</record>
</data>
</odoo>
	

Here ID of the record is given as XML ID of the main company.Since there is a record with this XML ID, update operation will be performed, resulting in the name changing of the main company.The name field value will be updated to “My Company (San Francisco). There is an option to get the External ID of any records from the User Interface. After enabling debug mode, developer tool menu will be shown. There is an option to see the metadata of the record from here. External ID is shown inside the metadata.
        Namespaced phrases are phrases that contain exactly one dot. When using the external ID for a record tag, Odoo first checks if it is namespaced. That is, if it contains exactly one dot. If it is not namespaced, then Odoo adds the module name as the namespace for the record.


Delete Data from XML


So far, we have discussed that we can create or update records using XML. There may be some cases where we need to delete existing records which are previously created at the time of any module installation. Delete tags (<delete>) are useful in such cases.


There are two methods to delete records from XML.
1. Using XML ID
2. Using Search Domain
Using XML ID


We are able to delete previously created records using the XML ID of it. For that, a delete tag is used. The syntax is given below.
<delete model="your model name" id="XML ID of the record"/>
	

 Here, attribute id stands for the external id of the record that needs to be deleted and attribute model is the model of that data. We can only delete records in this way for those records which are previously created using the XML or records which have external ids. Consider an XML record for creating a new Product Category.


<record id="demo_category_1" model="product.category">
    <field name="name">Category 1</field>
</record>
	

To delete this record, you have to follow the steps below.


<delete model = "product.category" id = "demo_category_1"/>
	

Odoo will search for a record inside the model product.category with the external id on running this code. If it is found, then the record will be deleted. If the record with this external id is not found, Odoo will raise an error.
Using Search Domain


This method helps in using a search domain for finding the record. We are able to pass a domain inside the search attribute of the delete tag. In this case, Odoo checks for matching records with the domain in the specified model while installing the module. The data will be deleted if records are found. In the first method using XML id, an error will be raised if no records are found. But here, no error will be raised if no matching records are found. The syntax is as follows
            <delete model = "model_name" search="domain"/>
	

let us discuss the syntax with an example.


<delete model = "sale.order" search [(partner_id.name,'=','Azure Interior')]/>
	

By running the above code, Odoo will delete all Sale Orders of the partner whose name is Azure Interior. Commonly delete is rarely used in Odoo

Function Call from XML


There may be some cases where you will need to perform some functions or methods once a module is installed. It is possible in Odoo to invoke a function from XML. The <function> tag is used to run python functions from XML. There are two ways to invoke a function from XML.
1. Invoking function without parameters
2. Invoking function with parameters
Invoking function without parameters


In this method, we can call a function defined inside any model without passing parameters. The syntax is given below.


<function id="function_id" model="model_name" name="method_name"/>
	The model of the method is specified in the attribute model of the function tag. The other attributes are id and name. Id specifies the unique identifier of the XML record, and the name corresponds to the method name.
Let us see an example of a function call without parameters.
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <function id="func_call_without_params" model="product.product"
              name="func_without_params"/>
    </data>
</odoo>
	

Here the model is product.product. So the system will invoke the method named func_call_without_params defined inside the model product.product. So the method 
definition will be as follows.
from odoo import api, fields, models

class product(models.Model):
  _inherit = "product.product"

   @api.model
  def func_without_params(self):
      self.create(dict(name='Test'))


	

After adding the XML data file inside the manifest, the method will be called on installing the module, and a new record will be created inside the model product.product.


Invoking function with parameters


The next method is Invoking function with parameters. In this method, we can call a function defined inside any model with passing parameters. The syntax is somewhat different from the previous one, and it is given below.


<function id="function_id"
         model="model_name"
         name="method_name">
   <value>param1</value>
   <value>param2</value>
   <!-- pass the parameters as per your need-->
</function>
	

Parameters for the method are passed inside value tag. It is possible to pass as many parameters as per your need. These parameters can be accessed from the method inside the model. An example is given below.


<odoo>
    <data noupdate="1">
              <function id="func_call_with_params"
              model="product.product"
              name="func_with_params">
            <value>Cybrosys Technologies</value>
        </function>
    </data>
</odoo>
	

Then the method definition need to be as follows.
from odoo import api, fields, models


class product(models.Model):
  _inherit = "product.product"

   @api.model
  def func_with_params(self, name):
      self.create(dict(name=name))


	

Then add the XML file inside the manifest. On installing the custom module, the python function will be invoked. The value of the parameter will be fetched, and this will be used to create the new product record.




















06. Views
Menu Action
There are two methods In Odoo for navigating to different pages. Both the user interface and the code can be used to generate menus. You add menus and associated actions using XML based upon the code. Therefore, inside the views folder, you should create a new XML file.
Menu:
The menu item tag can be used to create new menus. The attribute name specifies how the menu's name will be displayed. Additionally, you can provide the menu's sequence, which refers to the order in which you want the menu to appear. Only if the menu item or any of its submenus has an action will it appear on the screen.
For example:
<menuitem id="menu_root_hospital" name="Hospital Management"/>
	 https://lh6.googleusercontent.com/wfDxl7MPzgdpsrpJBgG8TJ_nnHjwBEmrLmv70Hzqmv1ZE3EO6jgm_Bkkm-v9H11RkTnL9ys5YPWpjeh7eo7_kr-TZgY88DjZ-VDasWJdvEhpPsHuE9kvK2Z_8NfN4JtlUKM3oKuM8dEeZyh5lhCGdXo 

Sub Menu
You can create a submenu for the main menu. For creating a submenu, a parent menu is required.
For example:
<menuitem id="menu_hospital_menu" name="Hospital" action="hospital_action" parent="menu_root_hospital"/>
<menuitem id="menu_patient_menu" name="Patient" action="patient_action"
       parent="menu_hospital_menu"/>
	

Two submenus are here. The main menu has a hospital submenu.
The Hospital menu includes Hospital Management and Patients.
Patient menus have actions, so when a menu item is clicked, the accompanying action is displayed. https://lh5.googleusercontent.com/piecUWCQGpTRB1DWxgia7-zKI_SVUeOz0lPGTht-SzNSuJpowbC64LTAAOi6-5gcX7rrvaPHTiy8DnG1iZJZoftk1iaEkc34-8QVQtA-mu5RUGQD0NjW9dwiPXROKjNLRWhi0-AdLPwjZBLa6WToBFY 
Next is to define the action. The menu or its submenu should have an action for viewing the menu.
For Example:
<record id="patient_action" model="ir.actions.act_window">
  <field name="name">Patient</field>
  <field name="res_model">patient.info</field>
  <field name="view_mode">tree,form</field>
  <field name="help" type="html">
  <p class="o_view_nocontent_smiling_face">No patients     found. Let's create one!</p>
<p>To get things done, use activities and status on    patients.</p>
</field>
</record>
	

From the action:
name: Name of the action
res_model: Name of the action
view_mode: The viewing mode, in this case, list and form and must desire to provide views that correspond to the view modes.
Help: If there is no data, a message inside the help will be displayed.
Menus from The UI:
Using the user interface, it is also able to construct and modify menus and submenus. For that, Go to > Settings > Technical > User Interface > Menu Items.
 https://lh6.googleusercontent.com/6ppWTawhHgEZim-r_rp-a-2CBSdWQdOoBVp0dJYB3AaZyY64bsMC_UJxRqdXnQ0z7IdtIjqnyUo76k3TyLMSxK8qrLFbk3lpJ9WE6DeHSi2V8We8EGOgUGsQ0kCgRXPWXupolEUaiYROjRAGwxv81e8 



To create a menu from the UI, Go to > Menu Items > Create
 https://lh6.googleusercontent.com/riWluDvmQX_db-K_GwVFEULttHsR99v1Koolaeo335FoNjihwFZUH6SeEqtl2gaPW2tDyEX0StOEAPZaQwwXkEWsIWPBGa4TveWglVhup-u13BhzRjbPko3yGLbjrjUaxsAmT26o3dKNR0q6U0kClR4 

Here to create a menu in the new module hospital_management,
Menu - Name of the menu
Parent Menu - The parent menu
Sequence - Sequence of the menu item.
Action - Specify the action.
Access Rights - - Giving access privileges allows you to restrict access to a certain user group
Submenus - - You can add a submenu here if you want to expand the menu. When you visit the corresponding module after saving the form, the menus are now visible.


 https://lh4.googleusercontent.com/qI7kU12UqTkSupYfUJ-JoezuAECz1gi3zW-Ck9PSVaZfoPCxOkXkyUmcSI-7S4zAYCgvxq4rzd4gk_nGGZoDLYIfpYbJ0u4wUB11rV7N18X0aGdYCrxRpoFhaS_Sb4u_xQo5sQBW20xZtlC8MIa3Xwc 

In this menu, Report is a recent addition.
In this manner, the UI can be used to construct new menus and submenus.
Widgets


There are two options for accessing different pages in Odoo. Both the user interface and the code can be used to generate menus. You add menus and associated actions using XML, according to the code. Therefore, inside the views folder, you should first create a new XML file.


widget="many2many_checkboxes"
	

 https://lh3.googleusercontent.com/Sp0K8y9jQLA8sTbXtSzlu88a1NF_50St8X3pqQ5mz4ePRZGRvnqqenDebNpjX_Txhp_XpG3Jn9XYRiMSYzBEJqLF38H8PZdV09Jp5-1lkKlplxbqmJA8T2c1urZviRo9I9TJcfwFWkIE-hdEviaI58s 



2. Status bar
Use this widget to display the status. Code is 


widget="statusbar"
	

 https://lh6.googleusercontent.com/DQo3z0R3kcU7u45MvEbJoVa43-6zCKq5MfHFvhgHW9b55XPpDAsa5lxOgSiEZab7WP5fqHBIFcVyuPuzVhPMOMJGmoiJdx4wpcK--zn5rnJ3m0Gb3D8Z6p7QwXbd9Y3zxPJQNmlgVcFp2vF3T-KI2-U 



3. Percentpie
This widget will display the progress chart. The code is
 https://lh3.googleusercontent.com/rzy1_wQS80qbMX2_ZJ8OIAzEQputZbEFeHCR9gRR77okol3ywvKkp2adRQFhITytejhpKXTaLf3_A9zfmtY1sdp-t_YfFytmDZnQTFRrpEemLr9dj2tX09KDu6sKVEHrJDvihI7-ibjTlOR54et4QQc 

4. Guage
Similar to the percentage widget, this one also allows you to enter a maximum value in the max field.
For example:
<field name="int_field" widget="gauge" options="{'max_field': 'another_int_field'}"/>
	5. Progressbar
By using this widget, you will get the progress. You can use the 
widget="progressbar" 


 https://lh3.googleusercontent.com/8Cc504dkey36EIYi8gsZKTHOQSc5n9UQynoZVtOTnl3J4_us8oW4jF743w5jnp8We2MCD48ay0AclCrDxoQl6Q6YOQARClBnnP6mkY2SqzOEHrC_73HbXnL3MUxbU9nunwIGL04PZ164Xrx3W_cOyak 



6. Many2many Tags
It will display multiple items as tags. Code is 
widget="many2many_tags"
	

 https://lh5.googleusercontent.com/kapXg6lYq6XjqlQn81dQ9gvVWM6TAlPIb0CQ3fk5Sci1PwwJryqMN64qXdK70WdAEWjZ4yTwVebAOhp8NVK80KnE3wXvonR35mF7Hkdv5CsUVXnQdHgquFTzfqsApVg2vjdFRHLNc9aISfcAkeN1W-o 

7. Handle
By using this widget, you can drag the lineup and down. You can use the code 
widget="handle"
	

 https://lh4.googleusercontent.com/qTBsMD5JOmDCiySQpVLEsfccXC8tEqXJGU4aOMiaBEHx43lM3yhL5hch9QMLUw7CB8B7v81sgjJzfQOAQYfGbmxxpVDILAwmOPUuVwPGVmgDUSiKRr7W31OYIo2iIPsVyKkoCZsm6LRrYYK0vPEd5HA 

8. Many2many Binary
You can attach files by using this widget. Code is
 widget="many2many_binary" 
	9. Selection
It displays a list of items by using the code 
widget="selection" 
	10. Radio
This widget is used to get the radio button effect. Code is          
widget="radio" 
	

 https://lh6.googleusercontent.com/EDDVy8FCwJ6Qoh2Rx-h_BpCnnClBFwwLkD-nAhSd8uyXAZe9GhsvwycRxa0gTliJWkuypYLio_pankQUX9G1IDEOfloSmiRntpA_9NYX5B85Ng_ijubg4WwvOmwgCqYCHdFR_by2UHFIxFcRgk3e_c0 

Buttons
In Odoo, there are various kinds of buttons. On the form view, form buttons are produced. The form button invokes an item or action when it is clicked. Another kind of button is a smart button. Use smart buttons if you wish to include relevant records from another model into your own.
1. Form Buttons:
For creating a form button, first define the view. Inside the view, you can create the buttons by using the tag <button>
For example:
<record id="patient_view" model="ir.ui.view">
  <field name="name">patient.info.form</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <form string="menu">
           <header>
               <button name="button_done" string="Done" class="oe_highlight" type="object"/></header>
          <sheet>
              <group>
                  <field name="name"/>

                  <field name="age"/>
                  <field name="gender"/>
              </group>
              <group>
                  <field name="phone"/>
                  <field name="partner_email"/>
                  <field name="doctor_id"/>
              </group>
          </sheet>
      </form>
  </field>
</record>
	

Here, first defined a form view. A button object type was established inside the form view. The button, in this case is called button done.
The function for the related model can be defined in the python file under the name ‘button done’. You would get an error if a function was not defined.


 https://lh3.googleusercontent.com/YeYcPULr5XNDcQPjapT9XsO2Qji3JJlMwLDs7KeydVFxlKMS-0FcaVwOE7HIeJ1TCjyNDA-GVjzvu_PH3hsizbblSvb9LqGD5j9h79MbVeydKnj2K998S53w-QsjvOWVYNKogvtdcmsqTPnFJyCBMu0 



Action In Odoo, action-type buttons is also available.
The action button signifies that when the button is clicked, an action will be initiated. Use the action button to have a wizard launch when a button is clicked.


For example:
<record id="patient_view" model="ir.ui.view">
  <field name="name">patient.info.form</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <form string="menu">
           <header>
               <button name="button_done" string="Done" class="oe_highlight" type="object"/></header>
                      <button name="%(patient_info_action)d" string="Book Appointment" type="action" class="oe_highlight" />
          <sheet>
              <group>
                  <field name="name"/>

                  <field name="age"/>
                  <field name="gender"/>
              </group>
              <group>
                  <field name="phone"/>
                  <field name="partner_email"/>
                  <field name="doctor_id"/>
              </group>
          </sheet>
      </form>
  </field>
</record>
	

 https://lh6.googleusercontent.com/rxafAjgcGoKXiO3tphHjzVYe3v_X1c1B2eSyNFAr8qtQYvSxFVy4gL6sYceXsTl6-ehXy4_ox8O3hSWG6N_3YuOdSj4N9oJ_N0BZR4Jo-oM3mM8UA4omx1rZVdcrqoCiqU6BfQDSv7NZwh8JdTTqLj4 

When clicking the button, it performs an action. So here, you can see a new form is open when clicking this button.
 https://lh3.googleusercontent.com/XdZs6wxYJA0XKQfPxdGxV4Gv9-DxEMOpe5fvXK-L_8JaWAxmCFkf8QfC7Ntguax6OXDTBI1IkGVqeqNb4yx-rqms7kfUSRroiZ5G9EWSza-vuLNB66hf-0GKveq9DYXlfMoLJZFQT02htraJ3chgGxo 

2. Smart Button
The form views define smart buttons. And they have permission to access all the records connected to this form view.For example
 <div class="oe_button_box" name="button_box">
  <button class="oe_stat_button" type="object" string="Appointments" name="show_appointments"
      icon="fa-pencil-square-o">
  </button>
</div>


	

Inside the form view, a new smart button was added here.
You must want to define a function with its name because the button is an object type. Icon is the term for the smart button's icon.
 https://lh6.googleusercontent.com/zTRADX0W0_qxzZMFroO_XODbnRESLpp3LZ8oNAkkcb_xFrb7XRxcSbw1XDb3cnW-Ihj6ASGdpnWWZqAJpXzwLk4P4mJQ8WTOhxDiA_TAIeR1t7l14AymjTjTk2qdyuN5vy0Yyaz7tOn5Z-jreYqMz_0 



Context & Domain
Using XML or Python, you can pass any information in context. Additionally, the domain is any requirement that aids in data filtering during searches. Therefore, when coding, context and domain will be more helpful. A context is a python dictionary that assists in passing necessary info to an Odoo function. You can see that practically every method in Odoo had a context argument to transmit data. Examples of many ways to use context are given below.


1. To pass default values for fields:
<field name="work_location_id" context="{'default_address_id': address_id}" />
	This way, you can set the default value for a field.
2. Setting default filters and groups by records
<group expand="0" string="Group By">
  <filter string="Department" name="department" domain="[]" context="{'group_by': 'department_id'}"/>
  <filter string="Company" name="company" domain="[]" context="{'group_by': 'company_id'}" groups="base.group_multi_company"/>
  <filter string="Employment Type" name="employment_type" domain="[]" context="{'group_by': 'contract_type_id'}"/>
</group>
	

Inside the context you can add the group_by field.
3. In Window actions
<record id="crm_lead_action_my_activities" model="ir.actions.act_window">
  <field name="name">My Activities</field>
  <field name="res_model">crm.lead</field>
  <field name="view_mode">tree,kanban,graph,pivot,calendar,form,activity</field>
  <field name="view_id" ref="crm_lead_view_list_activities"/>
  <field name="domain">[('activity_ids','!=',False)]</field>
  <field name="search_view_id" ref="crm.view_crm_case_my_activities_filter"/>
  <field name="context">{'default_type': 'opportunity',
          'search_default_assigned_to_me': 1}
  </field>
  <field name="help" type="html">
      <p class="o_view_nocontent_smiling_face">
          Looks like nothing is planned.
      </p><p>
          Schedule activities to keep track of everything you have to do.
      </p>
  </field>
</record>
	

For defining default values for new records, use context in window actions. The default type in this instance is set to opportunity.
4. Python has a function
Context is also usable inside of Python functions. You can access any value from XML passed to your Python function as self.partner id is the value that is passed from the XML in this statement: env.context.get('partner id').


5. In search view and filters
<group expand="0" string="Group By">
   <filter string="User" name="user" domain="[]" context="{'group_by':'user_id'}"/>
   <filter string="Type" name="type" domain="[]" context="{'group_by':'resource_type'}"/>
   <filter string="Company" name="company" domain="[]" context="{'group_by':'company_id'}" groups="base.group_multi_company"/>
   <filter string="Working Time" name="working_period" domain="[]" context="{'group_by':'calendar_id'}"/>
</group>
	Here added two filters inside the group tag, and passed the group_by using context.
Domain:
Domains can be used to search for or filter data or records depending on particular criteria. A field, operator, and value are all parts of a domain. You can filter the data using a variety of operators.
The syntax for the domain is: domain="[(field_name, 'operator', ‘value’)]"
The name of the field in the associated model to which the domain should be assigned is the field name. There are several distinct kinds of operators in Odoo.
-> comparison operators : < ,>, =, !=, <=,>=
-> [('name', '=like', ‘Mitchel’)] - This returns ‘Mitchel’
-> [('name', '=like', 'odoo')] - This returns ‘%odoo%’
-> [('name', '=like', 'odoo')] - This returns ‘%Odoo%’, ‘%odoo’
-> In’ and ‘not in’ : These are used to check if the value is present or not in the value list
-> child_of’ operator: It is used to find the child values in relation.
You can use domains in different situations
1. In a search view filter
<search string="Search for mrp workcenter">
  <field name="name" string="Work Center" filter_domain="['|', ('name', 'ilike', self), ('code', 'ilike', self)]"/>
  <filter name="archived" string="Archived" domain="[('active', '=', False)]"/>
  <group expand="0" string="Group By...">
      <filter string="Company" name="company" domain="[]" context="{'group_by': 'company_id'}" groups="base.group_multi_company"/>
  </group>
</search>
	

2. In record rule


<record model="ir.rule" id="res_users_log_rule">
  <field name="name">res.users.log per user</field>
  <field name="model_id" ref="model_res_users_log"/>
  <field name="domain_force">[('create_uid','=', user.id)]</field>
  <field name="perm_read" eval="False"/>
</record>
	

3. fields_view_get() method
Use the domain in the fields view get method to specify dynamic values for domain filters ().


4. To filter relational object fields records
partner_id = fields.Many2one('res.partner', 'Account Holder', ondelete='cascade', index=True, domain=['|', ('is_company', '=', True), ('parent_id', '=', False)], required=True)
	5. To display specific records
<record id="action_bank_statement_tree" model="ir.actions.act_window">
  <field name="name">Bank Statements</field>
  <field name="res_model">account.bank.statement</field>
  <field name="view_mode">tree,pivot,graph</field>
  <field name="domain">['|', ('journal_id', '=', False), ('journal_id.type', '=', 'bank')]</field>
  <field name="context">{'journal_type':'bank'}</field>
  <field name="search_view_id" ref="view_bank_statement_search"/>
  <field name="help" type="html">
    <p class="o_view_nocontent_smiling_face">
      Register a bank statement
    </p><p>
      A bank statement is a summary of all financial transactions
      occurring over a given period of time on a bank account. You
      should receive this periodically from your bank.
    </p><p>
      Odoo allows you to reconcile a statement line directly with
      the related sale or purchase invoices.
    </p>
  </field>
</record>
	

List Views
In Odoo, views are mainly for visualization, and it is more user-friendly. You can describe a view's appearance while defining it. In Odoo, there are various views that offer various visualizations. A form of view called a list view resembles a tree or list structure.
Furthermore, you can view numerous records on a single screen.
For creating a list view, first, you want to define a model and its fields. I.e.,
class PatientInfo(models.Model):
  _name = 'patient.info'
  _description = 'Patient Information'
  name = fields.Char(string="Name")
  age = fields.Char(string="Age")
  gender = fields.Char(string='Gender')
  phone = fields.Integer(string="Phone")
  partner_email = fields.Char(string="Email")
  doctor_id = fields.Many2one('res.partner')
	

Here defined a new model hospital. Patient and also created new fields for the model. Then the next step is to define a view from XML.




i.e.
First define the action window for the views.
<record id="patient_action" model="ir.actions.act_window">
  <field name="name">Patient</field>
  <field name="res_model">patient.info</field>
   <field name="help" type="html">
<p class="o_view_nocontent_smiling_face">
 No patients found. Let's create one!
</p>
<p>To get things done, use activities and status on patients.
</p></field>
  <field name="view_mode">tree,form</field>
</record>
	List view:
<record id="patient_info_tree" model="ir.ui.view">
  <field name="name">patient.info.form</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
          <tree string="cases">
               <field name="name"/>

                  <field name="age"/>
                  <field name="gender"/>
              <field name="phone"/>
                  <field name="partner_email"/>
                  <field name="doctor_id"/>

          </tree>
  </field>
</record>
	

Here, the tree element serves as the list view's root element, and you can specify the fields you wish to see on the tree view or list view inside the tree tag. Use the editable attribute to make the tree view editable if you wish to. For this characteristic, top and bottom values are possible. To prevent the deletion of the record, use delete=False.To prevent the creation of the record, use create=0.edit=0 stops the record from being edited. For example, if we set limit=50, then only 50 records will be shown in the tree view. You can set a limit for the tree view.
Search View
In Odoo, there are various view kinds. The search view is unique compared to other views because just a portion of the items will be seen in the search view. Since form views only contain one record, it is used to filter the contents of other views rather than those of the form view.
For example:
<record id="hospital_patient_search" model="ir.ui.view">
  <field name="name">patient.info.search</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <search>
          <field name="name"/>
          <field name="partner_email"/>
          <field name="age"/>
          <field name="gender"/>
      </search>
  </field>
</record>
	

 https://lh4.googleusercontent.com/mjIWBWu3lH9240aH5nOsNXx5h-sC40rpqmsjnsTasfKwq5aTPq0AKcNixxtutUG03qvwnXR7TREc9D53TJz4ZYBGsnFH-ag1gV0yxKpxU2-GGcdALD4LNXQf2AjnZZdjyoTW-S_DOtW3fWcjkPP2MLU 

When clicking the archived filter, you will get all the archived records. Different filtering conditions can be specified in the domain attribute.
If you choose to group by, you can include filters both inside the group tag and the search tag.
Filters and Group By:
There are filters and groups by in the search view. Records are filtered based on conditions using the filter command, and groups are grouped based on a field using the group by command. There is a simple way to add these by default, so you don't have to constantly select "Add Custom Filter" or "Add Custom Group."The search tag's filter tag is used to add a filter.
For eg:
<filter string="Gender" name="gender"
      context="{'group_by': 'gender'}"/>
	 https://lh4.googleusercontent.com/d68KyZQiC5ihm5hxKENjvd7_bi0XXN2M24Bp8zPmq0CZRnmV5DjfOVm8Q8Dj7sRGlJ-6SkGpyLjM_W_yyc8gFRq837KoIQGuu6ghfPJ6Z05zKLRSiGg14evYoyHgpw6DbgmKK7BC7vcPvfKm0MCewDw 

You will see all the archived records when you select the archived filter. Different filtering conditions can be specified in the domain attribute. If you choose to group by, you can include filters both inside the group tag and the search tag.
i.e.,
<group expand="0" string="Group By">
<filter string="Gender" name="gender" context="{'group_by': 'gender'}"/>
</group>
	 https://lh4.googleusercontent.com/tJb_vNqSbzbYe5hjZIXLTDoxkDijyTbaqcQUCuKhLiy4-9bFtZb-V_kvxM5U7p_36P8e1Xg9RM_wlELSWNdKbPmq1SaJeD5wbymtj6GzBTXlo5EPkiLPe8o9X0boxxz8G2yGluf1BvONjZ2-re2VQWc 

Applying a gender grouping here.The data will be sorted according to the gender field. Context is used to pass data for grouping.
While other fields can also be used for the group by filters, the attribute name is necessary.


View Inheritance
There are numerous view types in Odoo. In Odoo, you must first inherit the pertinent view before making any alterations to an existing view. It is possible to inherit any view, including form, tree, kanban, search, etc. To inherit a view, you must make an XML file for the inheritance in the views folder. Include this file path inside the data manifests as well. The inherited records can be added to the XML file.




i.e.,
<record id="view_crm_meeting_search" model="ir.ui.view">
  <field name="name">calendar.event.form.inherit</field>
  <field name="model">calendar.event</field>
  <field name="inherit_id" ref="calendar.view_calendar_event_search"/>
  <field name="arch" type="xml">
      <xpath expr="//field[@name='description']" position="after">
          <field name="opportunity_id"/>
      </xpath>
  </field>
</record>
	

Here, the form view calendar event search, which is inside the module calendar, is inherited. The parent view id that you want to inherit is specified using the inherit id function. For the inheritance, you can add module name.parent view id. After that, you can make adjustments using the XPath tag. Additionally, you can specify several XPath values.
Expressions can be added in a variety of ways:
Some examples are
expr="//field[@name='user_id']"
expr="//sheet/div[last()]"
expr="/kanban"
expr="."
expr="//filter[@name='activities_overdue']
expr="//header"
expr="//button[@name='action_open_product_lot']"
	

Also you can give different positions to the xpath. i.e.,
position=”after” : Display the field after the parent view mentioned in “expr”
position=”before” : Display the field before the parent view mentioned in “expr”
position=”inside” : Display the field inside the parent view mentioned in “expr”
position=”attributes” : Change the field attributes
position=”replace” : Replace the parent view field with newly created field
Form Style
If you want to provide customers with a consistent experience, you can style the document form in Odoo. You have a number of options for styling a form.
1. Header Element
Use the header element for adding buttons or status bars at the starting of a form.
For example
<header>
<button name="action_quotation_send" string="Send by Email" type="object" states="draft" class="btn-primary" data-hotkey="g"/>
<button name="action_cancel" type="object" string="Cancel" attrs="{'invisible': ['|', ('state', 'not in', ['draft', 'sent','sale']), ('id', '=', False)]}" data-hotkey="z"/>
<button name="action_draft" states="cancel" type="object" string="Set to Quotation" data-hotkey="w"/>
<field name="state" widget="statusbar" statusbar_visible="draft,sent,sale"/>
</header>
	

2. Sheet Element
Next, you can add a <sheet> element. Inside this element, you can add all other fields.
3. Smart buttons
Smart buttons can be used to retrieve more records associated with this object. The top of the sheet will then get smart buttons added.


<div class="oe_button_box" name="button_box">
  <button type="object" name="action_reconcile_stat"
    class="oe_stat_button" icon="fa-book">
      <field name="number_entries" string="Journal Entries" widget="statinfo"/>
  </button>
</div>
	

4. Prominent fields
If there are any prominent fields, then put them first.
<div class="oe_title">
  <h1><field name="name" class="oe_inline"/></h1>
</div>
	

Then you can add all other fields.
5. Notebook
If there are a lot of fields on the form, then we can arrange them as notebook pages.
<notebook>
  <page string="Internal Notes" name="internal_notes">
      <field name="description" placeholder="Add a description..." options="{'collaborative': true}" />
  </page>
</notebook>
	You can add more pages to a notebook.
6. Chatter widget
If you want to add a chatter on your form, you can add it after closing the sheet element.


<div class="oe_chatter">
  <field name="message_follower_ids"/>
  <field name="activity_ids"/>
  <field name="message_ids" options="{'post_refresh': 'recipients'}"/>
</div>
	

Kanban view
In Odoo we can create several views. such as tree view, form view, list view, kanban view, pivot view, calendar view, etc. The kanban view is a kanban board visualization. It displays records like block”, and we can add images in the kanban. Here we can’t edit the records from the kanban view.
Let's check how to create a new kanban view:Create a model example.odoo.
class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	    
After the model is created, we can add the menu and the corresponding menu action for this model
<record id="action_Example" model="ir.actions.act_window">
        <field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">kanban,tree,form,graph,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	

Now set the kanban view for the model with the corresponding design. Don’t forget to add the required fields. 
<record id="example_kanban_view" model="ir.ui.view">
            <field name="name">example</field>
            <field name="model">example.odoo</field>
            <field name="arch" type="xml">
                <kanban class="o_kanban_mobile" sample="1">
                    <field name="example_field"/>
                    <field name="example_field1"/>
                    <field name="id"/>
                    <templates>
                        <t t-name="kanban-box">
                            <div t-attf-class="oe_kanban_global_click">
                                <div class="o_kanban_image">
                            <img t-att-src="kanban_image('example.odoo', 'example_field', record.id.value)" class="o_image_64_max" height="52"/>
                      </div>
                      <div class="oe_kanban_details">
                          <strong class="o_kanban_record_title">
                          field: <field name="example_field"/>
                          </strong>
                      <div t-if="record.example_field1.value">
                            field1: <t t-esc="record.example_field1.value"/>
                      </div>
                      </div>
                            </div>
                        </t>
                    </templates>
                </kanban>
            </field>
        </record>
	

The output of the above model is
 https://lh3.googleusercontent.com/Q--QS0e-9RIdOwUxeUXdhOJ9j2U0PwEf5Oo8rh3pimVoNijZY9xgNP1HQpSORYJEAz3RnhdwPR6KJKEqDCy5qWuKw2qmb3adbVqTEG1XRvcEdssJgjSlS26tH7V91fCxSWF6A8VaN0zd5nDfX6jPI5s 



Graph view
One of the views that Odoo provided to us is the graph view. It is a graphical view of the data, and it can be represented like a Bar chart, Pie chart, and Line chart. So that users get an easy understanding of the records.
Now let’s create a graph view:
Created a model example.
from odoo import models, fields


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	 
And then add the action for the menu,
<record id="action_Example" model="ir.actions.act_window">
<field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">kanban,tree,form,graph,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	

After creating the model, menu and the action we can set the graph view for the model.
<record model="ir.ui.view" id="example_graph_view">
          <field name="name">example.graph</field>
          <field name="model">example.odoo</field>
          <field name="type">graph</field>
          <field name="arch" type="xml">
                      <graph string="Example" type="bar">
                          <field name="example_field" group="True"/>
                          <field name="example_field" operator="*"/>
                      </graph>
          </field>
</record>
	

The output of graph view model is,
 https://lh4.googleusercontent.com/S-LwAvBsMipp6XoGnEW3O82-2hIWKQTql4uSlwU04bAHxS9hXiom6vC1Hnn50WRn9pVROn0VE0bovSEYWpiplRxeRoRTGsUO192kj8VHExv1tus_KgK1qiOZlVzlD1fPjeP2QOyV0h2TdG2NFmkEJLI 

Pivot view


A Pivot table view is the best tool to calculate and also analyze data. In Odoo, we can create pivot tables for our model so that users get a table structure of all the records.
Let us see how to set the pivot table.
First, we have to create a  model, menu, and menu action.
from odoo import models, fields


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	

<record id="action_Example" model="ir.actions.act_window">
        <field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">form,tree,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	Then create the pivot view like this.
<record id="example_pivot_view" model="ir.ui.view">
    <field name="name">example.pivot</field>
    <field name="model">example.odoo</field>
    <field name="arch" type="xml">
        <pivot string="Project Tasks">
            <field name="example_field" type="row"/>
            <field name="example_field1" type="col"/>
        </pivot>
    </field>
</record>
	The output will be
 https://lh3.googleusercontent.com/Dsoy0DH21xEpy2XfOhrvDjbaNYKyxP-0wF34wia0WY3Au2rUeUmBqrFRqgAe89G8vK1JHF3V9GYLfwHedajDBrykZg-iekTeKAV9xSgqX-GFfsQrcAqve5V3Sjkkp8LUG2chF_fSMp9ZhyDhfJQj0NM 

Cohort view
One of the views that support Odoo is the cohort view, which gives information for the next 15 days, weeks, months, and years. So that we can get a good analysis of data in a specific time frame, let us look at an example.


from odoo import models, fields


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	

from odoo import models, fields


class ModelExample(models.Model):

    _name = 'model.example'
    patient_id = fields.Many2one('hospital.patient', string="C")
    name = fields.Char(string='Name')
    date = fields.Date(string="Date")
    attachment = fields.Binary(string="Attachment")


class HospitalPatients(models.Model):

    _name = 'hospital.patient'
    name = fields.Char(string='name')
    dob = fields.Date(string='date')


	



After adding models, we can set the action and menu for these models.


<record id="action_Example1" model="ir.actions.act_window">
        <field name="name">Example1</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">model.example</field>
        <field name="view_mode">tree,form,cohort</field>
    </record>

    <menuitem id="model_example_menu"
              name="Model Example"
              parent="example_menu"
              action="action_Example1"/>
	Now we can set the cohort view for the model.
<record id="model_example_cohort" model="ir.ui.view">
  <field name="name">model.example</field>
  <field name="model">model.example</field>
  <field name="arch" type="xml">
      <cohort string="model" date_start="date" date_stop="date" interval="day" sample="1"/>
  </field>
</record>
	Don't forget to add the ‘web_cohort’ in the depends otherwise it will encounter an error
There are two types of mode in cohort view which are retention and churn.
Churn starts from zero and ends at zero. Retention will start from 100 % and decrease to zero


The output of the above code will be
 https://lh3.googleusercontent.com/0Z5M7Ups3-Bxp5jOSWa0qN80ORFwYDOnb9-iX3h2c27JPvdt9bp0ozhy2dVlxHV_YD6nVgl6H6KJq-gdtzHrkLeL_NOnsBVHAvJjm5flCJDSH9oWk0sXiWCpvQ8p_SzXHdVJh0JME-ut9TZRzqPvguY 



Dashboard view
Dashboard view is used to get a good understanding of the various business KPIs. It will provide us a good overview of the records we can only get through this facility in the Odoo enterprise version. If we want to set up a dashboard view in your module, don’t forget to add the ‘web dashboard’ in the dependency in the manifest file. Let us take an example,


<record id="view_helpdesk_dashboard" model="ir.ui.view">
    <field name="name">Hepldesk dashbaord</field>
    <field name="model">helpdesk.ticket</field>
    <field name="arch" type="xml">
        <dashboard>
            <view ref="helpdesk.helpdesk_ticket_view_graph_analysis"
                    type="graph"/>
            <group>
              <aggregate name="all_ticket"
                  string="Total Ticket"
                  group_operator="count"
                  field="id" measure="__count__"/>
                  <aggregate name="progress_tikets"
                              string="In Progress Ticket" domain="[('stage_id.name', 'ilike',
                              'In Progress')]"
                              group_operator="count"
                              field="id" measure="__count__"/>
                  <aggregate name="done_ticket"
                              string="Done Ticket"
                              domain="[('stage_id.name', 'ilike',
                              'Done')]"
                              group_operator="count" field="id"
                              measure="__count__"/>
                  <formula name="average"
                            string="Overall Progress"
                            value="record.done_ticket / record.all_ticket"
                            widget="percentage"/>
            </group>
            <view ref="helpdesk.helpdesk_ticket_view_pivot_analysis"
                    type="pivot"/>
        </dashboard>
    </field>
</record>
	Now we can add the menu and action for this view.
<record id="act_window_dashboard" model="ir.actions.act_window">
    <field name="name">Dashboard of tickets</field>
    <field name="type">ir.actions.act_window</field>
    <field name="res_model">helpdesk.ticket</field>
    <field name="view_mode">dashboard</field>
</record>
<menuitem id="dashoard_ticket_menu"
    name="Dashboard"
    parent="helpdesk.helpdesk_ticket_report_menu_main"
    action="act_window_dashboard"
    sequence="28"/>
	

Here we can see that the dashboard view can include different types of graphical representation. 
To specify these views, we will give these views XML reference in the <view> tag’s ref attribute.
Gantt view
In Odoo, we can create several views such as tree view, form view, list view, kanban view, pivot view, calendar view, etc. The Gantt view is a Gantt visualization.
It is one of the advanced types of view in Odoo. We can access this feature only in the enterprise version. If you want to use the Gantt view in your custom module, you should have to install the “web_gantt” and also mention the module ‘web_gantt” in the manifest.
Let’s take an example.


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	    
After the model is created, we can add the menu and the corresponding menu and action for this model.
 
<record id="action_Example" model="ir.actions.act_window">
        <field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">kanban,tree,form,graph,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	

Now we can define the ‘Gantt’ view for this model.


<record id="student_assignment_gantt" model="ir.ui.view">
        <field name="name">model.example.view.gantt</field>
        <field name="model">model.example</field>
        <field name="arch" type="xml">
            <gantt
                    date_start="create_date"
                    date_stop="date"
                    default_group_by="name"
                    default_scale="week"
                    color="student_id"
                    scales="day,week,month,year"
                    precision="{'day': 'hour:full', 'week': 'day:full', 'month': 'day:full', 'year': 'day:full'}"
                    thumbnails="{'employee_id': 'image_128'}">
                <field name="student_id"/>
                <templates>
                    <div t-name="gantt-popover" class="container-fluid">
                        <div class="row no-gutters">
                            <div class="col">
                                <ul class="pl-1 mb-0">
                                    <li>
                                        <strong>Start Date:</strong>
                                        <t t-esc="userTimezoneStartDate.format('YYYY-MM-DD hh:mm:ss A')"/>
                                    </li>
                                    <li>
                                        <strong>Stop Date:</strong>
                                        <t t-esc="date.format('YYYY-MM-DD hh:mm:ss A')"/>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </templates>
            </gantt>
        </field>
    </record>
	

Activity view
One of the useful views that support Odoo is the activity view which helps the user to manage every business operation. In this view, we get information about the activities that are related to our records so that users can easily identify the scheduled activities.
First, we need to add “mail” to the depends
Like, 'depends': ['mail'],
After adding the depends in the manifest, we need to inherit mail.thread and mail.activity.mixin models.
Model for an example,
class Activity(models.Model):
    _name = 'activity.demo'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    name = fields.Char(string='Name', required=True)
    demo_field1 = fields.Many2one('res.users', 'Author', required=True)
    no = fields.Char('Sl No', required=True)
	

 Action definition
<record id="demo_action" model="ir.actions.act_window">
    <field name="name">demo</field>
    <field name="type">ir.actions.act_window</field>
    <field name="res_model">activity.demo</field>
    <field name="view_mode">tree,form,activity</field>
    </record>
	Also the  activity view define 
<record id="demo_view_activity" model="ir.ui.view">
  <field name="name">Book</field>
  <field name="model">activity.demo</field>
  <field name="arch" type="xml">
        <activity string="Applicants">
            <templates>
                  <div t-name="activity-box">
                        <div>
                            <field name="name"/>
                        </div>
                  </div>
            </templates>
        </activity>
</field>
</record>
	

Map View
One of the views that Odoo support is map view it displays the record on the map. Its root element is <map>. Here is an example.
Don't forget to add 'depends': [web_map], in manifest
To do this, first we have to create a model.


from odoo import models , fields


class Book(models.Model):

    _name = 'odoo.book'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    display_name = fields.Char(string='Name', required=True)
    author = fields.Many2one('res.partner', 'Author', required=True)
    sl_no = fields.Char('Sl No', required=True)
	Now we can arrange the corresponding model's view and map view.
So first we can create an action for the model.
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="odoo_book_action" model="ir.actions.act_window">
        <field name="name">Book</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">odoo.book</field>
        <field name="view_mode">tree,form</field>
    </record>
	 Now we can set the map view.
<record id="odoo_book_map" model="ir.ui.view">
        <field name="name">odoo.book</field>
        <field name="model">odoo.book</field>
        <field name="arch" type="xml">
            <map res_partner="author">
            </map>
        </field>
    </record>
	

<record id="odoo_book_action_map" model="ir.actions.act_window.view">
        <field name="sequence" eval="3"/>
        <field name="view_mode">map</field>
        <field name="view_id" ref="odoo_book_map"/>
        <field name="act_window_id" ref="odoo_book_action"/>
    </record>
	



After creating a record in this model, we can see the map view.
 https://lh3.googleusercontent.com/iuI63mUsw5TU9wDZFC8cC5OV9BVquQ5c8Ck4MlBKaGwCq49bhhCMetFKbg7ndT5b7_QTZD0Z6zcMjMH5J40vhSXAUBPZipBD7719PbcAVnnYOFBHJRudVOdKcn9g3GavB30sF1mZRY9KX04b9JBL4zI 

Menu Action
There are two methods In Odoo for navigating to different pages. Both the user interface and the code can be used to generate menus. You add menus and associated actions using XML based upon the code. Therefore, inside the views folder, you should create a new XML file.
Menu:
The menu item tag can be used to create new menus. The attribute name specifies how the menu's name will be displayed. Additionally, you can provide the menu's sequence, which refers to the order in which you want the menu to appear. Only if the menu item or any of its submenus has an action will it appear on the screen.
For example:
<menuitem id="menu_root_hospital" name="Hospital Management"/>
	 https://lh6.googleusercontent.com/wfDxl7MPzgdpsrpJBgG8TJ_nnHjwBEmrLmv70Hzqmv1ZE3EO6jgm_Bkkm-v9H11RkTnL9ys5YPWpjeh7eo7_kr-TZgY88DjZ-VDasWJdvEhpPsHuE9kvK2Z_8NfN4JtlUKM3oKuM8dEeZyh5lhCGdXo 



Sub Menu
You can create a submenu for the main menu. For creating a submenu, a parent menu is required.
For example:
<menuitem id="menu_hospital_menu" name="Hospital" action="hospital_action" parent="menu_root_hospital"/>
<menuitem id="menu_patient_menu" name="Patient" action="patient_action"
       parent="menu_hospital_menu"/>
	Two submenus are here. The main menu has a hospital submenu.
The Hospital menu includes Hospital Management and Patients.
Patient menus have actions, so when a menu item is clicked, the accompanying action is displayed.


 https://lh5.googleusercontent.com/piecUWCQGpTRB1DWxgia7-zKI_SVUeOz0lPGTht-SzNSuJpowbC64LTAAOi6-5gcX7rrvaPHTiy8DnG1iZJZoftk1iaEkc34-8QVQtA-mu5RUGQD0NjW9dwiPXROKjNLRWhi0-AdLPwjZBLa6WToBFY 

Next is to define the action. The menu or its submenu should have an action for viewing the menu.
For Example:
<record id="patient_action" model="ir.actions.act_window">
  <field name="name">Patient</field>
  <field name="res_model">patient.info</field>
  <field name="view_mode">tree,form</field>
  <field name="help" type="html">
  <p class="o_view_nocontent_smiling_face">No patients     found. Let's create one!</p>
<p>To get things done, use activities and status on    patients.</p>
</field>

</record>
	

From the action:
name: Name of the action
res_model: Name of the action
view_mode: The viewing mode, in this case, list and form and must desire to provide views that correspond to the view modes.
Help: If there is no data, a message inside the help will be displayed.
Menus from The UI:
Using the user interface, it is also able to construct and modify menus and submenus. For that, Go to > Settings > Technical > User Interface > Menu Items.
 https://lh6.googleusercontent.com/6ppWTawhHgEZim-r_rp-a-2CBSdWQdOoBVp0dJYB3AaZyY64bsMC_UJxRqdXnQ0z7IdtIjqnyUo76k3TyLMSxK8qrLFbk3lpJ9WE6DeHSi2V8We8EGOgUGsQ0kCgRXPWXupolEUaiYROjRAGwxv81e8 



To create a menu from the UI, Go to > Menu Items > Create
 https://lh6.googleusercontent.com/riWluDvmQX_db-K_GwVFEULttHsR99v1Koolaeo335FoNjihwFZUH6SeEqtl2gaPW2tDyEX0StOEAPZaQwwXkEWsIWPBGa4TveWglVhup-u13BhzRjbPko3yGLbjrjUaxsAmT26o3dKNR0q6U0kClR4 



Here to create a menu in the new module hospital_management,
Menu - Name of the menu
Parent Menu - The parent menu
Sequence - Sequence of the menu item.
Action - Specify the action.
Access Rights - - Giving access privileges allows you to restrict access to a certain user group
Submenus - - You can add a submenu here if you want to expand the menu. When you visit the corresponding module after saving the form, the menus are now visible.


 https://lh4.googleusercontent.com/qI7kU12UqTkSupYfUJ-JoezuAECz1gi3zW-Ck9PSVaZfoPCxOkXkyUmcSI-7S4zAYCgvxq4rzd4gk_nGGZoDLYIfpYbJ0u4wUB11rV7N18X0aGdYCrxRpoFhaS_Sb4u_xQo5sQBW20xZtlC8MIa3Xwc 

In this menu, Report is a recent addition.
In this manner, the UI can be used to construct new menus and submenus.


Widgets
There are two options for accessing different pages in Odoo. Both the user interface and the code can be used to generate menus. You add menus and associated actions using XML, according to the code. Therefore, inside the views folder, you should first create a new XML file.
widget="many2many_checkboxes"
	

 https://lh3.googleusercontent.com/Sp0K8y9jQLA8sTbXtSzlu88a1NF_50St8X3pqQ5mz4ePRZGRvnqqenDebNpjX_Txhp_XpG3Jn9XYRiMSYzBEJqLF38H8PZdV09Jp5-1lkKlplxbqmJA8T2c1urZviRo9I9TJcfwFWkIE-hdEviaI58s 



2. Status bar
Use this widget to display the status. Code is 


widget="statusbar"
	

 https://lh6.googleusercontent.com/DQo3z0R3kcU7u45MvEbJoVa43-6zCKq5MfHFvhgHW9b55XPpDAsa5lxOgSiEZab7WP5fqHBIFcVyuPuzVhPMOMJGmoiJdx4wpcK--zn5rnJ3m0Gb3D8Z6p7QwXbd9Y3zxPJQNmlgVcFp2vF3T-KI2-U 



3. Percentpie
This widget will display the progress chart. The code is
 https://lh3.googleusercontent.com/rzy1_wQS80qbMX2_ZJ8OIAzEQputZbEFeHCR9gRR77okol3ywvKkp2adRQFhITytejhpKXTaLf3_A9zfmtY1sdp-t_YfFytmDZnQTFRrpEemLr9dj2tX09KDu6sKVEHrJDvihI7-ibjTlOR54et4QQc 



4. Guage
Similar to the percentpie widget, this one also allows you to enter a maximum value in the max field.
For example:
<field name="int_field" widget="gauge" options="{'max_field': 'another_int_field'}"/>
	

5. Progressbar
By using this widget, you will get the progress. You can use the 


widget="progressbar" 
	

 https://lh3.googleusercontent.com/8Cc504dkey36EIYi8gsZKTHOQSc5n9UQynoZVtOTnl3J4_us8oW4jF743w5jnp8We2MCD48ay0AclCrDxoQl6Q6YOQARClBnnP6mkY2SqzOEHrC_73HbXnL3MUxbU9nunwIGL04PZ164Xrx3W_cOyak 

6. Many2many Tags
It will display multiple items as tags. Code is 


widget="many2many_tags"
	

 https://lh5.googleusercontent.com/kapXg6lYq6XjqlQn81dQ9gvVWM6TAlPIb0CQ3fk5Sci1PwwJryqMN64qXdK70WdAEWjZ4yTwVebAOhp8NVK80KnE3wXvonR35mF7Hkdv5CsUVXnQdHgquFTzfqsApVg2vjdFRHLNc9aISfcAkeN1W-o 



7. Handle


By using this widget, you can drag the lineup and down. You can use the code 


widget="handle"
	

 https://lh4.googleusercontent.com/qTBsMD5JOmDCiySQpVLEsfccXC8tEqXJGU4aOMiaBEHx43lM3yhL5hch9QMLUw7CB8B7v81sgjJzfQOAQYfGbmxxpVDILAwmOPUuVwPGVmgDUSiKRr7W31OYIo2iIPsVyKkoCZsm6LRrYYK0vPEd5HA 



8. Many2many Binary
You can attach files by using this widget. Code is 
widget="many2many_binary" 
	9. Selection
It displays a list of items by using the code 


widget="selection" 
	10. Radio
This widget is used to get the radio button effect. Code is          
widget="radio" 
	

 https://lh6.googleusercontent.com/EDDVy8FCwJ6Qoh2Rx-h_BpCnnClBFwwLkD-nAhSd8uyXAZe9GhsvwycRxa0gTliJWkuypYLio_pankQUX9G1IDEOfloSmiRntpA_9NYX5B85Ng_ijubg4WwvOmwgCqYCHdFR_by2UHFIxFcRgk3e_c0 

Buttons
In Odoo, there are various kinds of buttons. On the form view, form buttons are produced. The form button invokes an item or action when it is clicked. Another kind of button is a smart button. Use smart buttons if you wish to include relevant records from another model into your own.
1. Form Buttons:
For creating a form button, first define the view. Inside the view, you can create the buttons by using the tag <button>
For example:
<record id="patient_view" model="ir.ui.view">
  <field name="name">patient.info.form</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <form string="menu">
           <header>
               <button name="button_done" string="Done" class="oe_highlight" type="object"/></header>
          <sheet>
              <group>
                  <field name="name"/>

                  <field name="age"/>
                  <field name="gender"/>
              </group>
              <group>
                  <field name="phone"/>
                  <field name="partner_email"/>
                  <field name="doctor_id"/>
              </group>
          </sheet>
      </form>
  </field>
</record>
	

Here, first defined a form view. A button object type was established inside the form view. The button, in this case is called button done.
The function for the related model can be defined in the python file under the name ‘button done’. You would get an error if a function was not defined.


 https://lh3.googleusercontent.com/YeYcPULr5XNDcQPjapT9XsO2Qji3JJlMwLDs7KeydVFxlKMS-0FcaVwOE7HIeJ1TCjyNDA-GVjzvu_PH3hsizbblSvb9LqGD5j9h79MbVeydKnj2K998S53w-QsjvOWVYNKogvtdcmsqTPnFJyCBMu0 



Action In Odoo, action-type buttons is also available.
The action button signifies that when the button is clicked, an action will be initiated. Use the action button to have a wizard launch when a button is clicked.


For example:
<record id="patient_view" model="ir.ui.view">
  <field name="name">patient.info.form</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <form string="menu">
           <header>
               <button name="button_done" string="Done" class="oe_highlight" type="object"/></header>
                      <button name="%(patient_info_action)d" string="Book Appointment" type="action" class="oe_highlight" />
          <sheet>
              <group>
                  <field name="name"/>

                  <field name="age"/>
                  <field name="gender"/>
              </group>
              <group>
                  <field name="phone"/>
                  <field name="partner_email"/>
                  <field name="doctor_id"/>
              </group>
          </sheet>
      </form>
  </field>
</record>
	

 https://lh6.googleusercontent.com/rxafAjgcGoKXiO3tphHjzVYe3v_X1c1B2eSyNFAr8qtQYvSxFVy4gL6sYceXsTl6-ehXy4_ox8O3hSWG6N_3YuOdSj4N9oJ_N0BZR4Jo-oM3mM8UA4omx1rZVdcrqoCiqU6BfQDSv7NZwh8JdTTqLj4 

When clicking the button, it performs an action. So here, you can see a new form is open when clicking this button.


 https://lh3.googleusercontent.com/XdZs6wxYJA0XKQfPxdGxV4Gv9-DxEMOpe5fvXK-L_8JaWAxmCFkf8QfC7Ntguax6OXDTBI1IkGVqeqNb4yx-rqms7kfUSRroiZ5G9EWSza-vuLNB66hf-0GKveq9DYXlfMoLJZFQT02htraJ3chgGxo 

2. Smart Button
The form views define smart buttons. And they have permission to access all the records connected to this form view.
For example
 <div class="oe_button_box" name="button_box">
  <button class="oe_stat_button" type="object" string="Appointments" name="show_appointments"
      icon="fa-pencil-square-o">
  </button>
</div>


	

Inside the form view, a new smart button was added here.
You must want to define a function with its name because the button is an object type. Icon is the term for the smart button's icon.
 https://lh6.googleusercontent.com/zTRADX0W0_qxzZMFroO_XODbnRESLpp3LZ8oNAkkcb_xFrb7XRxcSbw1XDb3cnW-Ihj6ASGdpnWWZqAJpXzwLk4P4mJQ8WTOhxDiA_TAIeR1t7l14AymjTjTk2qdyuN5vy0Yyaz7tOn5Z-jreYqMz_0 



Context & Domain
Using XML or Python, you can pass any information in context. Additionally, the domain is any requirement that aids in data filtering during searches. Therefore, when coding, context and domain will be more helpful. A context is a python dictionary that assists in passing necessary info to an Odoo function. You can see that practically every method in Odoo had a context argument to transmit data. Examples of many ways to use context are given below.


1. To pass default values for fields:
<field name="work_location_id" context="{'default_address_id': address_id}" />
	This way, you can set the default value for a field.
2. Setting default filters and groups by records
<group expand="0" string="Group By">
  <filter string="Department" name="department" domain="[]" context="{'group_by': 'department_id'}"/>
  <filter string="Company" name="company" domain="[]" context="{'group_by': 'company_id'}" groups="base.group_multi_company"/>
  <filter string="Employment Type" name="employment_type" domain="[]" context="{'group_by': 'contract_type_id'}"/>
</group>
	

Inside the context you can add the group_by field.
3. In Window actions
<record id="crm_lead_action_my_activities" model="ir.actions.act_window">
  <field name="name">My Activities</field>
  <field name="res_model">crm.lead</field>
  <field name="view_mode">tree,kanban,graph,pivot,calendar,form,activity</field>
  <field name="view_id" ref="crm_lead_view_list_activities"/>
  <field name="domain">[('activity_ids','!=',False)]</field>
  <field name="search_view_id" ref="crm.view_crm_case_my_activities_filter"/>
  <field name="context">{'default_type': 'opportunity',
          'search_default_assigned_to_me': 1}
  </field>
  <field name="help" type="html">
      <p class="o_view_nocontent_smiling_face">
          Looks like nothing is planned.
      </p><p>
          Schedule activities to keep track of everything you have to do.
      </p>
  </field>
</record>
	For defining default values for new records, use context in window actions. The default type in this instance is set to opportunity.
4. Python has a function
Context is also usable inside of Python functions. You can access any value from XML passed to your Python function as self.partner id is the value that is passed from the XML in this statement: env.context.get('partner id').
5. In search view and filters
<group expand="0" string="Group By">
   <filter string="User" name="user" domain="[]" context="{'group_by':'user_id'}"/>
   <filter string="Type" name="type" domain="[]" context="{'group_by':'resource_type'}"/>
   <filter string="Company" name="company" domain="[]" context="{'group_by':'company_id'}" groups="base.group_multi_company"/>
   <filter string="Working Time" name="working_period" domain="[]" context="{'group_by':'calendar_id'}"/>
</group>
	

Here added two filters inside the group tag, and passed the group_by using context.
Domain:
Domains can be used to search for or filter data or records depending on particular criteria. A field, operator, and value are all parts of a domain. You can filter the data using a variety of operators.
The syntax for the domain is: domain="[(field_name, 'operator', ‘value’)]"
The name of the field in the associated model to which the domain should be assigned is the field name. There are several distinct kinds of operators in Odoo.
-> comparison operators : < ,>, =, !=, <=,>=
-> [('name', '=like', ‘Mitchel’)] - This returns ‘Mitchel’
-> [('name', '=like', 'odoo')] - This returns ‘%odoo%’
-> [('name', '=like', 'odoo')] - This returns ‘%Odoo%’, ‘%odoo’
-> In’ and ‘not in’ : These are used to check if the value is present or not in the value list
-> child_of’ operator: It is used to find the child values in relation.
You can use domains in different situations
1. In a search view filter
<search string="Search for mrp workcenter">
  <field name="name" string="Work Center" filter_domain="['|', ('name', 'ilike', self), ('code', 'ilike', self)]"/>
  <filter name="archived" string="Archived" domain="[('active', '=', False)]"/>
  <group expand="0" string="Group By...">
      <filter string="Company" name="company" domain="[]" context="{'group_by': 'company_id'}" groups="base.group_multi_company"/>
  </group>
</search>
	

2. In record rule
<record model="ir.rule" id="res_users_log_rule">
  <field name="name">res.users.log per user</field>
  <field name="model_id" ref="model_res_users_log"/>
  <field name="domain_force">[('create_uid','=', user.id)]</field>
  <field name="perm_read" eval="False"/>
</record>
	

3. fields_view_get() method
Use the domain in the fields view get method to specify dynamic values for domain filters ().
4. To filter relational object fields records
partner_id = fields.Many2one('res.partner', 'Account Holder', ondelete='cascade', index=True, domain=['|', ('is_company', '=', True), ('parent_id', '=', False)], required=True)
	

5. To display specific records
<record id="action_bank_statement_tree" model="ir.actions.act_window">
  <field name="name">Bank Statements</field>
  <field name="res_model">account.bank.statement</field>
  <field name="view_mode">tree,pivot,graph</field>
  <field name="domain">['|', ('journal_id', '=', False), ('journal_id.type', '=', 'bank')]</field>
  <field name="context">{'journal_type':'bank'}</field>
  <field name="search_view_id" ref="view_bank_statement_search"/>
  <field name="help" type="html">
    <p class="o_view_nocontent_smiling_face">
      Register a bank statement
    </p><p>
      A bank statement is a summary of all financial transactions
      occurring over a given period of time on a bank account. You
      should receive this periodically from your bank.
    </p><p>
      Odoo allows you to reconcile a statement line directly with
      the related sale or purchase invoices.
    </p>
  </field>
</record>
	

List Views
In Odoo, views are mainly for visualization, and it is more user-friendly. You can describe a view's appearance while defining it. In Odoo, there are various views that offer various visualizations. A form of view called a list view resembles a tree or list structure.
Furthermore, you can view numerous records on a single screen.
For creating a list view, first, you want to define a model and its fields. I.e.,
class PatientInfo(models.Model):
  _name = 'patient.info'
  _description = 'Patient Information'
  name = fields.Char(string="Name")
  age = fields.Char(string="Age")
  gender = fields.Char(string='Gender')
  phone = fields.Integer(string="Phone")
  partner_email = fields.Char(string="Email")
  doctor_id = fields.Many2one('res.partner')
	Here defined a new model hospital. Patient and also created new fields for the model. Then the next step is to define a view from XML.
i.e.
First define the action window for the views.
<record id="patient_action" model="ir.actions.act_window">
  <field name="name">Patient</field>
  <field name="res_model">patient.info</field>
   <field name="help" type="html">
<p class="o_view_nocontent_smiling_face">
 No patients found. Let's create one!
</p>
<p>To get things done, use activities and status on patients.
</p></field>
  <field name="view_mode">tree,form</field>
</record>
	List view:
<record id="hospital_patient_search" model="ir.ui.view">
  <field name="name">patient.info.search</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <search>
          <field name="name"/>
          <field name="partner_email"/>
          <field name="age"/>
          <field name="gender"/>
      </search>
  </field>
</record>
	

Here, the tree element serves as the list view's root element, and you can specify the fields you wish to see on the tree view or list view inside the tree tag. Use the editable attribute to make the tree view editable if you wish to. For this characteristic, top and bottom values are possible. To prevent the deletion of the record, use delete=False.To prevent the creation of the record, use create=0.edit=0 stops the record from being edited. For example, if we set limit=50, then only 50 records will be shown in the tree view. You can set a limit for the tree view.


Search View
In Odoo, there are various view kinds. The search view is unique compared to other views because just a portion of the items will be seen in the search view. Since form views only contain one record, it is used to filter the contents of other views rather than those of the form view.
For example:
<record id="hospital_patient_search" model="ir.ui.view">
  <field name="name">patient.info.search</field>
  <field name="model">patient.info</field>
  <field name="arch" type="xml">
      <search>
          <field name="name"/>
          <field name="partner_email"/>
          <field name="age"/>
          <field name="gender"/>
      </search>
  </field>
</record>
	

 https://lh4.googleusercontent.com/mjIWBWu3lH9240aH5nOsNXx5h-sC40rpqmsjnsTasfKwq5aTPq0AKcNixxtutUG03qvwnXR7TREc9D53TJz4ZYBGsnFH-ag1gV0yxKpxU2-GGcdALD4LNXQf2AjnZZdjyoTW-S_DOtW3fWcjkPP2MLU 

When clicking the archived filter, you will get all the archived records. Different filtering conditions can be specified in the domain attribute.
If you choose to group by, you can include filters both inside the group tag and the search tag.
Filters and Group By:
There are filters and groups by in the search view. Records are filtered based on conditions using the filter command, and groups are grouped based on a field using the group by command. There is a simple way to add these by default, so you don't have to constantly select "Add Custom Filter" or "Add Custom Group."The search tag's filter tag is used to add a filter.
For eg:
<filter string="Gender" name="gender"
      context="{'group_by': 'gender'}"/>
	 https://lh4.googleusercontent.com/d68KyZQiC5ihm5hxKENjvd7_bi0XXN2M24Bp8zPmq0CZRnmV5DjfOVm8Q8Dj7sRGlJ-6SkGpyLjM_W_yyc8gFRq837KoIQGuu6ghfPJ6Z05zKLRSiGg14evYoyHgpw6DbgmKK7BC7vcPvfKm0MCewDw 

You will see all the archived records when you select the archived filter. Different filtering conditions can be specified in the domain attribute. If you choose to group by, you can include filters both inside the group tag and the search tag.
i.e.,
<group expand="0" string="Group By">
<filter string="Gender" name="gender" context="{'group_by': 'gender'}"/>
</group>
	 https://lh4.googleusercontent.com/tJb_vNqSbzbYe5hjZIXLTDoxkDijyTbaqcQUCuKhLiy4-9bFtZb-V_kvxM5U7p_36P8e1Xg9RM_wlELSWNdKbPmq1SaJeD5wbymtj6GzBTXlo5EPkiLPe8o9X0boxxz8G2yGluf1BvONjZ2-re2VQWc 

Applying a gender grouping here.The data will be sorted according to the gender field. Context is used to pass data for grouping.
While other fields can also be used for the group by filters, the attribute name is necessary.


View Inheritance
There are numerous view types in Odoo. In Odoo, you must first inherit the pertinent view before making any alterations to an existing view. It is possible to inherit any view, including form, tree, kanban, search, etc. To inherit a view, you must make an XML file for the inheritance in the views folder. Include this file path inside the data manifests as well. The inherited records can be added to the XML file.
i.e.,
<record id="view_crm_meeting_search" model="ir.ui.view">
  <field name="name">calendar.event.form.inherit</field>
  <field name="model">calendar.event</field>
  <field name="inherit_id" ref="calendar.view_calendar_event_search"/>
  <field name="arch" type="xml">
      <xpath expr="//field[@name='description']" position="after">
          <field name="opportunity_id"/>
      </xpath>
  </field>
</record>
	

Here, the form view calendar event search, which is inside the module calendar, is inherited. The parent view id that you want to inherit is specified using the inherit id function. For the inheritance, you can add module name.parent view id. After that, you can make adjustments using the XPath tag. Additionally, you can specify several XPath values.
Expressions can be added in a variety of ways:
Some examples are
expr="//field[@name='user_id']"
expr="//sheet/div[last()]"
expr="/kanban"
expr="."
expr="//filter[@name='activities_overdue']
expr="//header"
expr="//button[@name='action_open_product_lot']"
	

Also you can give different positions to the xpath. i.e.,
position=”after” : Display the field after the parent view mentioned in “expr”
position=”before” : Display the field before the parent view mentioned in “expr”
position=”inside” : Display the field inside the parent view mentioned in “expr”
position=”attributes” : Change the field attributes
position=”replace” : Replace the parent view field with newly created field
Form Style
If you want to provide customers with a consistent experience, you can style the document form in Odoo. You have a number of options for styling a form.
1. Header Element
Use the header element for adding buttons or status bars at the starting of a form.
For example
<header>
<button name="action_quotation_send" string="Send by Email" type="object" states="draft" class="btn-primary" data-hotkey="g"/>
<button name="action_cancel" type="object" string="Cancel" attrs="{'invisible': ['|', ('state', 'not in', ['draft', 'sent','sale']), ('id', '=', False)]}" data-hotkey="z"/>
<button name="action_draft" states="cancel" type="object" string="Set to Quotation" data-hotkey="w"/>
<field name="state" widget="statusbar" statusbar_visible="draft,sent,sale"/>
</header>
	2. Sheet Element
Next, you can add a <sheet> element. Inside this element, you can add all other fields.
3. Smart buttons
Smart buttons can be used to retrieve more records associated with this object. The top of the sheet will then get smart buttons added.
<div class="oe_button_box" name="button_box">
  <button type="object" name="action_reconcile_stat"
    class="oe_stat_button" icon="fa-book">
      <field name="number_entries" string="Journal Entries" widget="statinfo"/>
  </button>
</div>
	4. Prominent fields
If there are any prominent fields, then put them first.
<div class="oe_title">
  <h1><field name="name" class="oe_inline"/></h1>
</div>
	Then you can add all other fields.
5. Notebook
If there are a lot of fields on the form, then we can arrange them as notebook pages.
<notebook>
  <page string="Internal Notes" name="internal_notes">
      <field name="description" placeholder="Add a description..." options="{'collaborative': true}" />
  </page>
</notebook>
	You can add more pages to a notebook.
6. Chatter widget
If you want to add a chatter on your form, you can add it after closing the sheet element.
<div class="oe_chatter">
  <field name="message_follower_ids"/>
  <field name="activity_ids"/>
  <field name="message_ids" options="{'post_refresh': 'recipients'}"/>
</div>
	


Kanban view
In Odoo we can create several views. such as tree view, form view, list view, kanban view, pivot view, calendar view, etc. The kanban view is a kanban board visualization. It displays records like block”, and we can add images in the kanban. Here we can’t edit the records from the kanban view.
Let's check how to create a new kanban view:
Create a model example.odoo.
class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	    
After the model is created, we can add the menu and the corresponding menu action for this model


<record id="action_Example" model="ir.actions.act_window">
        <field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">kanban,tree,form,graph,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	

Now set the kanban view for the model with the corresponding design. Don’t forget to add the required fields. 


<record id="example_kanban_view" model="ir.ui.view">
            <field name="name">example</field>
            <field name="model">example.odoo</field>
            <field name="arch" type="xml">
                <kanban class="o_kanban_mobile" sample="1">
                    <field name="example_field"/>
                    <field name="example_field1"/>
                    <field name="id"/>
                    <templates>
                        <t t-name="kanban-box">
                            <div t-attf-class="oe_kanban_global_click">
                                <div class="o_kanban_image">
                            <img t-att-src="kanban_image('example.odoo', 'example_field', record.id.value)" class="o_image_64_max" height="52"/>
                      </div>
                      <div class="oe_kanban_details">
                          <strong class="o_kanban_record_title">
                          field: <field name="example_field"/>
                          </strong>
                      <div t-if="record.example_field1.value">
                            field1: <t t-esc="record.example_field1.value"/>
                      </div>
                      </div>
                            </div>
                        </t>
                    </templates>
                </kanban>
            </field>
        </record>
	





The output of the above model is
 https://lh3.googleusercontent.com/Q--QS0e-9RIdOwUxeUXdhOJ9j2U0PwEf5Oo8rh3pimVoNijZY9xgNP1HQpSORYJEAz3RnhdwPR6KJKEqDCy5qWuKw2qmb3adbVqTEG1XRvcEdssJgjSlS26tH7V91fCxSWF6A8VaN0zd5nDfX6jPI5s 



Graph view
One of the views that Odoo provided to us is the graph view. It is a graphical view of the data, and it can be represented like a Bar chart, Pie chart, and Line chart. So that users get an easy understanding of the records.
Now let’s create a graph view:
Created a model example.
from odoo import models, fields


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	 
And then add the action for the menu,
<record id="action_Example" model="ir.actions.act_window">
<field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">kanban,tree,form,graph,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	

After creating the model, menu and the action we can set the graph view for the model.
<record model="ir.ui.view" id="example_graph_view">
          <field name="name">example.graph</field>
          <field name="model">example.odoo</field>
          <field name="type">graph</field>
          <field name="arch" type="xml">
                      <graph string="Example" type="bar">
                          <field name="example_field" group="True"/>
                          <field name="example_field" operator="*"/>
                      </graph>
          </field>
</record>
	







The output of graph view model is,
 https://lh4.googleusercontent.com/S-LwAvBsMipp6XoGnEW3O82-2hIWKQTql4uSlwU04bAHxS9hXiom6vC1Hnn50WRn9pVROn0VE0bovSEYWpiplRxeRoRTGsUO192kj8VHExv1tus_KgK1qiOZlVzlD1fPjeP2QOyV0h2TdG2NFmkEJLI 

Pivot view


A Pivot table view is the best tool to calculate and also analyze data. In Odoo, we can create pivot tables for our model so that users get a table structure of all the records. 
Let us see how to set the pivot table.
First, we have to create a  model, menu, and menu action.


from odoo import models, fields


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	

 
<record id="action_Example" model="ir.actions.act_window">
        <field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">form,tree,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	Then create the pivot view like this.
<record id="example_pivot_view" model="ir.ui.view">
    <field name="name">example.pivot</field>
    <field name="model">example.odoo</field>
    <field name="arch" type="xml">
        <pivot string="Project Tasks">
            <field name="example_field" type="row"/>
            <field name="example_field1" type="col"/>
        </pivot>
    </field>
</record>
	The output will be
 https://lh3.googleusercontent.com/Dsoy0DH21xEpy2XfOhrvDjbaNYKyxP-0wF34wia0WY3Au2rUeUmBqrFRqgAe89G8vK1JHF3V9GYLfwHedajDBrykZg-iekTeKAV9xSgqX-GFfsQrcAqve5V3Sjkkp8LUG2chF_fSMp9ZhyDhfJQj0NM 

Cohort view
One of the views that support Odoo is the cohort view, which gives information for the next 15 days, weeks, months, and years. So that we can get a good analysis of data in a specific time frame, let us look at an example.


from odoo import models, fields


class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	

from odoo import models, fields


class ModelExample(models.Model):

    _name = 'model.example'
    patient_id = fields.Many2one('hospital.patient', string="C")
    na
me = fields.Char(string='Name')
    date = fields.Date(string="Date")
    attachment = fields.Binary(string="Attachment")


class HospitalPatients(models.Model):

    _name = 'hospital.patient'
    name = fields.Char(string='name')
    dob = fields.Date(string='date')


	

After adding models, we can set the action and menu for these models.


<record id="action_Example1" model="ir.actions.act_window">
        <field name="name">Example1</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">model.example</field>
        <field name="view_mode">tree,form,cohort</field>
    </record>

    <menuitem id="model_example_menu"
              name="Model Example"
              parent="example_menu"
              action="action_Example1"/>
	

Now we can set the cohort view for the model.
<record id="model_example_cohort" model="ir.ui.view">
  <field name="name">model.example</field>
  <field name="model">model.example</field>
  <field name="arch" type="xml">
      <cohort string="model" date_start="date" date_stop="date" interval="day" sample="1"/>
  </field>
</record>
	Don't forget to add the ‘web_cohort’ in the depends otherwise it will encounter an error
There are two types of mode in cohort view which are retention and churn.
Churn starts from zero and ends at zero. Retention will start from 100 % and decrease to zero
The output of the above code will be
 https://lh3.googleusercontent.com/0Z5M7Ups3-Bxp5jOSWa0qN80ORFwYDOnb9-iX3h2c27JPvdt9bp0ozhy2dVlxHV_YD6nVgl6H6KJq-gdtzHrkLeL_NOnsBVHAvJjm5flCJDSH9oWk0sXiWCpvQ8p_SzXHdVJh0JME-ut9TZRzqPvguY 



Dashboard view
Dashboard view is used to get a good understanding of the various business KPIs. It will provide us a good overview of the records we can only get through this facility in the Odoo enterprise version. If we want to set up a dashboard view in your module, don’t forget to add the ‘web dashboard’ in the dependency in the manifest file. Let us take an example,
<record id="view_helpdesk_dashboard" model="ir.ui.view">
    <field name="name">Hepldesk dashbaord</field>
    <field name="model">helpdesk.ticket</field>
    <field name="arch" type="xml">
        <dashboard>
            <view ref="helpdesk.helpdesk_ticket_view_graph_analysis"
                    type="graph"/>
            <group>
              <aggregate name="all_ticket"
                  string="Total Ticket"
                  group_operator="count"
                  field="id" measure="__count__"/>
                  <aggregate name="progress_tikets"
                              string="In Progress Ticket" domain="[('stage_id.name', 'ilike',
                              'In Progress')]"
                              group_operator="count"
                              field="id" measure="__count__"/>
                  <aggregate name="done_ticket"
                              string="Done Ticket"
                              domain="[('stage_id.name', 'ilike',
                              'Done')]"
                              group_operator="count" field="id"
                              measure="__count__"/>
                  <formula name="average"
                            string="Overall Progress"
                            value="record.done_ticket / record.all_ticket"
                            widget="percentage"/>
            </group>
            <view ref="helpdesk.helpdesk_ticket_view_pivot_analysis"
                    type="pivot"/>
        </dashboard>
    </field>
</record>
	Now we can add the menu and action for this view.
<record id="act_window_dashboard" model="ir.actions.act_window">
    <field name="name">Dashboard of tickets</field>
    <field name="type">ir.actions.act_window</field>
    <field name="res_model">helpdesk.ticket</field>
    <field name="view_mode">dashboard</field>
</record>
<menuitem id="dashoard_ticket_menu"
    name="Dashboard"
    parent="helpdesk.helpdesk_ticket_report_menu_main"
    action="act_window_dashboard"
    sequence="28"/>
	Here we can see that the dashboard view can include different types of graphical representation. 
To specify these views, we will give these views XML reference in the <view> tag’s ref attribute.
Gantt view
In Odoo, we can create several views such as tree view, form view, list view, kanban view, pivot view, calendar view, etc. The Gantt view is a Gantt visualization.
It is one of the advanced types of view in Odoo. We can access this feature only in the enterprise version. If you want to use the Gantt view in your custom module, you should have to install the “web_gantt” and also mention the module ‘web_gantt” in the manifest.
Let’s take an example.
class ExampleOdoo(models.Model):
    _name="example.odoo"
    example_field = fields.Char(string="Example Field")
    example_field1 = fields.Many2one('res.users', 'User', required=True)
	    
After the model is created, we can add the menu and the corresponding menu and action for this model.


<record id="action_Example" model="ir.actions.act_window">
        <field name="name">Example</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">example.odoo</field>
        <field name="view_mode">kanban,tree,form,graph,pivot</field>
    </record>

    <menuitem id="example_menu"
            name="Example Odoo"
            action="action_Example"/>
	

Now we can define the ‘Gantt’ view for this model.
<record id="student_assignment_gantt" model="ir.ui.view">
        <field name="name">model.example.view.gantt</field>
        <field name="model">model.example</field>
        <field name="arch" type="xml">
            <gantt
                    date_start="create_date"
                    date_stop="date"
                    default_group_by="name"
                    default_scale="week"
                    color="student_id"
                    scales="day,week,month,year"
                    precision="{'day': 'hour:full', 'week': 'day:full', 'month': 'day:full', 'year': 'day:full'}"
                    thumbnails="{'employee_id': 'image_128'}">
                <field name="student_id"/>
                <templates>
                    <div t-name="gantt-popover" class="container-fluid">
                        <div class="row no-gutters">
                            <div class="col">
                                <ul class="pl-1 mb-0">
                                    <li>
                                        <strong>Start Date:</strong>
                                        <t t-esc="userTimezoneStartDate.format('YYYY-MM-DD hh:mm:ss A')"/>
                                    </li>
                                    <li>
                                        <strong>Stop Date:</strong>
                                        <t t-esc="date.format('YYYY-MM-DD hh:mm:ss A')"/>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </templates>
            </gantt>
        </field>
    </record>
	


Activity view
One of the useful views that support Odoo is the activity view which helps the user to manage every business operation. In this view, we get information about the activities that are related to our records so that users can easily identify the scheduled activities.
First, we need to add “mail” to the depends
Like, 'depends': ['mail'],
After adding the depends in the manifest, we need to inherit mail.thread and mail.activity.mixin models.
Model for an example,
class Activity(models.Model):
    _name = 'activity.demo'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    name = fields.Char(string='Name', required=True)
    demo_field1 = fields.Many2one('res.users', 'Author', required=True)
    no = fields.Char('Sl No', required=True)
	 Action definition
<record id="demo_action" model="ir.actions.act_window">
    <field name="name">demo</field>
    <field name="type">ir.actions.act_window</field>
    <field name="res_model">activity.demo</field>
    <field name="view_mode">tree,form,activity</field>
    </record>
	Also the  activity view define 
<record id="demo_view_activity" model="ir.ui.view">
  <field name="name">Book</field>
  <field name="model">activity.demo</field>
  <field name="arch" type="xml">
        <activity string="Applicants">
            <templates>
                  <div t-name="activity-box">
                        <div>
                            <field name="name"/>
                        </div>
                  </div>
            </templates>
        </activity>
</field>
</record>
	Map View
One of the views that Odoo support is map view it displays the record on the map. Its root element is <map>. Here is an example.
Don't forget to add 'depends': [web_map], in manifest
To do this, first we have to create a model.
from odoo import models , fields


class Book(models.Model):

    _name = 'odoo.book'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    display_name = fields.Char(string='Name', required=True)
    author = fields.Many2one('res.partner', 'Author', required=True)
    sl_no = fields.Char('Sl No', required=True)
	Now we can arrange the corresponding model's view and map view.
So first we can create an action for the model.
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="odoo_book_action" model="ir.actions.act_window">
        <field name="name">Book</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">odoo.book</field>
        <field name="view_mode">tree,form</field>
    </record>
	 Now we can set the map view.
<record id="odoo_book_map" model="ir.ui.view">
        <field name="name">odoo.book</field>
        <field name="model">odoo.book</field>
        <field name="arch" type="xml">
            <map res_partner="author">
            </map>
        </field>
    </record>
	

<record id="odoo_book_action_map" model="ir.actions.act_window.view">
        <field name="sequence" eval="3"/>
        <field name="view_mode">map</field>
        <field name="view_id" ref="odoo_book_map"/>
        <field name="act_window_id" ref="odoo_book_action"/>
    </record>
	After creating a record in this model, we can see the map view.
 https://lh3.googleusercontent.com/iuI63mUsw5TU9wDZFC8cC5OV9BVquQ5c8Ck4MlBKaGwCq49bhhCMetFKbg7ndT5b7_QTZD0Z6zcMjMH5J40vhSXAUBPZipBD7719PbcAVnnYOFBHJRudVOdKcn9g3GavB30sF1mZRY9KX04b9JBL4zI 

07. Security
Access rights
The access rights are regulations that specify how a user can access a specific object. Access rights follow the CRUD model [create, read(search), update(write), delete] 
* Create: values for that object can be created by the user.
* Read: the values of that object can be only seen by the user.
* Update: the values of that object can be edited by the user.
* Delete: the values of that object can be deleted by the user.
If a user doesn’t have access rights, the related menus and views are not displayed to the user. 
The user is the only person who is allowed to access the database. We can create many users for a single database. They are identified with their own login and credentials. A user has no access privileges by default. It should be noted that not all firm personnel are necessarily Odoo users; rather, an Odoo user is someone who utilizes the program.
Odoo provides two primary data-driven strategies for controlling or restricting data access, in addition to using custom code to accomplish so. Through groups, both systems are linked to specific users: A user can belong to as many groups as they want, and security mechanisms are associated with groups; therefore, security mechanisms are applied to users.
Let’s assume a case that, we are going to create a custom model. So for giving access to users in this model, we need to add the security directory in the corresponding module. And add the ir.model.access.csv file to that.
Consider the below example 
id,name,model_id/id,group_id/id,perm_read,perm_write,perm_create,perm_unlink
access_test_model, access_test_model, model_test_model, base.group_user,1,0,0,0
	Here,
*  ‘id’ is indicating the external identifier.
* ‘name’ is the name of ir.access.model
* model_id/id refers to the model to which the access right applies. The standard way to refer to the model is model_<model_name>, where <model_name> is the _name of the model with the ‘.’ replaced by _. Seems cumbersome? Indeed it is…
* group_id/id refers to the group to which the access right applies to.
* perm_read,perm_write,perm_create,perm_unlink: read, write, create and unlink permissions
Finally, need to add this ir.model.access.csv file to the __manifest__.py file.
'data': [
  'security/ir.model.access.csv',
],
	

—-------------------------------------------------------------------------------------------------
Record rules
Records are filtered depending on record rules while accessing an object. So filters that restrict the records of an item a group can access are record rules or access filters. Each record has a set of requirements that must be met in order for it to be generated, read, updated (written), or removed. Records are filtered, so they don't match the requirements. Record rules can grant or reject access to individual records.
Let’s consider the below code for the record rule creation,
<record id="school_student_rule" model="ir.rule">
   <field name="name">Student Records</field>
   <field name="model_id" ref="model_school_student"/>
   <field name="domain_force">[('user_id', '=', user.id)]</field>
   <field name="groups" eval="[(4,      ref('school_management.school_management_student'))]"/>
   <field name="perm_read" eval="True"/>
   <field name="perm_write" eval="False"/>
   <field name="perm_create" eval="False"/>
   <field name="perm_unlink" eval="False"/>
</record>
	

As per the above code, going to create a record on ‘ir.rule’ model.
*  ‘id’ of the record should be unique. 
* ‘name’ is the name of record, which will be shown in the user interface.
* ‘model_id’ indicates the model where we are going to use this record rule. So the ref becomes model_modelname. Here model name is school_student, so ref = model_school_student
* ‘domain_force’ acts as a filter for this record.
* ‘groups’ indicate the groups which are going to use this record rule.
* And finally, we can set up the permission to read, write, create and unlink. If the ‘eval’ is true means, we have permission. If it is false, we don't have permission.
We can access record rules from the user interface. Activate the debug mode. Go to settings -> Technical -> Record rules.
—-----------------------------------------------------------------------------------------------


Groups


Groups are the set of users who share some access permissions. Let’s look at how to create security groups.
All security-related files are added to the security directory.
 https://lh3.googleusercontent.com/WS9yzGwZGbWLZqGSy8INly3tKkGyJD6qwHGKhVmD5fQZoGB2qSTQzjm9UASvsDEW3gUjaxqjNeo6c1LLJ3P-nOqNFh4vtUo9CGVhHnuKqcEjSKNvv49gvVKobLLiKklEJS6pFdpbRsCfc8E-yG26ZE0 

Also, this path will be added to the __manifest__.py


'data': [
'security/ir.model.access.csv', 
'security/security.xml'
],
	

First, we can create an XML file for the security group. For that, going to create a record in the ‘res.groups’ model.


<record id="school_management_student" model="res.groups">
  <field name="name">Student</field>
  <field name="category_id" ref="school_management.school_management_accesss"/>
</record>
	

Here we mainly mention the name and category_id for the group.
id: id of the record, which will be saved in the res group table and is distinct for each record.
name: the record's name. It is a name that people can read, and the user interface displays it.
category_id: This is the category to which this record belongs.
Therefore, we must construct a category to provide the category's id. For that, we are creating a record in the ‘ir.module.category’ model.
<record model="ir.module.category" id="school_management_accesss">
  <field name="name">School Management</field>
</record>
	

For accessing groups from the user interface, enable the debug mode. Go to general settings -> users & companies -> select groups option.
Under this option, we can see all the groups created in the database.


We can also use these groups in the ir.model.access.csv files as per our needs. (please refer to the highlighted part of below code)


id,name,model_id/id,group_id/id,perm_read,perm_write,perm_create,perm_unlink
access_test_model, access_test_model, model_test_model, school_management.school_management_student,1,0,0,0
	

Hide/View menu based on groups


Let us have a look at how to hide/view menus based on groups.
First, consider a button view. We all are familiar with the header tag. Most of the buttons are defined inside the header tag. We can give groups in both header and button tags.


<header groups="education_organisation.group_education_organisation_user">
  <button groups="education_organisation.group_education_organisation_user" name="get_top_score_students"
      string="Get Top Score Students" class="oe_highlight" type="object"/>

</header>
	

Here the groups are defined like ‘module_name.group_id’. Here this header tag is only for the specific user group ‘education_organization.group_education_organisation_user’. In the same way, we can mention the group for the button tag too.
Next, we can consider a menu. By adding groups to the Menu item, we can indicate the group for whom the menu item should be displayed.


<menuitem id="res_config_settings_menu"
   parent="config_menu"
   name="Settings" sequence="10"
   action="dev_book.res_config_settings_menu_action"
groups="education_organisation.group_education_organisation_admin,education_organisation.group_education_organisation_user"/>
	Additionally, you can designate multiple user groups. Add each user group category for the groups attribute, separated by commas.


—----------------------------------------------------------------------------------------------
Superuser access to record sets
The sudo() is the method where we can access recordsets as superuser. Access to records can be managed using different techniques like record rules, access rules, and so on. 
The sudo() can break all the access rules and record rules. Let us look at an example, 
class Student(models.Model):
  _name = "student.student"
  _description = "Student"
  name = fields.Char(string="Name", required=True)
  phone = fields.Char(string="Phone Number")
  email = fields.Char(string="Email", required=True)
  status = fields.Char(string="Status", groups="edu_organisation.group_organisation_admins")
	

Here, we can see a model which records all student's related data. Consider the field ‘status.’This field is only accessible by admins group users.
Next, we can create a button to update the student's records status.


<button name="update_status" string="Update Status" class="oe_highlight" type="object"/>
	Here, we need a method to work this button. Since the status field is only accessible to the Admins, it is necessary to use the superuser access in the button click method. For that, use sudo() in the method. Before using the write method, we used sudo() for accessing the current record set with superuser access. This will return the same record set with a different environment, that is, the environment from the superuser, and it will bypass all access rules and security rights. This way, a user who does not include in the Edu Organization Admin category can update the status field value.


def update_status(self):
  self.sudo().write({
      'status': "Status Updated"
})
	















08. Internationalization
Import language and set user preferences 
The user can set their own language preferences in Odoo. This chapter helps to understand the methods to set the language for user needs.
Import Language
We can use the Import Translation feature to import a new language in Odoo. For that, open the Settings app and select Translations->Import Translations.
 https://lh5.googleusercontent.com/Usk0VbHp8SbhEXHfNus2yb6H9ZDMO062OVDsKQdpCT_sXKb6l69UyFqfZ9nlGECjuxe7KKLlHzAZlSDS5tvi4R09h98Umi1UPpmeigmxhW8OpCcJpB9NGbO4sDvRW8FAB3YlgA_TxFTzc8snDvH4SsE 

We can add the restatement train for the new language in the wizard by entering its name and legal system. Enable the checkbox to overwrite restated terms. Since we're importing a new language, there won't be any restated terms for the new language. To include the new language, select Import. 
 https://lh5.googleusercontent.com/BohuJVqHH42wJnCqKUuYHIk8Ya9_UxFjncxw7wEUr9ucWRpjKceIOHHgH55JP9h6dXr0rJCWB08R6Wf0YeOE5l9Ejr9ujMZZ4260MCTiZb40tiFQk5ei4CXVKQGSzbpH904gKryTxBfl2LpKtb1xgzU 



The language will be default active and accessible with other languages (Translations->Languages).


 https://lh6.googleusercontent.com/R1xPi4-UOs8sRtSq_gn7_0HiepMz5FO0TonepBl5m52eKqnQq7NEXzmDmypNzfrX0Aoi3jiE0KNBea6EHQrTi6F064OalJN0f9e8odfFAdwvsvszlipyYvRpwisjttGyHIq1f_FxIQopwPBvHhULEb0 



Set user preferences:
Under the Preferences tab, we may configure the user's time zone and language.
 https://lh6.googleusercontent.com/CiBcivJZ3gPBVhVxkXjRlpOE8Gh54Ucm27RxjakxUfHqTjr7BDxUd-TJ7DwjZrLbOzuCRyC1MPSZWGC2NjMv1y9849dp1LG13f1s-CYAy5XHKd0McayXrB-0wk2Kabw1WiUNBV31dHUEbOOU866vLWA 



Go to Users & Companies->Users in the Settings app or select Manage Users in the Users section to set the user preferences for other users.


 https://lh5.googleusercontent.com/SdJwI2ICMJM0tWt4ujMdfVzK1ZLrjG4rtHTb6mzff_CFiBeYZTOBVJSeZlhSVIz-U3S7OehlGnNJPzXU1_klBUuPrh-3kfAxD4uJRNzh7e4r002CTUfFyem0mBKbALQfE8C_7DlozwlMfkTNgX9-gyc 







From the tree view, choose the user.
 https://lh4.googleusercontent.com/5KYPu125-nbrFukFCyt3Xv95jJnZXvJDUFmz-0Tg8_OBTE9I4G3hSJyOFAH59btKLjWOLL6-9milnTg6Lq0ShW5IPLT-z6ATsqPM7bxH1nPQrJ1rnFsFQJ61ZKw5sRvzVfbVxeJ24BOsUYAwUDypp5Y 

In the User Form View's Preferences area, we may customize the user's language.
 https://lh5.googleusercontent.com/fN7D8bes7kuEQf0KX5cOxCs8R-ec_KBnisb-o62e43QxkrF_bZZRlykoF6GRP5-t5uEnVcutUBn1LcgkYdiIrXpDLR3l0pCDdSKiBH57vyxFB0oKuRwjqjYWzWjqmc5gDZWCBdIpMthf-1cBq4P5M5Y 

Configure settings in the language
To view all of Odoo's supported languages, navigate to Settings->Translations->Languages.
 https://lh5.googleusercontent.com/3RMDCeoudpxJIjPPascEJxwYFNBlCHYzaBr69_W5yw4yT65TLMrRODTIEqJj2DsHk45nXFve5TvTAcsBDsmm1O86hUvuXhGdmPQQUklwWeC_ndBePVEMK7W0beCswbS0fqd9qHWn7wRQS8UVRtVF-Ko 

Select one language to configure the settings.
 https://lh4.googleusercontent.com/NA_ie2L_uhVHJ8fMpkcKoyGHqWOm1NfMmM_ZeH25jpASHGAPJ6G2o9Gj9xwRsru6hfG8xBN5dN0GgP3FM7XOEw86RzPyU0bdsd-U7rJAGTLBIWMTemnwRQxQGT23XBHJPDvSzaCsOGHm_RxJ780x_U0 

In the form view, we may customize the Language name, locale code, ISO code, URL code, and direction. From here, we can activate or deactivate a language. For numbers, we can choose the format of the separator, the decimal separator, and the thousands separator. The legends mentioned at the bottom of the form with examples can be used to customize the different date and time formats. The time and date can be set up in a variety of ways. The first day of the week also has a field that needs to be set.


 https://lh5.googleusercontent.com/TW-IKC88Q65I7EzhdVn5ZrtfYTqilRUtLiE8z9G0w5kpWTioPtuT_0qE-2JQ3kRWY_yLORL4Ceu-whTR3rKK3y793v6-WxnH-41VTNJZBDouJx2YgTVfYV63-V5v5iUgmTTkYDZMWURRU_c5ytkeZsU 



Export translation
With the translate=True attribute set on Char, Html, and Text fields in Odoo, we may add translations in the current languages.
 https://lh3.googleusercontent.com/fyh0CoS43d3nmWihJ08J_9Ps1e7d01Kj6qNeq8-I5W_kezMl79VTn03YR4syC_dz8cl8L_W4G0rGDB9qqsVavidL29G4QfMDQUgoUZLA53rUbWdC5TwQYp7uEMwKUJdV8tboTY206lh55VgNo7AxEsk 



The export translations wizard is displayed by selecting Translations->Export Translations in the Settings app. The language and export file format is both selectable (CSV File, PO File, or TGZ archive). The apps for which we must export the translations can be specified. The translations in all apps will be exported if no apps are chosen. To create the export file, click "Export."


 https://lh3.googleusercontent.com/NqP4gi-VoBYu3Bf9LezkfrT8ICIoE2a6nQLN7KVYQKUuaz1FdJ1xP8gcjwru7YhtIiovE05BBWuv_Z4pdV_9r_xdY6y8akM7nRklPspY9cSX9Ol7c2qM-LnbvXdUjtoKTTQY0IM32DKInk6b-RZYluU 



With the export file, another wizard will open. To download it, click the file's name or the download button.
 https://lh4.googleusercontent.com/2UlW771bfA2ZKBpHUhbuO3By-wzfEhZX1P8-uw5IH6iHb0q-U0Ok1Tex83T4CGw0nyKvWNwOdMexyUrJWxfCwDEtn_dppbP3crH_-DVOCDIoaHZuVD7kCq4iNvHbVyVFcL5t1b607NSgVopAJ5VM5P0 



Gettext Tools
The GNU gettext tools help produce, use, and update the translation files. To expedite translations, Odoo employs the gettext-like method "underscore" (). We can use it to designate string literals in the code that need to be translated with the language that is appropriate for the situation. To use it in the Python code, we must import it from the Odoo packages.


 https://lh3.googleusercontent.com/U5SJo5kI0qErLKm-orvs32xOplXk3JBgFkamTbL7Qka-VKpReKs_FxsKIMYrvuZ4PfgAnrJPH8g0HQ9J5AP4Mds2cyDKHATuC2ax7t5j5qLmftWipJfZ6Eg1ROStEQ4WMaTmD7aykWk3ZWvHML6Xark 



The string literals can be written within _() after we import it because doing so will include them in the translation file.
 https://lh5.googleusercontent.com/Dyko30oP7E_itcZ9-hjMXXKBYKJB7RlxOcdUacvDVZ8lZv-PzIAE_yoFYUyN08JkN4tw8FG2h1aZdFS6hfZkK8T3pIY22T7Bx75wWmNhPb1hl6KAxlEuwHZMDZ65JKWexUOZrSMUvlkAlt7uCixojGY 



Export the translation file (PO file) for the relevant module for that language now.
 https://lh6.googleusercontent.com/izxCMjvhRDTaATbIsdekFtUtuuphVQvEOKMDZJP5xDkiV3FC4dE-3ic8FJuFjBtNQkaWvpKuYBigUCKwqmvi-Nvc-bmgCb9mitMxle41Tr2PtNZcr7VAK3dwNMW88-1bEFPHu2qNkNOcsk-qiYNDM_k 



We can see that the PO file contains the string literal that needs to be translated. The msgid will contain the untranslated string. The translated string for the relevant language can be added to msgstr.


 https://lh4.googleusercontent.com/keAqnuu0lhrsNvasEWqLALJsCFRiLpCGWoyKvM6g1kloqwPlyMmN5g6hsgeGH2DrDWrJQ2fVaf4F1GRYP7VFIcVVCMM8znugGRXWR47jCWEt-ZLWKcV8wfqh3yhcAGvKB2TrevPg5V7KiH05INT8fbM 

Once the translations have been added or updated, there are two ways to add them to Odoo. To add or change translations in Odoo.


 https://lh5.googleusercontent.com/BbYAm4B9rdF2tD3ya8yPQBItkLjyg9rP0ELn5RWsCXDv-VRrOUmqTg1SaDPhJWG6099hxfcOIHOmz7ZWiaCWFMhnYJGjhCw_vBq3KmFVp_vzdtPHWtpR0yNJVJY-aqB8eQ34VmfmK2oGklfCS3LzzAg 



Create a new directory called "i18n" inside the module and place our translation files there if we need to update the translations automatically with the module. This is quite helpful when we release apps or modules that support several languages. The ISO code for the language in Odoo will be used as the filename for the translation files (for example, fr CA.po). The directory also contains the Odoo translation template, which is added with the filename serving as the module name (for example, point of sale.pot).
 https://lh5.googleusercontent.com/-ukM9knGbvLhcIDoBkNm72ttG4OsZXCCZzbZknysqy52gAbLG9KZ0AY7SW0h44Iq8xv3-bLYACs6GrcNBuI27Q6-TDPXDU15um_R_Kt4Df55y3ZtVh7b5dmAWn2wx_c9mkwfa8b-WSFAdxFtSoPQRjs 



When the languages are activated, Odoo will automatically load the translations that were added with the modules.
Import Translation
To import the translations, go to Translations->Import Translations in the Settings app, which opens the wizard for import translations. The language name, language code, and translation file that will be imported can all be selected (supported formats are .csv, .po, and .pot). The checkbox lets us decide whether to override already-translated phrases. Click the "Import" button in Odoo to import the translations.
                                 
 https://lh3.googleusercontent.com/3hj917s9s6QCfbUOxo2PJJZqCZoSyPQpAtOyEWXPm5-OaMzK8fx7MWgZ4iiAiZiCCYD-oo9hiiG0KLz-qPBfeta0QgaBZM8bC-7A6a4eq7pC_WYoJ2n3d_sbMpuwfnnsaRETYhXh_dJc5J2F7q_Cw3A 




Custom language URL code for website
We can configure the URL code in the languages (Translations->Languages in the Settings app). The ISO code or the result of adding the language code and the country code will typically be used.
 https://lh3.googleusercontent.com/T3PoGF4bzhaMXaG32g3WVpXfq5uW7Tz5TxKEz3toeCjiTGeWKfPjeu-HIqq8TyIsJAo1oZoJEDXni5jxtKjMUB4mciAmsfyGrBgpwQ9BGgb2Jc4NUAlMpymqETSKaCgf8eO4sCn4GpejpnttKjYtvYM 

From the Website Settings, we can add the languages that are supported by the websites. Go to Settings in the Website app's Configurations section. In the Language part of the Website section, we can choose the languages that are supported as well as the default language for the website. Only active languages can be added.
 https://lh3.googleusercontent.com/oo_f4bkJSoUnLtnMhQCzXtBGu8zJ_mZVrRwY-WwAmkVUStRCG8czX5e6PzzUNCh6NM89hnaN4nm0grn0Fgi9ZO_Qicfq-N3un8J63UCvmzKRQkUlHiJRBM4wD8lxuG8JfRIYUK63fKEuVKMLynf66x8 

The default language will be loaded on the website. We have several alternatives for changing the website's language.
 https://lh3.googleusercontent.com/k8MZ9U9NV_bhLy6Kthvl0O8gXnzIYlHI_gkIpIOMnoaqwhIIYzK_8GJYdzoZdjPb-s_TbC-9jdJezHJffXGHEdla5Ug41uNLSlhIKN1n3GyUSwlfLOpNEi5PG1PLe-cVbU7hH-jlQFkLtDdkbkv1bvw 

Using the language's URL code, we can switch the language on the webpage. Just after the base URL, we may add the URL code, which will cause the page to load in the chosen language.
 https://lh5.googleusercontent.com/_zPf4KlDQba5d69nudBMe0BZq67cb58CCr3EhmIXqBfILl91Ke649RbLVOMS_M2TWO5TwdXjFXFW9Opk253sH7NiLTxO6F5U0po94HfOZyk6FxXtRXMeWYSns8eRK_fr4d1Uk50sMemmIcqUEqH07vA 

This way, we can use Odoo in any language the user wants.
09. Web Development
Controllers


In Odoo, web controllers are a class that can be used to connect the front end with the backend models. If we need to render some data from the backend model to the website, we can use the Controllers in such scenarios
For creating a web controller, initially, we need to create a directory called “Controllers” with __init__.py and a python file inside our custom module.
 
For Instance, let’s create a controller that fetches data from res. partner model and pass to a web page.
from odoo import http, _
from odoo.http import request


class ResPartnerController(http.Controller):

        @http.route('/contacts', type='http', auth='public', website=True)
        def contact_details(self, **kwargs):
           partner_data = request.env['res.partner'].sudo().search([])
           values = {
               'partners': partner_data,

           }
           return request.render("library_management.contact_details_template", values)


	The Controllers in Odoo are actually inherited from the “Controller” class, as you can see from the above code. The ‘ ‘@http.route()’ defined in the controller specifies some details like the url of the page that need to be redirected, the type of the request (can be http or json), auth for specifying who can access the url, website parameter for specifying the controller is linked with a page (it will take either True or False values).
Lastly,  in the controller function definition, using request.render(), we can specify the template that needs to be rendered when redirecting to the specified URL.
Then, we can create the XML file for creating the template specified in the controller.
<odoo>
        <record id="contact_menu" model="website.menu">
           <field name="name">Contacts</field> <!-- Name of the menu-->
           <field name="url">/contacts</field>
           <field name="parent_id" ref="website.main_menu"/>
        </record>

        <template id="contact_details_template" name="Contact Details">
           <t t-call="website.layout">
               <div class="oe_structure">
                   <div class="container">
                       <br/>
                       <center>
                           <h3>Contact Details</h3>
                       </center>
                       <br/>
                       <table class="table-striped table">
                           <thead style="font-size: 23px;">
                               <tr>
                                   <h6>
                                       <b>
                                           <th>Name</th>
                                           <th>Mobile</th>
                                           <th>Email</th>
                                           <th>Job Position</th>

                                       </b>
                                   </h6>
                               </tr>
                           </thead>
                           <tbody>
                               <t t-foreach="partners" t-as="partner">
                                   <tr>
                                       <td>
                                           <span t-esc="partner.name"/>
                                       </td>
                                       <td>
                                           <span t-esc="partner.mobile"/>
                                       </td>
                                       <td>
                                           <span t-esc="partner.email"/>
                                       </td>
                                       <td>
                                           <span t-esc="partner.function"/>
                                       </td>

                                   </tr>
                               </t>
                           </tbody>
                       </table>
                   </div>
               </div>
           </t>
        </template>
</odoo>
	This is how we can create a new controller in Odoo 16. 
In Odoo, it's also possible to inherit an already existing controller. 
For Instance, if we need to override the controller “CustomerPortal” defined by the “portal” module, 
First need to import the controller class like below,
from odoo.addons.portal.controllers.portal import CustomerPortal
	

Here the “portal” is the controller file where the “CustomerPortal” Controller class is defined. After importing the controller, we can override the function like below,


class CustomerPortalPasswordPolicy(CustomerPortal):
        def _prepare_portal_layout_values(self):
           d = super()._prepare_portal_layout_values()
           d['password_minimum_length'] = request.env['ir.config_parameter'].sudo().get_param('auth_password_policy.minlength')
           return d
	

    This is how we can create and override a controller in Odoo 16
Http route
        ‘@http.route’ is a decorator which allows navigating to the URL specified in it. 
@http.route('/contacts', type='http', auth='public', website=True)
	

Inside http.route(), we can define some parameters like;
1. /url: In this keyword, we need to specify the url that needs to be redirected.
   * In the above example, ‘/contacts’ is the url
2. type: The type keyword defines which kind of operation needs to be performed. type can have two values; ‘http’ or ‘json’.
   * type=’http’ will return to the template, and it will take the dictionary with that.
   * type=’json’ will call from json rpc from javascript.
3. auth: auth describes who can access the specified URL. It can have values like;
   * auth=’public’: anyone can access the url, no restrictions.
   * auth=’user’:  the logged-in user has only permission to access the url.
   * auth=’none’: it is always active and mainly used by the authentication modules.
4.  website: this keyword describes whether this controller links to a web page or not. It can be True or False.


Serving static resources


        A web page can have different types of static resources like images, videos, etc. Let’s look at how we can manage static resources in our custom modules. For this purpose, let us check how we can display an image on the web page. For that, follow the below listed steps;
1. Add your desired image in your custom module, inside the static directory. For example; /library_management/static/src/img/odoo16.png
2. Then define a controller.
@http.route(['/library'], type='http', auth="user", website=True)
def library_books(self):
           partners =request.env['res.partner'].sudo().search([])
           image_url = '/library_management/static/src/img/odoo16.png'
           values = {}
           values.update({'partners': partners, 'image_url': image_url})
           return   request.render("library_management.online_appointment_form", values)
	

In the above code, in place of image_url, you can add the url of your image.


   3.   Finally, from the template, you can fetch the image_url, and can be added like this;
        
<div class="form-group col-12 s_website_form">
                 <img t-att-src="image_url"/>
         </div>
	

In this example, an image is displayed on the page. It’s also possible to display the image by directly from /library_management/static/src/img/odoo16.png
In Odoo, all the files that we will add inside the static directory are considered as static resources. In the above example, our image is placed inside the /static/src/img directory. Like wise, we can place different types of static resources inside the static directory.
For instance; the CSS files can be added inside the /static/src/css directory,
Javascript files in /static/src/js directory etc. 
Custom widgets


In Odoo, there are various field widgets that help to provide certain functionality to our fields. For example, we can use widget=” date” for date fields, widget=” image” for binary fields to display an image, and so on.
Let’s see how we can create a custom widget with our desired functionalities in Odoo 16.
Let’s take an example of creating a widget called “one2many_delete”  which will help to delete multiple one2many lines from the view.
To create our custom widget, we can perform the steps listed below.
1. First, we need to add a static/src/js/widget.js file inside our 
module.
odoo.define('one2many_mass_select_delete.form_widgets', function (require) {
   "use strict";

   var core = require('web.core');
   var utils = require('web.utils');
   var fieldRegistry = require('web.field_registry');
   var ListRenderer = require('web.ListRenderer');
   var rpc = require('web.rpc');
   var FieldOne2Many = require('web.relational_fields').FieldOne2Many;
   var _t = core._t;
	

   2. For selecting multiple one2many lines, we need to add a selector/ checkbox in each                                                          line, and also for creating the widget for one2many fields, we have to extend the r                                     elational field class.
        
'assets': {
           'web.assets_backend': [
               'one2many_mass_select_delete/static/src/js/widget.js',
           ],
           'web.assets_qweb': [
               'one2many_mass_select_delete/static/src/xml/widget_view.xml',
           ],
        },
	


3.Then load the js file inside the assets in the manifest as shown below.


'assets': {
           'web.assets_backend': [
               'one2many_mass_select_delete/static/src/js/widget.js',
           ],
           'web.assets_qweb': [
               'one2many_mass_select_delete/static/src/xml/widget_view.xml',
           ],
        },
	


4.Now we need to add the template inside static/src/Xml. 


        
<?xml version="1.0" encoding="UTF-8"?>
<templates id="template" xml:space="preserve">
   <t t-name="One2manyDelete">
           <div>
                   <button t-if="!widget.get('effective_readonly')" style="margin-bottom: 1%;display:none;"
                       class="button_delete_order_lines"
                       href="javascript:void(0)">
                                   <span class="fa fa-trash"/>
                           </button>
               <button t-if="!widget.get('effective_readonly')" style="margin-bottom: 1%;display:none;"
                       class="button_select_order_lines"
                       href="javascript:void(0)">
                                   <span class="fa fa-check"/>
                           </button>
               <t t-if="widget.get('effective_readonly')">
                           <span class="oe_form_char_content"></span>
                   </t>
           </div>
        </t>
</templates>
	


5.Finally, we need to add this “one2many_delete” widget to the field. 
        
<xpath expr="//field[@name='order_line']" position="attributes">
                   <attribute name="widget">one2many_delete</attribute>
               </xpath>


	

Qweb templates


A client-side template engine is also available in Odoo. This template engine is known as Qweb Templates that is carried out completely in javascript code and rendered withinside the browser.
Perform the following steps to render a qweb template from the client-side;
Below is an example of rendering a qweb template for dashboard creation;

1. Import ‘web.core’ and extract the qweb reference to a variable as below;


var core = require('web.core');
var QWeb = core.qweb;
	

2. Below is a JS function defined for rendering a template;
render_dashboards: function() {
               var self = this;
               if (this.login_employee){
                   var templates = []
                   if( self.is_manager == true){
                       templates = ['LoginUser', 'Managercrm', 'Admincrm'];
                   }
                   else{
                       templates = ['LoginUser','Managercrm'];
                   }
                   _.each(templates, function(template) {
                       self.$('.o_hr_dashboard').append(QWeb.render(template, {widget: self}));
                   });
               }
               else{
                   self.$('.o_hr_dashboard').append(QWeb.render('EmployeeWarning', {widget: self}));
               }
           },
	

3. Add the template file in static/src/xml/file_name.xml


<t t-name="LoginUser">
  <section class="dashboard_main_section" id="main_section_login">
     <div class="row">
        <div class="col-sm-12 mb-4">
           <div class="row">
              <div class="col-12 col-sm-12 col-md-8">
                <h2 class="section-header">CRM Dashboard</h2>
              </div>
              <div class="col-12 col-sm-12 col-md-4">
                 <form class="form-group">
                    <select id="income_expense_values" class="form-control">
                       <option id="this_year" value="this_year">This Year</option>
                        <option id="this_quarter" value="this_quarter">This            Quarter</option>
                        <option id="this_month" value="this_month" selected="">This Month</option>
                        <option id="this_week" value="this_week">This  Week</option>
                    </select>
                 </form>
              </div>
           </div>
          <hr/>
     </div>
   </div>
 </section>
</t>
	


4. Then add the Qweb file to the manifest. In Odoo 16, we can add the qweb file also inside  'web.assets_backend' instead of adding in ‘web.assets_qweb’


'assets': {
           'web.assets_backend': [
               'crm_dashboard/static/src/css/dashboard.css',
               'crm_dashboard/static/src/css/style.scss',
               'crm_dashboard/static/src/css/material-gauge.css',
               'crm_dashboard/static/src/js/dashboard_view.js',
               'crm_dashboard/static/src/js/custom.js',
               'crm_dashboard/static/src/js/lib/highcharts.js',
               'crm_dashboard/static/src/js/lib/Chart.bundle.js',
               'crm_dashboard/static/src/js/lib/funnel.js',
               'crm_dashboard/static/src/js/lib/d3.min.js',
               'crm_dashboard/static/src/js/lib/material-gauge.js',
               'crm_dashboard/static/src/js/lib/columnHeatmap.min.js',
               'crm_dashboard/static/src/js/lib/columnHeatmap.js',
               'crm_dashboard/static/src/xml/dashboard_view.xml',

           ],
        },
	        
RPC calls


In Odoo, If we want to trigger a python function, it can be done with the help of  _rpc calls.
        
        
this._rpc({
               model: this.model,
               method: 'quick_publish_products',
               args: [this.res_id],
           }).then(function (result) {
               self.do_action(result);
           });


	

In the example above, we made an RPC call and called the quick_publish_products method defined in the current model.
After calling a method, ._rpc returns the method's data.
New view creation


In Odoo, there are different types of views, and each view provides different purposes and functionality.
Let’s look at how we can create a new view type in Odoo 16.
Here, we are going to create a new view type called the “hello  world” view.
Let's follow the below steps to create a “hello world” view;


1. Add Hello World view in ir.ui.view model


class View(models.Model):

        _inherit = "ir.ui.view"

        type = fields.Selection(selection_add=[('hello_world', "Hello World")])
	

2. .Add Hello World in view_mode selection by inheriting  ir.actions.act_window.view          model.


class ActWindowView(models.Model):
        _inherit = 'ir.actions.act_window.view'

        view_mode = fields.Selection(selection_add=[('hello_world', "Hello World")], ondelete={'hello_world': 'cascade'})
	

3.  When adding a new view type, we need to define a js module and need to         import the required variables as shown below;
odoo.define('custom_view_app.HelloWorldView', function (require) {
"use strict";

        var AbstractController = require("web.AbstractController");
        var AbstractModel = require("web.AbstractModel");
        var AbstractRenderer = require("web.AbstractRenderer");
        var AbstractView = require("web.AbstractView");
        var ViewRegistry = require("web.view_registry");

        var HelloWorldController = AbstractController.extend({});
        var HelloWorldRenderer = AbstractRenderer.extend({});
        var HelloWorldModel = AbstractModel.extend({});


	

4. Then we follow the Model-view-controller pattern.


var HelloWorldView = AbstractView.extend({
           config: _.extend({}, AbstractView.prototype.config, {
               Model: HelloWorldModel,
               Controller: HelloWorldController,
               Renderer: HelloWorldRenderer,
           }),
           viewType: "hello_world",
        }
	

5. Now register the view like below.


ViewRegistry.add("hello_world", HelloWorldView);

        return HelloWorldView;
	 
6. Then on the Renderer function, we can add things that we need to view.
For example, we can add a heading “Hello World” like below.
var HelloWorldRenderer = AbstractRenderer.extend({
className: "o_hello_world_view",
this.$el.append(
                       $('<h1>').text('Hello World!'),
                       $('<div id="mapid"/>')
           );
           return $.when();
        },
});
	Mobile app javascript


From Odoo Version 10 onwards, a mobile app is introduced to access all the Odoo apps , even the custom modules also.
 https://lh5.googleusercontent.com/lBy9TY40MMpF9XDCwy4ryUffpSEPt_qPZjCeP-BnfmQd_vbd_vycxaifOnNImSiXT_2iO5bKmMNOuIh5EGtB80k0P9eBUZYXRzy612isCXKgakz9k6Wl8owMKcaZxsJy2D2rTxpw7D4mZN6eASwwT9g 



web_mobile.rpc establishes the connection between your mobile device and Odoo Javascript. Mobile RPC provides a list of utilities. In the image above, we use the Vibrate method to constantly vibrate for a specified amount of time.
Mobile Utilities Example;


1. mobile.methods.showToast({'message': 'Message sent'});
In the example above, we used the showToast method to display a toast in our mobile app.
  2.mobile.methods.showSnackBar({'message': 'Message is deleted',      'btn_text': 'Undo'})
Snackbars display short messages at the bottom of your mobile screen.
  3.mobile.showNotification({'title': 'Simple Notification',  'message': 'This is a test for a simple notification'})


The ShowNotification method can be used to display notifications on the mobile app.
   4.var contact = {
        'name': 'Michel Fletcher',
        'mobile': '9999999999',
        'phone': '7954856587',
        'fax': '765898745',
        'email': 'michel.fletcher@agrolait.example.com',
        'website': 'http://www.agrolait.com',
        'street': '69 rue de Namur',
        'street2': false,
        'country_id': [21, 'Belgium'],
        'state_id': false,
        'city': 'Wavre',
        'zip': '1300',
        'parent_id': [8, 'Agrolait'],
        'function': 'Analyst',
        'image': '<<BASE 64 Image Data>>'
}
mobile.methods.addContact(contact);
 addContact can be used to create a new contact on mobile.
    5. mobile.methods.scanBarcode()
         scanBarcode method can be used to scan QR codes.
   6. mobile.methods.switchAccount();
        switchAccount method can be used to switch from one account to another on the            device.






10. Website Development
Static Assets
Managing static assets in Odoo is more complicated. As you know, it has extensive applications and a code base. Odoo's different apps have specific purposes and different user interactions. So Odoo's assets are not as simple as other applications. For example,  web clients, websites, POS, or mobile apps have different requirements. Additionally, some elements can be large but are rarely necessary. In this case, you should lazy load (if necessary). Loading large unneeded static assets is unhealthy and may need to be loaded as needed. To avoid this example in Odoo, let's use different asset batches for each codebase.
Managing Static Assets


Modern websites contain a large number of JavaScript and CSS files. These static files send requests to the server when the page is uploaded to the browser. A large number of requests slows down the website. Many websites combine multiple files to serve static assets to avoid this problem. There are many tools for managing these types of items, but Odoo has its way of managing static assets.


Asset types
 
In Odoo, There are three different types of assets that are script (JavaScript files), style (CSS or SCSS files), and templates (XML files).
1. Script (JavaScript files)
Odoo supports three types of JavaScript files, each bundled and served to the browser. The different types of JavaScript files supported by Odoo are plain JavaScript files, native JavaScript modules, and Odoo modules. During this simple JavaScript, the file is only reserved for external libraries and is also used for certain forms of low-level purposes. All newly created JavaScript files must be built within the native JavaScript module system. Odoo modules are a custom module system for these JavaScript files, processed and minified when not in asset debug mode, and finally concatenated together. Finally, the result is saved as an attachment. These attachments are typically loaded into static files using the <script> tag.
2. Style (CSS or SCSS files)
Styling can be done in CSS or SCSS files. Style files are minified and merged after being treated like JavaScript files. (debug mode unless debug=asset mode). SCSS files are converted to CSS. The file is then saved as an attachment and loaded with the <link> tag.
3. Templates (XML files)
A template is a static XML file. They are called to be read-only as soon as they are needed and are eventually concatenated in small amounts, much like JavaScript and Elegance files. Every time the browser loads her Odoo, it calls /web/WebClient/qweb/controller to get the template.   QWeb is the first template engine used by Odoo. This is an XML templating engine, primarily used for pushing HTML fragments and pages. Template directives are defined as t-prefixed XML attributes. Conditional t-ifs that render components and other attributes directly.


Note that in most cases, browsers only make requests when the page is first loaded. This is because each of these assets is linked to a checklist included in the page's source. Then add a checksum to the URL. This allows you to safely set cache headers over time.  



Bundles 
Odoo assets are grouped by bundles, where each bundle can be a list of different file paths for specific asset types such as XML, JS, CSS, and SCSS. Bundles are listed in the Odoo module's manifest file. These files use a global syntax, so one line declares the various files containing the assets. Adding a bundle to your module's __manifest__ file keeps important assets private, including dictionaries. The most important things in the various dictionaries are the names and values ​​of the secret bundles and the list of files they contain. It will be as follows.


'assets': {
  'web.assets_common': [
      'web/static/lib/bootstrap/**/*',
      'web/static/src/js/boot.js',
      'web/static/ src/js/webclient.js',
  ],
  'web.assets_backend': [
      'web/static/src/xml/**/*',
  ],
  'web.assets_frontend': [
      'web/ static/src/scss/style.scss',
      'web/static/src/js/custom.js',
  ],
  'web.assets_qweb': [
      'web/static/src/xml/templates.xml',
  ],
  'web.qunit_suite_tests': [
      'web/static/src/js/webclient_tests.js',
  ],
  'web.qunit_mobile_suite_tests': [
      'web/static/tests/mock_tests.js',
  ],
},
	 
1. web.assets_common:
This bundle contains the most common assets for web clients, websites, and POS. It should contain the sub-building blocks of the Odoo framework. Note that we have included a boot.js file that defines the Odoo module system. 
2. web.assets_backend:
This bundle contains specific code for the web client (specifically his web client/action manager/view).
3. web.assets_frontend:
This bundle contains specific code for the public website (specifically for eCommerce, portal, forum, blog, etc.).
4. web.assets_qweb:
All static XML templates are used in the backend environment and POS. 
5. web.qunit_suite_tests:
All JavaScript unit test code (tests, helpers, mocks).
6. web.qunit_mobile_suite_tests: 
 Mobile-specific unit test code.
Operations
Typically, Handling assets is simple: you just need to add some new files to a frequently used bundle like assers_common or assets_backend. But there are other operations available to cover some more specific use cases.
Note that all directives targeting a certain asset file (i.e., before, after, replace and remove) need that file to be declared beforehand, either in manifests higher up in the hierarchy or in ir.asset records with a lower sequence.


1. append   
The append operation is used to append one or more files to the end of a bundle. This is the most commonly used operation and allows you to prepend a filename. 
'web.assets_common': [
'my_addon/static/src/js/**/*',
],
	

2. prepend
The prepend operation is used to prepend one or more files to a bundle. This is useful for adding certain files before other files in the bundle.
'web.assets_common': [
('prepend', 'my_addon/static/src/css/bootstrap_overridden.scss'),
],
	

3. before   
The Before operation is used to add one or more files before a specific file. Creating the file at the beginning of the bundle may not be accurate. Can be used to prepend the specified file to the target file.   
'web.assets_common': [
('before', 'web/static/src/css/bootstrap_overridden.scss', 'my_addon/static/src/css/bootstrap_overridden.scss'),
],
	

4. after   
After adding one or more files after a specific file. Same as before, but added after the target file.  
'web.assets_common': [
('after', 'web/static/src/css/list_view.scss', 'my_addon/static/src/css/list_view.scss'),
],
	

5. include 
Use nested bundles. Include directives may be due to using bundles within other bundles to reduce manifest size.   
'web.assets_common': [
('include', 'web._primary_variables'),
],  
	

	6. remove   
Sometimes you may want to remove one or more files from a bundle. This can be done with a delete operation.   
'web.assets_common': [
(remove, 'web/static/src/js/boot.js'),
],
	



7. replace   
If you want to remove an asset, but add a new version of that asset in the same position. This can be done with the replacement directive.
'web.assets_common': [
('replace', 'web/static/src/js/boot.js', 'my_addon/static/src/js/boot.js'),
],
	Dynamic Routes


Odoo uses controllers to configure frontend modules. These frontend modules are integrated into backend modules. For example, if you want to display sales order details on your website, you cannot use Odoo's model functionality. However, using the controller, you can get the sales order details from the backend. The controller extends its functionality with modules such as website sales, website blogs, website forums, etc. Controllers make it easy to define links between arbitrary URLs and websites.   When developing a website, it is necessary to create pages with dynamic URLs. For example, 
In a website store, each product has its own detailed view of the product that links to different URLs.
Consider having a "shop" module and adding a product page for each product.


How do I create a dynamic route?


To create a dynamic route, follow these three steps.


1. Create a new controller.


@http.route('/store/', type='http', auth="user", website=True)
def product_details(self, product):
   Welte = {
         'product': product,
   }
   return request.render('store.product_details', value)
	

2. Create a new template for the detail page.


<template id="product_details" name="Product Detail">
   <t t-call="website.layout">
       <div class="container">
           <div class="oe_structure"/>
           <div class="row">
               <div class="col-12">
                   <div class="col-6">
                       <span t-field="product.image"
                             t-options="{'widget': 'image'}"/>
                   </div> <div class="col-6">
                       <div class="prod_details">
                           <h1 t-field="product.name"/>
                           <span class="prod_price"
                                 t-field="product.lst_price"
                                 t-options="{'widget': 'price'}"/>
                           <ul class="prod_desc_list">
                               <li><t t-esc="product.brand"/></li>
                               <li><t t-esc="product.category"/></li>
                               <li><t t-esc="product.origin"/></li>
                               <li><t t-esc="product.code"/></li> </ul>
                           <span t-field="product.description"/>
                           <div class="prod_buttons">
                               <button class="btn btn-primary"
                                       t-options="{'widget': 'button'}"/>
                           </div>
                       </div>
                   </div>
               </div>
           </div>
       </div>
   </t>
</template>
	

3. Add a link or button to an existing view to redirect the details page.


<a t-attf-href="/store/#{product.id}" class="btn btn-primary">
   Goto Product <i class="fa fa-eye"/>
</a>
	Snippets  
Odoo provides easy-to-use and effective website management tools that allow users to create and customize websites. Users can simply drag and drop these snippets to use. Odoo's website editor comes with several editing building blocks that you can drag and drop onto your page and edit to your liking. Learn how to create your own building blocks. Odoo has many types of snippets, but generally, it can be divided into two types: static snippets and dynamic snippets. The static snippet is fixed and will not change until the user changes it. Dynamic snippets based on datasets are stored in the Odoo backend.  
How do I create a Static snippet?   
A snippet is a QWeb added to the Insert Pad bar. Create a snippet that displays the image and title of your item. You can drag and drop snippets onto your page and edit images and text. A static snippet is just a block of HTML code.
You just need to follow two basic steps to create a static snippet.
1. Create a template view for the snippet.
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
<template id="snippet_product_cover" name="Product Cover">
   <section class="pt-3 pb-3">
       <div class="container">
           <div class="row align-items-center">
               <div class="col-lg-6 pt16 pb16">
                   <h1>Odoo static snippet</h1>
                   <p>
                      Hi welcome to odoo static snippet
                    </p>
                   <a class="btn btn-primary" href="#" >snippet Details</a>
               </div>
               <div class="col-lg-6 pt16 pb16">
                   <img
                     src="/module_name/static/src/img/cover.jpeg"
                     class="mx-auto img-thumbnail w-50 img img-fluid shadow"/>
               </div>
           </div>
       </div>
   </section>
</template>
</odoo>
	

2. Register the snippet as static
<template id="bproduct_snippets_options" inherit_id="website.snippets">
   <xpath expr="//div[@id='snippet_structure']/div[hasclass('o_panel_body')]" position="inside">
       <t t-snippet="module_name.snippet_product_cover"
        t-thumbnail="/module_name/static/src/img/s_product_thumb.png"/>
   </xpath>
</template>
	

How do I create a Dynamic snippet?   
A dynamic snippet is a snippet whose content changes when the backend or data source changes. To create a dynamic snippet, you need to create an XML file to define the view, a Python controller to fetch data from the Odoo backend, and a Javascript file to display the content from the backend on your website. To create a new dynamic snippet that displays a list of products, consider the following steps:
Controller:
First, let's create a controller that fetches data from the backend. In this example, let's find the total amount sold.
from odoo import http
from odoo.http import request
class Sales(http.Controller):
   @http.route(['/total_product_sold'], type="json", auth="public")
  def sold_total(self):
      sale_obj = request.env['sale.order'].sudo().search([
          ('state', 'in', ['done', 'sale']),
      ])
      total_sold = sum(sale_obj.mapped('order_line.product_uom_qty'))
      return total_sold
	

XML:
First, we need to define the content of the snippet as in the static snippet.
<template id="basic_snippet" name="Dynamic Snippet">
   <section class="container dynamic_snippet_blog">
       <div class="row">
           <div class="col-md-12">
               <h1>Dynamic Snippet</h1>
               Total Products Sold: <span id="total_sold"/>
           </div>
       </div>
   </section>
</template>
	

Here we created a span with id total_sold to show the total number of products sold.The value will be fetched in Javascript and will be rendered here. After defining the view, we need to add this to the website builder snippet blocks. To do that, we need to inherit the website.snippets and add our snippet inside that as in the static snippet.
<template id="external_snippets" inherit_id="website.snippets" priority="8">
   <xpath expr="//div[@id='snippet_effect']//t[@t-snippet][last()]" position="after">
       <t t-snippet="basic_snippet_blog.basic_snippet"/>
   </xpath>
</template>
	

This time we are adding the snippet inside Dynamic section.JS:
For getting the data from the server and viewing it on the website, we will use JavaScript.
odoo.define('basic_snippet_blog.dynamic', function (require) {
  var PublicWidget = require('web.public.widget');
  var rpc = require('web.rpc');
  var Dynamic = PublicWidget.Widget.extend({
      selector: '.dynamic_snippet_blog',
      start: function () {
          var self = this;
          rpc.query({
              route: '/total_product_sold',
              params: {},
          }).then(function (result) {
              self.$('#total_sold').text(result);
          });
      },
  });
  PublicWidget.registry.dynamic_snippet_blog = Dynamic;
  return Dynamic;
});
	

Here we are  giving the class of the section as selector, and we are fetching the value from the controller using RPC. Now we need to add the XML file to the data section and the js file in the assets section of the manifest.py file.
"data": [
  'views/view.xml',
],
'assets': {
  'web.assets_frontend': [
      '/basic_snippet_blog/static/src/js/dynamic.js',
  ],
},
	After installing or updating the module, go to the website and click on the edit button. Now we can see the snippet under Dynamic Content.


Input from website users


Website development tutorials often require you to create forms that receive input from website users, called visitors. Use the Survey_form module to indicate user input for your site. We need to create a new model to store the records added by the website visitors.
Here's how to create a model and corresponding fields in the Survey.Form model.


class SurveyForm(models.Model):
   _name = 'survey.form'
   name = fields.Char('Title', required=True)
   email = fields.Char('Email', required=True)
   phone = fields.Char('Phone', required=True)
   dob = fields.Date('Release Date')
   qualification = fields.Char('Qualification')
	

Add a view for the survey_form module as follows:


<record id="survey_form_tree" model="ir.ui.view">
   <field name="name">survey.form.view.tree</field>
   <field name="model">survey.form</field>
   <field name="arch" type="xml">
       <tree create="false">
           <field name="name"/>
           <field name="email"/>
           <field name="phone"/>
           <field name="dob"/>
           <field name="qualification"/>
       </tree>
   </field>
</record>
	

Add right access for the survey.module model in the ir.model.access.csv file


Added a new model called Survey Form for demo purposes. Next, add a new HTML form template for entering data from your website.










To create a new root and template for the survey form page, perform the following steps.


Step 1: Create a new route in your controller file (main.py).


class SurveyFormController(http.Controller):
    @http.route(['/survey_form'], type='http', auth="user", website=True)
   def survey_form_view(self, **post):
       name = post.get('name')
       email = post.get('email')
       phone = post.get('phone')
       if name and email and phone:
           request.env['survey.form'].sudo().create({
               'name': name,
               'email': email,
               'phone': phone,
               'dob': post.get('dob'),
               'qualification': post.get('qualification')
           })
           return request.redirect('/survey_form?submitted=1')
       return request.render('survey_form.survey_form_template',
                             {'submitted': post.get('submitted', False)})
	

We created a route that submits a survey form. The function's **post argument accepts any query parameter in the URL. It also retrieves the form data submitted with the **post argument. The demo used the same controller to display a page and submit a vote. When it finds data in **post, it creates a new issue in the survey.form model and redirects the user to the survey page with the submitted query parameters.
Site Visitor does not have permission to create new survey form records, so sudo() was used to create a survey form record. This is the case when a user submits a survey from her web page, and we need to create a survey form record. This is a practical example using sudo().


Step 2: Create a new Template


<template id="survey_form_template" name="Survey Form">
   <t t-call="website.layout">
       <div class="container s_website_form">
           <h3>Survey Form</h3>
           <t t-if="submitted">
               <h3 class="alert alert-success mt16 mb16">
                   <i class="fa fa-thumbs-up"/>
                   Survey submitted successfully
               </h3>
               <a href="/survey_form">Submit another survey</a>
           </t>
           <t t-else="">
               <div class="row">
                   <div class="col-6">
                       <form id="form_survey_form"
                             action="/survey_form" method="POST">
                           <input type="hidden" name="csrf_token"
                                t-att-value="request.csrf_token()"/>
                           <div class="s_website_form_rows row s_col_no_bgcolor">
                               <div class="form-group col-12">
                                   <label for="name">Name</label>
                                   <input type="text" class="form-control"
                                          name="name" placeholder="Enter your name"
                                          required="required"/>
                               </div>
                               <div class="form-group col-12">
                                   <label for="email">Email</label>
                                   <input type="email" class="form-control"
                                          name="email" placeholder="Enter your mail-id"
                                          required="required"/>
                               </div>
                               <div class="form-group col-12">
                                   <label for="phone">Phone</label>
                                   <input type="number" class="form-control"
                                          name="phone" placeholder="Enter your name"
                                          required="required"/>
                               </div>
                               <div class="form-group col-12">
                                   <label for="dob">DOB</label>
                                   <input type="date" class="form-control"
                                          name="dob" placeholder="dd/mm/yyyy"/>
                               </div>
                               <div class="form-group col-12">
                                   <label for="qualification">Qualification</label>
                                   <select class="form-control" name="qualification">
                                       <option value="">Select</option>
                                       <option value="pg">Post Graduation</option>
                                       <option value="ug">Graduation</option>
                                       <option value="higher_secondary">Higher Secondary</option>
                                       <option value="secondary">Secondary</option>
                                   </select>
                               </div>
                               <div class="form-group col-12">
                                   <input type="submit" class="btn btn-primary"
                                          value="Submit"/>
                               </div>
                           </div>
                       </form>
                   </div>
               </div>
           </t>
       </div>
   </t>
</template>
	

Now we created a template for a survey form web page. Adds a conditional partition that displays a success message when the form is submitted. The website uses all fields to get input from the user. However, csrf_token is used to prevent cross-site request forgery (CSRF) attacks. The user cannot submit the form unless it is used in the form. After submitting the form, the submitted data is received as the **post parameter of survey_form_view(). Update the module and open the URL /survey_form. This page allows you to submit a survey. After submission, you can view them in the corresponding Survey_form tree view in the backend.


If you want to disable csrf verification, you may be able to use csrf=False in your root.
@http.route('/url', type='http',auth="user", website=True, csrf=False)
	

You can restrict requests by including method parameters in the route like this:
@http.route('/url, type='http', method='POST' auth="user", website=True)
	

Managing Sitemaps for the Odoo Website


A sitemap is important for any website. It is a file that contains information about the website's pages and other files on the website. Search engines use sitemaps to index the pages of your website.
This blog describes how to modify an existing sitemap for the Odoo website.
We can use the sitemap_xml_index method for changing the already existing sitemap. Ie, 
@http.route('/sitemap.xml', type='http', auth="public", website=True, multilang=False, sitemap=False)
def sitemap_xml_index(self, **kwargs):
  current_website = request.website
  Attachment = request.env['ir.attachment'].sudo()
  View = request.env['ir.ui.view'].sudo()
  mimetype = 'application/xml;charset=utf-8'
  content = None

  def create_sitemap(url, content):
      return Attachment.create({
          'raw': content.encode(),
          'mimetype': mimetype,
          'type': 'binary',
          'name': url,
          'url': url,
      })
  dom = [('url', '=', '/sitemap-%d.xml' % current_website.id), ('type', '=', 'binary')]
  sitemap = Attachment.search(dom, limit=1)
  if sitemap:
      # Check if stored version is still valid
      create_date = fields.Datetime.from_string(sitemap.create_date)
      delta = datetime.datetime.now() - create_date
      if delta < SITEMAP_CACHE_TIME:
          content = base64.b64decode(sitemap.datas)

  if not content:
      # Remove all sitemaps in ir.attachments as we're going to regenerated them
      dom = [('type', '=', 'binary'), '|', ('url', '=like', '/sitemap-%d-%%.xml' % current_website.id),
             ('url', '=', '/sitemap-%d.xml' % current_website.id)]
      sitemaps = Attachment.search(dom)
      sitemaps.unlink()

      pages = 0
      locs = request.website.with_user(request.website.user_id)._enumerate_pages()
      while True:
          values = {
              'locs': islice(locs, 0, LOC_PER_SITEMAP),
              'url_root': request.httprequest.url_root[:-1],
          }
          urls = View._render_template('website.sitemap_locs', values)
          if urls.strip():
              content = View._render_template('website.sitemap_xml', {'content': urls})
              pages += 1
              last_sitemap = create_sitemap('/sitemap-%d-%d.xml' % (current_website.id, pages), content)
          else:
              break

      if not pages:
          return request.not_found()
      elif pages == 1:
          # rename the -id-page.xml => -id.xml
          last_sitemap.write({
              'url': "/sitemap-%d.xml" % current_website.id,
              'name': "/sitemap-%d.xml" % current_website.id,
          })
      else:
          # TODO: in master/saas-15, move current_website_id in template directly
          pages_with_website = ["%d-%d" % (current_website.id, p) for p in range(1, pages + 1)]

          # Sitemaps must be split in several smaller files with a sitemap index
          content = View._render_template('website.sitemap_index_xml', {
              'pages': pages_with_website,
              'url_root': request.httprequest.url_root,
          })
          create_sitemap('/sitemap-%d.xml' % current_website.id, content)

  return request.make_response(content, [('Content-Type', mimetype)])
	This native function is defined within the website module controller. This function is called each time a sitemap file is generated.
locs = request.website.with_user(request.website.user_id)._enumerate_pages()


This code will generate the site URL for the sitemap. Here it is defined using the _enumerate_pages function in the sample website.


def _enumerate_pages(self, query_string=None, force=False):
  """ Available pages in the website/CMS. This is mostly used for links generation and can be overridden by modules setting up new HTML controllers for dynamic pages (e.g. blog).By default, returns template views marked as pages. :param str query_string: a (user-provided) string, fetches pagesmatching the string:returns: a list of mappings with two keys: ``name`` is the displayable
name of the resource (page), ``url`` is the absolute URL
of the same. :rtype: list({name: str, url: str})
  """
  router = self.env['ir.http'].routing_map()
  url_set = set()

  sitemap_endpoint_done = set()

  for rule in router.iter_rules():
      if 'sitemap' in rule.endpoint.routing and rule.endpoint.routing['sitemap'] is not True:
          if rule.endpoint in sitemap_endpoint_done:
              continue
          sitemap_endpoint_done.add(rule.endpoint)

          func = rule.endpoint.routing['sitemap']
          if func is False:
              continue
          for loc in func(self.env, rule, query_string):
              yield loc
          continue

      if not self.rule_is_enumerable(rule):
          continue

      if 'sitemap' not in rule.endpoint.routing:
          logger.warning('No Sitemap value provided for controller %s (%s)' %
                         (rule.endpoint.method, ','.join(rule.endpoint.routing['routes'])))

      converters = rule._converters or {}
      if query_string and not converters and (query_string not in rule.build({}, append_unknown=False)[1]):
          continue

      values = [{}]
      # converters with a domain are processed after the other ones
      convitems = sorted(
          converters.items(),
          key=lambda x: (hasattr(x[1], 'domain') and (x[1].domain != '[]'), rule._trace.index((True, x[0]))))

      for (i, (name, converter)) in enumerate(convitems):
          if 'website_id' in self.env[converter.model]._fields and (not converter.domain or converter.domain == '[]'):

converter.domain = "[('website_id', 'in', (False, current_website_id))]"

          newval = []
          for val in values:
              query = i == len(convitems) - 1 and query_string
              if query:
                  r = "".join([x[1] for x in rule._trace[1:] if not x[0]])  # remove model converter from route
                  query = sitemap_qs2dom(query, r, self.env[converter.model]._rec_name)
                  if query == FALSE_DOMAIN:
                      continue

              for rec in converter.generate(self.env, args=val, dom=query):
                  newval.append(val.copy())
                  newval[-1].update({name: rec})
          values = newval

      for value in values:
          domain_part, url = rule.build(value, append_unknown=False)
          if not query_string or query_string.lower() in url.lower():
              page = {'loc': url}
              if url in url_set:
                  continue
              url_set.add(url)

              yield page

  # '/' already has a http.route & is in the routing_map so it will already have an entry in the xml
  domain = [('url', '!=', '/')]
  if not force:
      domain += [('website_indexed', '=', True), ('visibility', '=', False)]
      # is_visible
      domain += [
          ('website_published', '=', True), ('visibility', '=', False),
          '|', ('date_publish', '=', False), ('date_publish', '<=', fields.Datetime.now())
      ]

  if query_string:
      domain += [('url', 'like', query_string)]

  pages = self._get_website_pages(domain)

  for page in pages:
      record = {'loc': page['url'], 'id': page['id'], 'name': page['name']}
      if page.view_id and page.view_id.priority != 16:
          record['priority'] = min(round(page.view_id.priority / 32.0, 1), 1)
      if page['write_date']:
          record['lastmod'] = page['write_date'].date()
      yield record
	


You can use this function to switch between pages of your website in your sitemap. This function can be used when you need to add a new page or a new URL to your sitemap. You can use this function.


Adding a Records Page to Your Sitemap


 To add a Records page to your sitemap, you must first import the following method.
Import slug from odoo.addons.http_routing.models.ir_http
Import from odoo.addons.website.models.ir_http sitemap_qs2dom
	

The slug is used to generate user-friendly URLs and created on the basis of sitemap_qs2dom is primarily used to create domains based on routes and query strings.


Next, create a new method in main.py.
class Main(http.Controller):
   def sitemap_records(env, rule, qs):
       records = env[your.model]
       dom = sitemap_qs2dom(qs, '/url', records._rec_name)
       for r in records.search(dom):
           loc = '/url/%s' % slug(r)
           if not qs or qs.lower() in loc:
               yield {'loc': loc}
	

where sitemap_records is a Python generator function. This function is called each time a sitemap is generated. This function generates a domain with sitemap_qs2dom. And then used that generated domain to search for records. The location is then generated by the slug() method. Get a user-friendly URL by using the slug method.


Then you can add the sitemap_records function reference to the record detail root. in short,


@http.route('/url/<model("your.model"):record>', type='http', auth="user", website=True, sitemap=sitemap_records)
   def records_detail(self, record):
	

Here we passed a reference to the sitemap_records() function to the root using the sitemap keyword.


This allows you to add record pages to sitemap.xml. If you don't need to filter records and just want to list all records in the sitemap, you can pass True instead of a function reference.


Finally, update the module with your changes. The sitemap is updated every 12 hours. So if you want to see the changes, go to attachments and delete the existing sitemap.xml. Open /sitemap.xml in a browser to see the changes.
Visitor information


Visitor information is information about people who visit our website. The information is stored in the backend of the website. Go to Website -> Reporting -> Visitors.


See a kanban view of all your website visitors and information such as name status, active or inactive, number of visits, and more.


 https://lh3.googleusercontent.com/-LddKnNrNrzqsdqWR_N1sxnJTEJ7bFIjLMkw7VwdqqQncYqFRla8wuVaXntbOeCenEB3gXjl9iXZVz0BIkM28idVZbZ7c5n1FeI_8T4WZ1rc1SLgbalMMg7Y5MhYY1WRUda1qHOhRXfbG0uDT_Haphk 



The icons on the top right allow you to change the view to a list view or graphical view as needed. Odoo's optional filtering and grouping allow you to categorize and organize your website visitors.


Storing your visitor's contact information in our system allows us to contact you via SMS and email.


Click on one of these records to open the record's form view.
 https://lh5.googleusercontent.com/DHZ5NhzAWJC8KFPfucV7hW4turVHFmknIGG8eH6HXWgqthFH6rIjYQLLuSB_PNmwjnx40x1Fnmrj2S5pffy4dXpNx5PTb89pnFNU46d01og8sLVtUPRpQq5tyGiEHT_2flmW0jWjpJbRbiFFxIN5JpU 



In it, you can see visitor information and visits. Basic visitor information such as affiliate partner, email, language, and mobile phone can be found in the visitor information form. In the "Visit" group you can see information about visits to the website.Date of first connection, last connection, pages visited, products visited, etc.


You can also get information about visited pages, how often pages are visited, and product views to determine if each person is currently connected.
Marketing campaign
In business, the word marketing is very relevant. Marketing is the process of getting our business to  people. There are multiple methods of marketing. We may advertise on social media or provide SMS, emails, etc. Odoo mainly has three types of marketing, namely.   
1. Email Marketing  
2. SMS Marketing  
3. Social Marketing  
We also have marketing automation options. This marketing automation allows you to create marketing campaigns. Marketing automation makes it easy to create compelling marketing programs and templates.   
You can also access a list of previously generated campaigns from the Marketing Automation Dashboard. You can also check the status of the campaign on this page. Campaign names, the total number of campaigns, active campaigns, completed campaigns, and the number of campaign participants can all be found in the marketing automation dashboard.


 https://lh6.googleusercontent.com/4LyO6cwFhyXyCMgVlTz40wVdJDFIT6QcQQUJGaPdjYLljJM-Ya6Hc5NftSdnv57hdCEQeyKhWLlVN7ku17TqEVPCk_UhUI4hlAYeWjrcN_zvsC7SMZJqL9pRX6ZyQXj3QUjUup9ZdxReW34REmclOyM 













You can create a new campaign by clicking the Create button.


 https://lh6.googleusercontent.com/UgDzso5BRsdlsclsw_Gqi2NxC1Vg5PGI8pAXMyYtWfg6akaje7T70jIYfu44uejClGmsQ7XW9m8gE5s1_s1ch7ME_LQJ-xxUioHK3uxEJYsiE40RhEtwoKD3do1YUImAv9Tt-TKPMTM2sq2dKt-QO9g 

Name: Name of the created campaign.
Target: Adds a target model for the campaign.
Add New Activity: Click this option to create multiple activities.
 https://lh3.googleusercontent.com/bsYaDOuf2x7-3u6dCq9PBS2aoFEWW2ob8KCXfPXO6jhXnoxkKhNncgL3erGoDMuMD1SfsVvCw4OKJALK_aummCrXwmNWHYY32HUrnZdPi3ZynXBTuuvZ5d-7z2w3VYvmbwJYvcChuSwSRR7V7NRxyW8 



Name: Here, you can add a name for your activity.
Activity Type: Determines the action type. Action type can be either email or SMS.
Email Template: The activity was created using the template used for the activity.
Email templates can be customized. Go to the email template selection box and click the link button to configure the activity email template. A popup will appear with the option to create a new template. Here are the many building blocks for creating email text. Drag and drop the correct building blocks to complete the puzzle.


 https://lh6.googleusercontent.com/b8P8A2G8X45YWB2KN6JmcHxiWNy99t7tGC7Xx3MU304Y4-AFW0MsONYq-SUagNAO8V11GKDoxCkq8zvwmTXS5S1jbWkvQw7E3I6S6QODOQMtNP7NvtQFjiIOakOt08HZoKlfVASVo_eevQAF15ro6jI 



There you will find a tab with options. This allows further functionality to be integrated.
 https://lh4.googleusercontent.com/GhVihcjZPYFoiL_sdtkkDr7Ry7jTwZZD-qKyWw7iEXHdgO0jmeR8CNSPt_6aHq7O3FnyTVY2JWRsYQi-ZVbC3vv2o_4Cj5-nTTjqHlfWFhzyS_3O-4zOE7FEpGS6-4Y0symw_mM8UZS9Rl_vvSIGbB4 



Here you will find email options such as attaching files, replying, etc.
Once the process is complete, you can save and close the window to create and schedule activities.
Then click Save & Close or Save & New.
You can get the views shown below.
 https://lh5.googleusercontent.com/yhgkfMepdTPiomYsLqsgqhZQF4SGPGS4LRa_ssBIODXywFXvnvqi2C8zW5zn16QZcanShqa1p_svufz5cJj2HnSd9Uu1JK6efo6MFc2XfrR2Jo-W3UR7a9d7NJX_vQnecMOqtqtH4tl6vepHs_oEFwE 

Click the "Start" button to start the campaign.
Please click the stop button to end the campaign. Selecting a participant will display the list of participants.
Multi Website


The Odoo Websites module allows you to manage multiple websites with a single Odoo instance. After installing the website module, you can create and manage multiple websites by going to Configuration> Settings.


 https://lh5.googleusercontent.com/cJ2N3czR4iq1Xdo4wTFD9Rqv2DOSoiqJ-NV6GYd-o9ZzsUGiNmOu3kKBpDT5P8uMAHmKeGJj0X8h-KPov0QENhFb6VcT_0mVztf0Cc_a7howkNiEGQwW4oeiDDRjwIkUMHmrJt1y3STGWmYiqwGjk0I 



To create a new website, the user must click on this create new website option and complete this form. Once you have created your website, you can use  different themes. In fact, you can use different themes  for each build of your website.


 https://lh4.googleusercontent.com/tI8hOfjCwKLC_sDFHvULKMKkJrIOxrp_jhCnG1U3L5B2kmROpv917X6Y2ndQMiO0zN4Of0WcTvsn-FYvVAKcbZkvpdLkSw56SyRuwcFpmZ_et1dw0viG5-6Gut-Po6fgWumXNNIql8uvUbblKOcAx1s 



Once your website is created, you can use the website builder to create your website. A website builder is a tool for creating and customizing website pages. The website builder also allows users to create menus.


 https://lh6.googleusercontent.com/ADRqBJd83yBeFa6emMCXTzatkKUP3pX5IJ70Nt7Pk-SDafLbMttvPjJEg9FIdwuTj1COj6Mq1XSMQdgoUASIWSvtLDlxqOVYduf1WaMFDK5zylIxixIEo7PdtsMugYwO6dEDfQ9BjHzi6f_zBro72CA 



You can customize the visitor experience for each website. There is also a single item menu. 


 https://lh4.googleusercontent.com/CcPHstIzJAmgUiIlMwL5Y5znFkY3JSXmfSnDpVgKtci4NIC39pqskohzU4MfuPt5y54i2FpghDXZ17ggBPsgIdbAlThWZhdoD31rd7OJGIJXPUoPZ7_SPDJQaHcdVVPKiVPV2mdE__VhXYfVlm-YAs0 



Each option specified here is site-specific. Also, these options vary depending on the page from which you access the menu option. The user can easily configure the setting options from here.


 https://lh3.googleusercontent.com/TMaIOKgzNgNO46MH59GSrhoumORB0NeZAwfq4nXJ4HCf6rLiC16WwR3PMpAMozO7RkqFRw8jxkOED3Sd2piOGKPq-_Gb2vzSHCfaGtIQX7G3RHUfBQshpDoGwFTJ_rY1vW6MpBxw88oTHPGGGsC8GFI 



Users can switch between websites using the dropdown menu.


 https://lh5.googleusercontent.com/CiPGTdXeWmKXlDgpGxJIIkUuqa1WFO5injlJemMQn2GmFXDUNcpYt5dqU_9y5apLyduxDatLSNbGu78tFwz1xF01wYmgWJiFdmnRQiayQt6XCYNgSWjt8v6XRUPGZ7I_M0Y0TYJ2TMAcEf20pNBtnQM 



In the case of technical aspects of Odoo's multiple websites. There are a few things to consider when viewing several objects in a multisite environment.  
1. It is important to add the domain to the root based on the website. This helps publish only the records available in each site's sitemap. 
2. You must call the can_access_from_current_website() method to check the access properties. This way, the visitor only sees  the current record of her website. 
3.  Include the website's domain when searching for records.
Redirect Old URL


You need to migrate from your current system or website to the Odoo website. Replace the old URL with the new URL. All SEO ranks improve with URL redirects. In it, we will tell you how to switch to the new one. This recipe also shows how to redirect the old URL to the new URL. 
To use redirects, go to Websites> Configuration> Redirects. A tree view of redirects appears. Simply click the Create button to create a new record.


 https://lh4.googleusercontent.com/JJodmWES727Zn5wQ1pEQQ17o-NcPY-6y1HYD7zmjHSBGoWccIPmCeaihlPL1Mf7SmN1TD3IpwnVtfV8U0YL7UBhXj-3j82DnKuOjuC7PazFV4vOZZYCDTLg9JwXLrRo9GDmjwTXpzTbCB5ME2CT9NO8 



1. Name: Name of the site rewritten 
2. Action: Actions to be performed in this rewrite. 
   1. 302 Temporarily Moved: An HTTP status code of 302 means the page the user is trying to access has changed. Temporarily moved to another location. The server redirects the user to the new destination with a 302 "Found " or " Moved Temporarily" redirect, but the original location is still used for requests. 
   2. 404 Not Found: The 404 error is an HTTP status number that indicates that the page you are trying to access on a website does not exist on the server. 
   3. 301 Moved Permanently: The HyperText Transfer Protocol (HTTP) 301 Transferred Permanently redirect status response code indicates that the requested resource was definitely moved to the URL specified in her Location header. Search engines update links to resources after the browser redirects to the updated URL. 
   4. 308 Redirect / Rewrite: The 308 Permanent Redirect redirect status code indicates that the requested resource was permanently redirected to the URL specified in her Location header. The browser will be redirected to this page, and the search engine will update the link to the resource ("link juice" in SEO terms will be transferred to the new URL). 
1. Url from: old URL
2. Url​​​ to: new URL 
3. Website: The website field is used when using the Multiple Websites feature and restricting the redirect rule to only one website. However, by default, the rule applies to all websites. Active: Can be used to occasionally activate / deactivate the rule.
Manage website record
A website record is a record that contains everything on a website. Everything created or checked on the website's front end is stored on the website's back end. You can see all the  details of your website  stored in the backend. You can see how to create a form for your website  and how to store this value in the backend.
Creates a menu used to store the selected product in the back end. To do this, you need to follow three basic steps


1.First, we need to create a menu called Repair Order.


<record id="menu_contactus" model="website.menu">
  <field name="name">My Product</field>
  <field name="url">/my_product</field>
  <field name="page_id" ref="website.contactus_page"/>
  <field name="parent_id" ref="website.main_menu"/>
  <field name="sequence" type="int">60</field>
</record>
	







2.Then create a template that helps display the data when the menu is clicked.


<template id="my_product_temp" name="My Product">
  <t t-call="website.layout">
      <div id="wrap">
          <div class="oe_structure">
              <div class="container">
                  <form role="form" action="/create/my_product" method="POST">
                      <input type="hidden" name="csrf_token" t-att-value="request.csrf_token()"/>
                      <div class="form-group">
                          <label for="product_id" class="control-label"> Product </label>
                          <select name="product_id" class="form-control link-style">
                              <t t-foreach="product_rec" t-as="product">
                                  <option t-esc="product.name" t-att-value="product.id"/>
                              </t>
                          </select>
                      </div>
                      <div class="clearfix oe_login_buttons">
                          <button type="submit" class="btn btn-primary pull-left">Submit</button>
                      </div>
                  </form>
              </div>
          </div>
      </div>
  </t>
</template>
	







3.Create a controller to specify the actions


class Request(http.Controller):        
@http.route(['/my_product'], type='http', auth="public", website=True)
        def my_product(self, **kw):
           product_rec = request.env['product.product'].sudo().search([])
                       return request.render("website_demo.my_product_temp", {
               'product_rec': product_rec
               })
        @http.route(['/create/myproduct'], type='http', auth="public", website=True)
        def create_my_product(self, **kw):
           request.env['own.product'].sudo().create(kw)
           return request.render("website_demo.submit_thank", {})

	

11. Odoo Web Library (OWL)
OWL COMPONENT


OWL is the custom component framework used by the Odoo javascript framework. It’s a UI framework based on components considered to be the basis for the Odoo Web Client. It is written in typescript with the best ideas of Vue and react.
The Components are classes in Javascript that have properties and functionalities. Each component has a template, and components are capable of rendering themselves. Next, we'll build a straightforward OWL component and integrate it into Odoo's online client. 


At first, we have to define a javascript module:
/** @odoo-module **/
	

Then add the js file to the assets in manifest.


'assets': {
  'web.assets_backend': [
      '/owl_test/static/src/js/owl_test.js',
  ],
},
	

Then we define OWL utility.


const { Component, whenReady, xml, mount, useState } = owl;
	









Then we have to add the owl component and its template.


class App extends Component {
static template = xml`
  <div class="bg-info text-center p-2">
     <span>Hello Owl</span>
  </div>`;
}
	

Then initialize the component and add it to the web client:


whenReady().then(() => {
  mount(App, document.body);
});
	

Then the component will be added as shown below.


 https://lh5.googleusercontent.com/WxOTdFq_sVRNo_7SAYtk9XjRyuK4QNRyx0xlb3gp6NB_pJ_cKav4O8nPUgzYuil-OYYvFUO2agsZskKVa6Sin-MrkWNneK8ylFmTslRMQGfRGJRvEA_KAgTyUX7w7Mv2wEor2QwMsz45Ta4EjEXfEcc 



A helper called XML (xml helper) is used in the example above to construct inline XML templates. We can directly define XML codes by utilizing this helper. It is not the best method for producing inline XML templates when taking into account a huge project. We can load the XML template similar way to loading the Qweb template. 
User Actions


When components of a user interface are said to be interactive, it means they must react to different user actions like clicks, hovers, and form submissions, among others. The component will have a click event added in the example below. Create a button and assign a click to it in the component. 
The component template is defined as follows:


static template = xml`
  <div class="bg-info text-center p-2">
     <span>Hello Owl</span>
      <button t-on-click="() => state.value++">
          Click Me! [<t t-esc="state.value"/>]
      </button>
  </div>`;
	

Here, we have mentioned in the template that to increment the value when clicking on the button.
class Counter extends Component {
  static template = xml`
      <div class="bg-info text-center p-2">
         <span>Hello Owl</span>
          <button t-on-click="() => state.value++">
              Click Me! [<t t-esc="state.value"/>]
          </button>
      </div>`;
  state = useState({ value: 0})
}
	

The Output will be like this:


 https://lh5.googleusercontent.com/ZUDxLKkelbcYENEYeOg58McgxOExRfprSevdvpsxgRPCaKCQ9LzJb835jvGL6KNIwekLEowzklfPafvGVGvooFv9b40bczVT8hHd-fXnvWl_XuaWupBoxGvl9r9-PsYx6pBXTCKHpXZbPnc0ZE1Snzs 



In the previously mentioned example, a component contains a button that has an on-click function added where the value 0 will become 1 when we click the button, and the value will rise by 1 with each subsequent click. The value will be reset to 0 following a page refresh. The component's template was established in the first step, and the button's t-on-click attribute was added.
We can also mention the method name in on-click and define the 
method's name as the attribute's value, which will bind the click event. The increase is the response function in the example mentioned above. The response function is defined inside the component in the second step. The event syntax of the component is as follows:
t-on-<name_of_the_event>="method name in component"
	

Life Cycle
Developers can create interactive and potent components in a variety of ways with the aid of OWL Components. The following are some significant methods for components and their life cycles:- 


1. setup
After the construction of the component, the setup will run. The difference between the constructor and setup is that setup does not accept any argument. The hooks are called inside this method to make it possible to monkey patch.


setup() {
                useSetupAutofocus();
}
	

2. willStart
Before the initial rendering of the component, the willStart hook is called to perform some actions. It is useful in some cases to load external assets before the component rendering.


setup() {
                    onWillStart(async () => {
                              this.data = await this.loadData()
                    });
         }
	



3. willRender
To execute code just before the component is rendered. We can use onWillRender hook.
setup() {
                  onWillRender(() => {
                             // do something
                   });
         }
	

4. Rendered
In some cases, we need to execute the code just after the component is rendered. In such cases, we can use the onRender hook.
setup() {
   onRendered(() => {
     // do something
   });
         }
	

5. mounted
After the initial rendering, each time component is attached to DOM, the mounted is called. Only this hook is called when the component is present in the UI.


setup() {
   onMounted(() => {
     // do something here
   });
 }
	

 6. willUpdateProps
It is an asynchronous hook. This hook is called when an update is made for the related component. This function will be useful if a component has an asynchronous task that needs to be completed. At this time, the function will be registered using this hook.


setup() {
   onWillUpdateProps(nextProps => {
     return this.loadData({id: nextProps.id});
   });
 }
	

7. willPatch
Before the DOM patching starts, willPatch is triggered. We can use it for reading information from the DOM. On the initial render, it is not called, and modifying the state is not allowed. This hook is used to register the function at this moment.


setup() {
   onWillPatch(() => {
     this.scrollState = this.getScrollSTate();
   });
 }
	

8.patched
Patched hook is called when a component updates its DOM. It is not called from the initial render. This method is useful to interact with the DOM whenever the component is patched. At this moment, onPatched hook is used to register.


setup() {
   onPatched(() => {
     this.scrollState = this.getScrollSTate();
   });
 }
	

9. willUnmount
Before the component is unmounted from DOM, the willUnmount method is called.
setup() {
   onMounted(() => {
     // add some listener
   });
   onWillUnmount(() => {
     // remove listener
   });
 }
	

10. willDestroy
When components are inactive, we need to clean some actions where actions are done on setup.


setup() {
   onWillDestroy(() => {
     // do some cleanup
   });
 }
	

Reactive OWL Component
Reactivity's objective is to offer a straightforward method of changing the state in a way that causes the interface to be updated automatically as the state changes. Through the hooks, OWL supports automatic user interface updating. The hooks will automatically update the component's UI when a change is made to the component's internal state. The message in the component will be updated in the example that follows based on the user's actions. 
Making our OWL component reactive by carrying out the subsequent actions, the useState hook import 


const { Component, whenReady, xml, mount, useState } = owl;
	

Then define the component as below:
class Counter extends Component {
   static template = xml`
       <div class="bg-info text-center p-2">
           <i class="fa fa-arrow-left p-1" style="cursor: pointer;" t-on-click="onPrevious"> </i>
           <b t-esc="messageList[Math.abs(state.currentIndex%4)]"/>
           <i class="fa fa-arrow-right p-1" style="cursor: pointer;" t-on-click="onNext"> </i>
           <i class="fa fa-close p-1 float-right" style="cursor: pointer;" t-on-click="onRemove"> </i>
       </div>`
}
	

Then add the constructor () method for constructor
constructor() {
super(...arguments);
this.messageList = [
   'Hello World',
   'Welcome to Odoo',
   'Odoo is awesome',
   'You are awesome too'
];
this.state = useState({ currentIndex: 0 });
}
	

Inside the component, we define the methods for handling click events as shown below:
onNext(ev) {
  this.state.currentIndex++;
}
onPrevious(ev) {
  this.state.currentIndex--;
}
	

Here, we imported the useState hook to handle the state of the component. Then define the template of the component. In the component we have added message with an arrow on both the left and right side of the message. The constructor method is called when the instance of the object is created. Inside the constructor, we have defined list of the message to a variable. Using the useState hook, we have added state variable. Thus our OWL component is reactive. We have added the current index in the state; when a change happens to the state, UI is also updated. The methods onNext() and onPrevious() are used to update the variable. The output will be as shown below:


 https://lh6.googleusercontent.com/mXd1RRGhR9qmHZowssblxRp-DDL5atqu--ah3COgiYbE_00J76Z6fxXH9TB0c9UVlikOjcYwBf0fW0b2wxkUrWkcFMS68dtQNeMVfqj1ee3vOWOPMhMzGK6kAkOQUR6bCRnqNGX5str3iRmOMAQB1v0 



When we click on the arrow, the corresponding method is called and updates the message.


OWL Field
Here, we are going to create a new widget and add it in a form view. Now we are creating a date picker widget in which we can add multiple dates. Now we can go through the steps to create a widget.
Here we are adding a char field in the res.partner model.


from odoo import fields, models
class ResPartner(models.Model):
  _inherit = 'res.partner'
  test_field = fields.Char()
	

Then add the field in the form view.


<field name="test_field" widget="multiple_datepicker"/>
	

Then we define the Qweb template for the field widget


<templates>
  <t t-name="FieldDateMultipleDate" owl="1">
      <input type="text" class="input_datepicker" t-ref="inputdate"
             t-on-click="_onSelectDateField"/>
  </t>
</templates>
	

Then we are going to add the style for the widget.


.datepicker-dropdown {
  top: 0;
  left: 0;
  padding: 4px
}

.datepicker table tr td,
.datepicker table tr th {
  text-align: center;
  width: 30px;
  height: 30px;
  border: none
}

.datepicker table tr td.day:hover,
.datepicker table tr td.focused {
  background: #eee;
  cursor: pointer;
  border-radius: 18px;
}

.datepicker table tr td.active.active,
.datepicker table tr td.active.highlighted.active,
.datepicker table tr td.active.highlighted:active,
.datepicker table tr td.active:active {
  color: #fff;
  background-color: #7C7BAD;
  border-radius:18px;
  border-color: #7C7BAD;
  background-radius:11px;
}

.datepicker table tr td span {
  display: block;
  width: 23%;
  height: 54px;
  line-height: 54px;
  float: left;
  margin: 1%;
  cursor: pointer;
}
.datepicker table tr td span.active,
.datepicker table tr td span.active.disabled,
.datepicker table tr td span.active.disabled:hover,
.datepicker table tr td span.active:hover {
  color: #fff;
  background-color: #7C7BAD;
  border-color: #2e6da4;
  text-shadow: 0 -1px 0 rgba(0, 0, 0, .25)
}

.datepicker .datepicker-switch {
  width: 145px;
  background:#7C7BAD;
  color:white;
}

.datepicker .datepicker-switch,
.datepicker .next,
.datepicker .prev,
.datepicker tfoot tr th {
  cursor: pointer;
  background:#7C7BAD;
  color:white;

}
	

	Then define the widget component


/** @odoo-module **/
import { registry } from "@web/core/registry";
import { useInputField } from "@web/views/fields/input_field_hook";
import time from 'web.time';
var translation = require('web.translation');
var _t = translation._t;

const { Component,useRef} = owl;

export class DomainSelectorTextField extends Component {
  static template = 'FieldDateMultipleDate'

  setup(){
      super.setup();
      this.input = useRef('inputdate')
      useInputField({ getValue: () => this.props.value || "", refName: "inputdate" });
  }
  _onSelectDateField(ev){
      var dateFormat = time.getLangDateFormat();
     if (dateFormat.includes('MMMM')){
        var dates = dateFormat.toLowerCase()
        var result = dates.replace(/mmmm/g, 'MM');
        dateFormat = result
    }
    else if (dateFormat.includes('MMM')) {
        var dates = dateFormat.toLowerCase()
        var result = dates.replace(/mmm/g, 'M');
        dateFormat = result
    }
    else if(dateFormat.includes('ddd')){
        var dates =new dateFormat.toLowerCase()
        var result = new dates.replace(/ddd/g, 'DD');

        dateFormat = result
    }
   else{
      dateFormat = dateFormat.toLowerCase()
   }
      if (this.input.el){
         this.props.update(this.input.el.value.replace(DomainSelectorTextField, ''));
          console.log('this',dateFormat)
          $(this.input.el).datepicker({
              multidate: true,
              format: dateFormat,
          }).trigger('focus');
      }
  }
}
registry.category("fields").add("multiple_datepicker", DomainSelectorTextField);
	

Then define these in the manifest file.


'assets': {
  'web.assets_backend': [
      '/owl_test/static/src/scss/style.scss',
      '/owl_test/static/src/js/owl_test.js',
      '/owl_test/static/src/js/lib/bootstrap-datepicker.min.js',
      '/owl_test/static/src/xml/owl_test.xml',
  ],
},
	

Next we can select the multiple dates in the field.


 https://lh6.googleusercontent.com/y1LLikXceARrBSdPgykKkDzWZgIAeTOT9K6DdR-XwpxGl95C9xI2pPJ-c25W2gmGs9rauh8Vre9M21OKssqOfG2vqqh4Kgle2BLFR5NcGWIXxsbHUFJ_cKrVz7r0w_0_OBDH6bDCw9CJ_-nYIa-ak6Y 



Thus we can add multiple dates.






12. Test Cases
Python Testing
Keeping in mind the growth of large-scale applications, including robotics experiments, it is the right way to work on the unwavering quality of modules. This will harden the module. Odoo consistently releases alternative forms of products, and robotized experiments are very helpful in detecting application fallbacks that may have been caused by redesigning customizations. Fortunately, each Odoo structure comes with various mechanized test programs. Odoo comes with three basic types of tests included.


Adding Python Test Cases


Test file structure
 https://lh6.googleusercontent.com/Z8gSatTKMTG4kG6mpRLadk4jC6KJ2_xqE06mzgO4tRpStfa4X9XoJbj5ymhnNkPpYkfkFyUnRAsZ1tjeZCp5hIPUCQ_IS0hUw3Q9dYUaWOwwAniFzvce3kj-IX6UNuny5OWkDOj8SDSw93GAdLFus1s 

Structure of test case:
* In your module, define a test subpackage.
* All test files in the Tests subpackage must start with the string test_.
* All tests should be in tests/__init__.py
* All tests must extend the Odoo test case class.
* All test methods must start with def test_


Here, the tests/__init__.py contains


from . import test_book
	

Extend an Odoo test case class


Odoo provides many utilities and helpers for testing. Odoo mainly contains test case classes. Each of these classes must be extended when writing test cases in Odoo.

* odoo.tests.common.SingleTransactionCase
A test case where all test methods are executed in the same transaction. Transactions are started in the first test method and rolled back at the end of the last test method.


* odoo.tests.common.TransactionCase
This is the most commonly used test case class. A test class where all test methods run in one transaction, but each test method runs in a subtransaction managed by a savepoint. Cursors in a transaction are always closed without committing


* odoo.tests.common.SavepointCase
Transactional HTTP test case with url_open and headless helpers for Chrome.



* odoo.tests.common.HttpCase


Extending one of these classes would result in code like this:


# -*- coding: utf-8 -*-
from odoo.tests import common

class TestBook(common.TransactionCase):
	

All test files must start with test_
E.g., test_book.py
All test methods must start with test_
E.g.,
from odoo.tests import common
class TestBook(common.TransactionCase):
        def test_string_concatenation_and_length(self):
	

Writing A Test- Example
from odoo.tests import common
class TestBook(common.TransactionCase):
        def test_string_concatenation_and_length(self):

        book = self.env['book.book'].create({'name': 'War
         and Peace',
         'author ': 'Leo Tolstoy'})
                    """Book name checking"""
                    self.assertEqual(
                        # Actual results from function call...
                        book.name,
                        # Expected results from the function call...
                        "War and Peace")
                    """Book name length checking"""
                    self.assertEqual(
                        # Actual results from function call...
                        len(book.name),
                        # Expected results from the function call...
                        13)
	

In the example above, I created a test method called test_string_concatenation_and_length() that checks the string concatenation and the length of the concatenated string.


Running Tests
Odoo test cases can be executed in different ways
* Enabling --test-enable when starting the Odoo server. It runs tests after module installation or update.
* Using --test-file <file>, it will runs a python test file
* Using --test-tags [-][tag][/module][:class][.method]


Tagged Python test


Odoo allows you to highlight selections and run test cases. Decorator for tagging Points BaseCase objects. The tags are placed in a set accessible through the "test_tags" property. The tagged() decorator can be used on the test class to add or remove tags when assembling the test. Additionally, the decorator's assertion is that the tag name is a string. Tags are not picked up when using class inheritance. Of course, the tests will run once the comparison module is introduced. Instead of tracking module installations directly, you can also adjust your experiment to track all installed modules.


Some special tags are listed below:
At_install - Testing is done immediately after module setup and before various module rollouts. This is a standard implicit tag.


Post_install - It means that tests will be run after all modules are installed. This is mainly needed for HttpCase tests.


Standard - All Odoo tests that acquire from BaseCase are explicitly flagged by default. --test-tags also defaults to standard. So untagged tests naturally run.


Post_install is usually paired with -at_install when tagging test classes.


Subclasses of odoo.tests.common.BaseCase (usually by TransactionCase, SavepointCase, or HttpCase) are automatically marked standard and at_install by default.

Instead of adding or selecting tags, you can prefix them with a minus sign (-) to remove them. If you don't want your tests to run by default, you can remove the default tag.



# -*- coding: utf-8 -*-
from odoo.tests import TransactionCase, tagged

@tagged('-standard', 'mytest')
class MyTest(TransactionCase):
	


This test is not selected by default. To run, you have to explicitly select the corresponding tag (mytest).


Invocation
You can use --test-tags to select/filter which tests to run on the command line. It means --test-enable, so you don't need to specify --test-enable when using --test-tags.


This option is set to +standard by default. This means that tests tagged as standard (explicit or implicit) are run by default when Odoo is started with --test-enable.


Command to run test cases with test tags:


odoo-bin --test-tags [-][tag][/module][:class][.method]


The ‘-’ indicates to include or exclude tests conforming to this specification. This tag matches tags added to the class using the tagged() decorator.
Example:
* odoo-bin --test-tags /purchase
For testing the module.
                
* odoo-bin --test-tags mytest,standard
For testing specific tag.Configuration switch parameters also accept + and - prefixes. The - (minus) prefix is ​​used to deselect test tags that have a previous tag, regardless of whether they are selected by other specified tags. For example, if you have a standard test that is also marked as mytest, you can run all standard tests except mytest.
        
* odoo-bin --test-tags .test_date_planned
        For testing specific function with a unique name.
This is equivalent to:
odoo-bin --test-tags /purchase:TestPurchase.test_date_planned
* odoo-bin --test-tags '/purchase,-slow'
Run the tests from the purchase module but not the ones tagged as slow:
* odoo-bin --test-tags '-standard, mytest, /student
        Run only the tests from student or tagged as mytest


Head Less Test


Headless browser testing is the course of running program tests without using the program's UI or GUI. Headless program testing allows the analyzer to accurately and effectively perform cross-program testing without requiring a program to test the application. In a continuous integration environment, this testing technique is useful for testing because no one notices visual elements, so continuous testing scales effectively.


This kind of program can approach all pages, and without showing them to the client, this program can move the site's page content to another program. The client screen is blank when the headless program starts because the headless program runs as expected in the backend. The execution of the two programs is dissimilar, but the headless program is able to deconstruct and interpret her web pages. This allows headless programs to convey the perspective of the actual program without allocating memory or performing costly experiments with the actual program GUI.


The purpose of using headless programs and running headless tests is to be faster than regular programs. It doesn't open the GUI of the program, so the time it takes a normal program to stack CSS and JavaScript and render HTML is negligible. Headless tests scale execution 2x to 15x faster. If the presentation is the primary perspective of your test system, a headless program may be the best approach.


List Of Browsers supports Headless Test


Headless Chrome
Odoo uses headless Chrome to run JavaScript test cases and tour test cases. Headless Chrome is a way of running Chrome without a full user interface. With that in mind, you can run your JavaScript test cases in an environment similar to end-client. We will introduce Headless Chrome and different bundles to run JavaScript test cases. 


Chrome versions 59 and higher support headless mode. Brings all the latest highlights of Web Stage to the command line, powered by Chromium and the Blink rendering engine. Headless Chrome allows you to take screenshots, create PDF files of website pages, and edit correspondence with website pages.
Headless Firefox
For Firefox 56 and above, Mozilla Firefox offers headless testing. Developers can now interact with Mozilla's built-in APIs to run Firefox in headless mode and test different test cases rather than emulating a browser environment using several different devices. Headless Firefox utilizes Selenium, SlimmerJS, and W3C WebDriver.
The majority of analyzers utilize Selenium as their preferred API for controlling headless Firefox. However, each analyzer is free to choose its own API and comfort for creating and running crucial unit tests.
PhantomJS
PhantomJS is a headless browser scriptable with a WebKit-based JavaScript API. It can be used for screenshots, page automation, network monitoring, rendering dashboard screenshots to users, running unit tests on the command line, and gathering information from the web. However, PhantomJS maintenance has been discontinued.
Google Puppeteer
The headless browser Puppeteer is a node library. Provides a significant level of API for controlling headless Chrome or Chromium via the DevTools protocol. You can also change to use full (non-headless) Chrome or Chromium.
HTMLUnit
It is a "GUI-less program for Java program." It displays HTML entries and provides an API for building pages, completing structures, and clicking links, just as you would in a "typical" program.
Splinter
Splinter is a headless program powered by Python. It is public and used to test web applications in Python. For example, it can be used to robotize browser actions such as accessing a URL or collaborating with a Thing.
jBrowserDriver
Programmable and embeddable internet browser driver compliant with the Selenium WebDriver specification - Headless, WebKit-based, Java.
Qunit Test


The Odoo framework uses the QUnit library test system as a test splinter. QUnit characterizes the concept of tests and modules (a set of related tests) and provides a web-based interaction point for running tests.
web.test_utils provides the test programs needed to create JavaScript test cases.
Adding Qunit Test Cases
 https://lh3.googleusercontent.com/Ue0aS4-l4hpf1JF0sC36Qgav5C9bLxhV_HBqP722TmvvO8PsWlQPOsNaDioz_RkB8VJictDR8R9JIfsIOAhPKKFJF0lLDrHEKWr3QAcph1avPC4i6NhRCXpoU_pBlsGIrsKhDR8SJlhDbIkPlX-SefQ 

    
While writing tests:
* Define a tests subpackage in your module's static directory.
* Create a js test file in the tests directory.
* After defining the test suite, add test cases.
* Add the file to the main test assets.
* Visit /web/tests/ to make sure the test is executed.
Let's look at an example qunit test for JavaScript code (e.g., helper function myFunction in test_addon.utils). The process to add a new test case is as follows.
First, create our test file inside static/tests/utils_tests.js
odoo.define('student.arithmetic', function (require) {
"use strict";
var pyUtils = require('web.py_utils');
var testUtils = require("web.test_utils");
  QUnit.module(student,{},  function (){
  });
});
	

Define the test case inside the test file.


odoo.define('student.arithmetic', function (require) {
"use strict";
var pyUtils = require('web.py_utils');
var testUtils = require("web.test_utils");
  QUnit.module('student',{},  function (){
          QUnit.test('simpletest', function (assert) {
                  assert.expect(2);
                  var result = pyUtils.py_eval("4 + 2");
                  assert.strictEqual(result, 6, "should properly evaluate sum");
                  result = pyUtils.py_eval("6 * 6");
                  assert.strictEqual(result, 36, "should properly evaluate        multiplication operator");
          });
  });
});
	

Add our tests inside the asset (manifest file
'assets': {
          'web.qunit_suite_tests': [
              'student/static/tests/test_file.js'
          ],
},
	

Running test by visiting /web/tests/.


 https://lh6.googleusercontent.com/QEf4-AHAF_olUzmasQcwcQpnsLhyCwZiCsxQ1ueGHbBTH4d_n2F2imYaitTlU_qf46tkqSLvlEf0yqFbYONXW1Jhd8EIiMvPTLmsqSFvmnSbsSe_W9HQiUdMgfyGvrUcUlhm8yeEv7kWJ8DgNUtT6Q0 



Testing by using Helper Function:


It's very difficult to test some parts of Odoo without help. In particular, views can communicate with the server and perform many RPCs that need to be mocked. For this reason, we have developed some special helper functions in test_utils.js.


Mock test functions: These features help you set up your test environment. The main use case is to mock answers from Odoo servers. These functions use the mock server. This is a JavaScript class that simulates responses to the most common model methods (read, search_read, name_get, etc.).


DOM helpers: Useful for simulating events/actions on specific targets. For example, testUtils.dom.click performs a click on the target. Note that this is safer than doing it manually, as it also checks that the target exists and is visible.
create helpers: These are probably the most important functions exported by test_utils.js. These helpers help you create widgets with simulated environments and lots of details to simulate real-world conditions as much as possible. The most important is indeed the createView.


qunit assertions: QUnit can be reached out with particular assertions. For Odoo, we often test some DOM properties. To this end, we made a few assertions to assist with that. For instance, the containsOnce assertion takes a widget/jQuery/HtmlElement and a selector and afterward checks in the event that the objective contains precisely one counterpart for the CSS selector.


For example, with these helpers, a simple form test might look like this:


QUnit.test('Simple Form Test ', async function (assert) {
  assert.expect(1);
  var form = await testUtils.createView({
          View: FormView,
          model: 'student.student',
          data: this.data,
          arch: '' +
                  '' +
              '',
          res_id: 1,
  });
  var line = form.$('[name="f_name"]').length
  assert.strictEqual(line, 1,
          "The field exist");
  form.destroy();
});

form.destroy();
});
	

Tour Test Cases


Testing Python code and JS code separately is very useful, but it doesn't prove that the web client and server work together. To do this, we can write another type of test: tours. Tours are mini-scenarios of interesting business processes. It describes the sequence of steps to follow. The test runner then creates a PhantomJs browser, points it to the correct URL, and simulates clicks and inputs according to the scenario.


To add a tour test case for a custom module, follow the steps below:


structure:
 https://lh3.googleusercontent.com/GferPDoz7p_RZuClne-QwyVPSkTNBcHyQGUoikcIDMC7E9pGQHiaWf33w5kOuGoYgUT99xPl6vmk1RDd0YSUxoOE-MlEFyK4MZZyvLYejleDDs_unroUHfhIr5a0K9H6gep17QpsQfT73YqV-HYu72A 

1. Set up your tour by registering for it.
import { _t } from 'web.core';
import { Markup } from 'web.utils';
import tour from 'web_tour.tour';

tour.register('student_tour', {
        url: "/web",
        test:true,
        },
);
	        
Below are some possible options that you can define for your tour.


* url: Page to start the tour.
* skip_enabled: To add a skip button to the top.
* wait_for: Wait for the deferred object before running the tour.
* test: If set to true, this tour will only be used for testing purposes.

2. Add a required number of steps to the tour.

[tour.stepUtils.showAppsMenuItem(), {
        trigger: '.o_app[data-menu-xmlid="student.menu_research_management_root"]',
        content: Markup(_t('Want to manage your books? It starts here.')),
        position: 'bottom',
  },
  {
        trigger: '.o_list_button_add',
        content: _t('Let\'s create your first book by clicking on create.'),
        position: 'bottom',
        },
        {
           trigger: '.o_field_widget[name="name"]',
           content: _t('Fill the Book name.'),
           // When you run the test (from the developer tools) it will automatically fill in 'War and peace'.
           run: function (actions) {
                     actions.text('War and peace',this.$anchor.find("input"));
           },
           position: 'right',
           },
  ]
	

Each step of the tour can have several arguments. Possible arguments are:


   *  trigger: selector/element/jQuery you want to trigger
   * extra_trigger: An optional secondary condition for executing the step. It waits like the trigger element, but the action is not executed with additional triggers.
   * run: Action to perform on the trigger element.
   * edition: If you don't specify an edition, the step is active in both community and enterprise.
   * position: Optionally, "Top," "Right," "Bottom," or "Left." Where to place the tooltip relative to the target when running an interactive tour.
   * content: Although optional, the interactive tour tooltip content is also logged to the console, which is very useful for tracking and debugging automated tours.
   * auto:  Whether the tour manager should wait for the user to perform the action if the tour is interactive, defaults to false.
   * in_modal: If set, the trigger element will only be searched in top-level modal windows. The default is false.
   * timeout: Wait time in milliseconds, 10000 (10 seconds) before the step executes.
3. Add tour.js file in a manifest.
'assets': {
           'web.assets_backend': [
              'student/static/src/js/tour.js',
           ],
},
	

4. To start a tour from a Python test, make your class inherit from HTTPCase and call start_tour.


@tagged('post_install', '-at_install','student')
class TestUi(HttpCase):

        def test_01_student_tour(self):
            self.start_tour("/web", 'student_tour', login="admin")
	

5. To run the test case, start the server with the following option;


./odoo-bin -c odoo14.conf -i student - - test - tags=student
	

6. If our test case ran successfully, the following log will be displayed


...INFO test odoo.addons.student.tests.student_tour.TestBook:
console log: Tour student_tour succeeded
	

Client-Side Test Cases


Odoo provides a way to run client-side test cases from the UI. By running the test case from the UI, you can see the behavior of each step of the test case. This way, you can be sure that your UI test cases work as intended.


Both QUnit test cases and Tours test cases can be run from the UI. Python test cases run server-side and cannot be run from the UI. Developer mode must be enabled to see options for running test cases through the user interface.
Running QUnit test cases from the UI


Enable developer mode, click the bug icon, and click the Run JS Tests option.


 https://lh4.googleusercontent.com/n6tiC8RHhPLyFTbrs2ooxAeTSbww5fewoRjgxpHmmfnWJc4FSTykgaAITpsmtDpk5lq_bshsswsVvsTRIfbNhcOeAFu73uBf_8IDx1Ej0XmgXF7XXKrK0IH64OWdaQS7DkIj3h-OjoWlHJWFAtoY7Dg 



This will open the QUnit suite and run the test cases one by one, as shown in the screenshot below. By default, only failed test cases are shown. To see all passed test cases, clear the Hide passed tests check box, as shown in the screenshot below.
 https://lh6.googleusercontent.com/qy3DNvnCEmpvdb_uPDIU2ny3NAtAo509eEUggkg1957GipOWIes6_eOw-e7kRDp0WbWtOu9kc_p_ni9QirY96CJsm5Xy1l8u4Q9SUdS9YgygVH0Ln1bPX2p15LJzY3_LX-P7Sl_BtEdqGdutJ2vO8ug 



Running tours from the UI
Activate developer mode and click on the bug icon and then click on Start Tour:
 https://lh3.googleusercontent.com/fKNRayEEFNkxKTnFQnHM-xj_53LNfmrBFkzs1XYAhrMGONgULowFMyIgV9Q4qpF6uoV7GHKo9dNgoqKJrqNvdiYSnBVLLbJVfZdDsShJTvE05tM2jP3w7K2TJhss2sewo_xcOcSNFOFV7JOWkQlKUSM 



This will open a dialog with a list of registered tours, as shown in the screenshot below. Click the play button on the side to start the tour.


 https://lh4.googleusercontent.com/9fUOLAWwdrR7ji2ZMpMNiqaHO6wNHQPDwH75AUuqqsK2PY7KNer-KAwvqSrv4bOK8dJKWip9kVwfn1zprmX9moK-OgVDxJI7c7K28FecB0gbPjs_CFpXKSujYZGzAdvX9ksJGoP89jHSjdQt1VVYe3k 



Video/Screenshots For Failed Test Cases
Odoo uses headless Chrome. This opens up additional possibilities. Since Odoo 12, it is possible to record failed test cases and take screenshots of failed test cases.


Generating Video/Screenshots
Recording a video for the test case requires the ffmpeg package.
   * Command to install ffmpeg package in python
        apt-get install ffmpeg
	

   * If you want to generate screencasts (videos) of your test cases, use the --screencasts command:
./odoo-bin -c server.conf -i my_module --test-enable
        --screencasts=/home/odoo/odoo_test/
	

   * If you want to take screenshots of your test cases, use the --screenshosts command :
./odoo-bin -c server.conf -i my_module --test-enable
--screenshots=/home/odoo/odoo_test/
	

To create screenshots/screencasts of failed tests, you need to run the server with a path where you store video or image recordings. Every time you run a test and the test fails, Odoo saves a screen capture/video of the failed test case to the specified registry.
To generate test case videos, Odoo uses the ffmpeg package. If this package is not installed on the server, it will only save screenshots of failed test cases. After installing the package, you will see mp4 files of all failed test cases.










13. Odoo .SH
Basic Concepts


Odoo.sh is a cloud-based web hosting platform managed by Odoo SA. Maintenance, backups, email servers, customization options such as third-party applications, server control, built-in development option, device management gear, and many more are just a few of the main features of Odoo.sh.


Create Odoo.sh Account


Log into Odoo.sh website using your GitHub credentials.


 https://lh5.googleusercontent.com/ABa74YiVTmK_SpEhYBtOpSCiE2JELgQDdwPtpi2hEJteKcMNV2WerL39nyzs4tkSDrQIZW8xhkmQJv9UHqiPKJXReUqilS4TH67ZD3sn2J9GOnJG6Tgw6lIft1KyXBegAGP8AaovCUnk8wNh2B_lV2Y 



After logging in to sh, you can deploy your platform like this by filling in the following details.
 https://lh3.googleusercontent.com/4w7DchdKLff6-Dzh2nz47U77Jt9nSTQsR5e63i81fWA_7f9mVQkbjSkPWaqUf-nRgSLTf-gg37TtZlXiITFrPluOMtpOls6amNqBabYL3jC4D4_uTasP-UQmAt9ytLhMag7-b0AbG7w1t-bpd0O_40Y 



1. Add the git repository; you can either create a new repository or add an existing repository.
2. Choose the Odoo version for your project
3. Enter your subscription code
4. Hosting Location - Enter the hosting location
Click the Deploy now button. After this, the GitHub repository that you have provided gets linked to the sh project.
How to Install Custom Modules


Installing a custom module requires a created project on sh, and you know your GitHub repository’s URL. And also a development branch in your project for your GitHub repo. If all this is set, you have to push your custom module into your GitHub repo. Once you push the module, the sh will automatically add a new build and add your custom module into the Odoo instance. After that, connect Odoo from the sh and update the app list and install the module. If your Odoo.sh project is set up to automatically install your module, it will appear among the database applications. Otherwise, it will be accessible for download through the applications. 
You can merge your branch into the production branch once you've tested your module in a staging branch with your production data and feel it's ready. Drag the staging branch over to the production branch. You may also join your branches with the git merge command. This will combine the most recent modifications from your staging branch into the production branch, as well as update your production server.
Manage Branches


There are three possible branches in Odoo.sh. Development, Staging, and Production.


 https://lh4.googleusercontent.com/W_d3FzQmPeSKHsMcaQz1q7Cf9UItusMU31URt-goZw0-QvUaG6lxhWSuOK6kyUkVjcriUeSw0YPQxmHNNFUHawG1_wItn4LyLLeGDcJnC0v9FzkYrM9XxjZuQWmMi9al8NhzgnLCd5i8ZzNYxnUuTFU 



Development


In the Development stage, it provides databases for testing for both developers and end-users. Users can rapidly test the latest advancements in these branches. These data are used in unit tests. Whenever a new commit happens to these development stage branches, it will create a new database. These databases are only valid for three days. Since the purpose of these branches (branches in the Development Stage) are development and testing, it will automatically restrict mail servers and scheduled actions.


Staging
Staging branches are for testing without exposing the production data. This database is a neutralized copy of the production database. The most recent database is kept in staging, while older instances are trash removed to save space. A Staging database can be used to test the newly designed features.


Production


The Production stage contains the Production database. In short, we can say that the changes you make here are final and are for real, which simply means that we have our live database now. A new commit to this branch updates the production server with the new code and restarts the service.
If you fail to restart the service after updating the code in the production branch, the branch reverts to the previous successful commit. Our production database is protected in this way. Since it is the live database, the demo data is not loaded into the production database, and unit testing is not performed because the server may be unavailable to prepare updates.


Merging
You can unite the branches by dragging and dropping one branch into another branch. You may integrate the changes made in development with those made in staging and subsequently with those made in production. Direct merging from development to production is also possible, but it demands guts and audacity. When you do this, the tests in the staging stage are bypassed. Only do this if you are certain that the updates are correct.
Debugging
Odoo.sh provides different features for debugging.
Branch history
Under the History menu of a branch, you can see all the build history of the particular branch. It will display logs, merges, new commits, and database restores.


 https://lh5.googleusercontent.com/vwMr-HdLfOrlunFdyMv0sG8NvXPEJPJg-Tmzxvx-BpFTorfS2ICreFJtBqkK5PpAXJQvEQ2RuBkFLC0BPza4lb-RCTrcpOFegMA-3-CNveuZCeaOVutLJnqJn1W7CzmoDgn7wXRlqXVCpW8TjZTRgXo 



Mail catcher


In the Development and Staging branches, the mail servers are restricted, and they do not send real emails. If you want to test your email system before deploying new features to production, you can use the mail catcher in the Development and Staging branches. It will display all outgoing mails.


In the MAILS tab, you can see a list of all the captured mail with all attachments. The MAILS tab will only be displayed in the staging and development branches.
 https://lh6.googleusercontent.com/ERiXlykr97XQ3tt_gG1SefQ7FUzLi5f9ls-cNyew_kAd5PyvdKo2l4LKsKUc8n-sIfdcaU6IzS2jLZWtVieQ8P2e8JVM0r-53zgX19o8Kjq8MNxgMd-rc1p542NxnQmvLxIx9cFAXpkaJt-qL3IjlM8 



Web shell
From the SHELL tab, you can access the web shell. Here, you can access the source code, the logs, the file store, and so on. It provides all of the shell features with editors such as nano and Vim. With shell access, you can traverse between different directories and perform operations. You can also use the pip command to install Python packages.
Sometimes you need to restart the server or update the module from the shell. You can use the following command in the shell to restart the server:
odoosh-restart
To update the module, execute the given command in the shell:
Odoo-bin -u my_library --stop-after-init
The previous command will update the my_library module. If you want to update multiple modules, you can pass module names separated by a comma.
Backups Instances
The backup server stores an Odoo sh backup of the production databases.
You may also use the import database option to upload databases to the production server.
This is a list of backups stored on the server where your production build is housed. This server only saves backups for one month (7 daily and 4 weekly backups).
Backups from the past are preserved on dedicated backup servers. Backups may be downloaded through /web/database/manager on on-premise Odoo servers.
 https://lh4.googleusercontent.com/R5vLcHmDfYoTTLC6x5B-3W4MaThe8ZvkCswLgCusnlaqEia7QXm6t0fZmzW62_wOTqOhybiaG9Th3nOZx6zzttuCEBf5oCl_SC3OEYMWzUY9-rGdikLskld7kvXLpCn2gh6AiCon3ifEq0VB2a4uZLQ 

You can download a backup using the download button, and also you have a restore button for the restore option. In the download backup option, you have to specify the purpose and filestore option. The filestore makes the dump quite larger. It contains all the files and attachments but is often not necessary.
 https://lh3.googleusercontent.com/GM0FPUZbkddc5qkV29IPpZP6M-qb1vOfOSCFsQO9dsAlN-0tXSjxN_YWXPL7m6IwiGetg4M7FU9skvfUfBGlHGNFhZ_9DUUikhz05uaNXvOyfbhPQ10zLsSOIytGr0PS3mMSSdrSFmbUgo8aC42YOaE 



Builds


Builds help us to test the server behavior. If the new changes don’t have any issues, the build will be successful.


If a build is shown in red, that means the build failed.
If the construction is partially complete, the build will show in yellow. Yellow indicates a warning.
Green indicates the successful build.
You can use the rebuild option if you need to rebuild a certain branch.


 https://lh3.googleusercontent.com/YOci37ZNkqRUDfaLCPsrEqWhybNtpkv-2OU_uTG_AF7GieMj6WPnlQaTBoE2sbIGxCNbs9y5FMm9csM7AlhOv4IjLVk1mEQVdvt9poiGcxM7n5gxnGI2lxWs4vADGE4GfI0qP0c_UdfI0HHL17qQAck 



Rebuild will be triggered with the branch's most recent commit.
The GitHub icon can be used to review the updates you have made.
Connect button can be used to connect to a certain build. You can connect as different users with the Connect As option in the Connect dropdown.
Warnings on a build can be seen by clicking the icon below.


 https://lh3.googleusercontent.com/wlthNNjHAJsqLfI63pHgzA-lHHPKlU9hTgDdRTsh_csA1LXZhwzyyONANEaN5t6Bcehj8__DW-Vgq8QFEwIg3DqUcc0dhc6yin2oeF9fisHom-ayoa8uzR5HAmghXr4oIjiEJ-x9tDs8J41UHOyb_jQ 

With the three dots in the build, you can access some of the other options from your build.
 https://lh6.googleusercontent.com/6AemUTJYBg2Fk_eosOM_D6aCYd6YH_s_MZgEFCPFHFPXQBsbAxxFsuCkjPMb5rU1iRX1FSG3Uwu53ZF9mcZdDPLO2cxC7KW2gRfBmKAvF-9r-V4zmv7p9XGhzoPd9mCqZ24VAtQBbiG_8oeVmPYWnDE 



The build behavior can be customized in the settings of each branch. The branch behavior can be set as, on each commit update the existing database or create a new one.
 https://lh5.googleusercontent.com/8eYMK1Pj3Ki1CsP-Q_juw0yrAZ43fCIMW7qSd18D4pSJ1_oKlT10L2A6BZVCvROOpwnD7H53uqlSXVaNLFcA_JIedowSJZhOGQGroQn-SEoyd7dhuQOlC6s2YVoggWhlhC1aZ_sJSri-BWMgr3kauT0 



History - Displays a date-based history of builds, commits, and test statuses. The database may be accessed via the Connect button if the build is successful.
Mails - The messages are the emails that have been sent. The development and staging branches assist in sending emails for testing reasons, which means they are intercepted, but the production branch sends actual emails.
Shell - Gives you access to the shell, where you can use Linux commands. The terminal may be used to connect to Postgres and perform SQL instructions. The Plus icon in the sidebar may be used to create several terminal instances.
Editor - The Editor is a tool that aids in editing source code. You may also use the editor to create notebooks, access Python 2 and Python 3 consoles,etc.
 https://lh3.googleusercontent.com/AgyfB4jj4nOUK8zuTp_lJJYYmZPxtgRibpRsWmIJJy_qhXDFu-URhxNpAzVBClQwlVa91RyCx-ulKl9nC0t_LoEzhM4fiBjEAtN0MbQA9G7Ve7XCydN8tOLql_GE9yIELCM5wGJNoSuU2PPEhM2x1jw 



The source code for Odoo may be found under /home/odoo/src. To modify the source code, double-click the folder and then go to the file you want to change. After making the necessary changes, save the file using the Ctrl + S shortcut or through the File menu. Save the python script. The changes made to Odoo files are automatically recognized. Therefore the service does not need to be restarted manually. The module requires an update due to the modifications made in view. You may do so by using the command below.
odoo-bin -u module_name --stop-after-init
Or Just Connect to Odoo-->Upgrade the current module
From Odoo —>Server Logs, you may see the server logs.
The log view is provided by the logs. There are a variety of logs to choose from:
   * install.log: This is for the logs that are generated when installing the modules. The logs of all the automated test cases will be located here.
   * pip.log: You can add Python packages with the requirement.txt file. In this log file, you will find the installation log of these Python packages.
   * odoo.log: This is the normal access log of Odoo. You will find the full access log here. You should look in this log to check production errors.
   * update.log: When you upload a new module with a different manifest version, your module gets updated automatically. This file contains the logs of these automatic updates.
Other logs, such as Jupiter-log are also accessible.
To filter content in the log, use the filter option.


 https://lh3.googleusercontent.com/uT2w40t51f0BTsyvGbQMfoVNpLuxqjeV7M2eUV1HNX_AsSSRkTh1_f8aMBebpcGrGTmV2UumV1W4q5rQNng1y2gDgyxRHbqSeXaGQq3EzlnI8tMMHxL4trfrZ_FUWVraftL6olC_P8UCIp2xN-bEEfk 



Other.SH options
Branch Settings


 https://lh3.googleusercontent.com/i6mEmTuNZpSgPrFHJ6pjM7hQHE4KkSyYKFGOQfKZ2jQ56ANIj5GplmEcnqa6Plq4ow319QxYwWuL4TQdVLf92ZghpVByjnHJp9lSf5P6mhLKLOqBJY-uqudf7cYNFslFRjCHjf-ha7Y8iOj3VCJ9_HI 



Behavior upon new commits: It helps to customize the behavior of each build, on build construction. It provides three options - Do nothing, New build, and Update the previous build. The staging branch updates the previous build by default, whereas the development branch makes a new one. When you drag the staging instance to development, the behavior changes to Do Nothing.


Odoo Version - This field specifies the Odoo version. The Odoo versions can be changed for each build, but not for production. Any changes to the source code are automatically updated.


Test Suites - In the development stage, test suites are enabled by default.
Custom Domains - For your instances, you may set up your own domains. *.odoo.com can be used to set up domain names.
Follow the steps below to set up your own domain, such as yourdomain.com:
 https://lh6.googleusercontent.com/x2HUHHFPJojCTw83bh5nUgxhBlBUc127SUYkn-3FNoLz8LQzah_74LtZLifZu5j9VSoME8yO_pRBZ_4_FwF8sbQg-JfCb7vwL-06NaVfcA7PRuJdbwi_ovIusjjdm9ehtd6sBcNqrZCTWz-YJRqlCA8 



Shell Commands - Merge, fork, clone, and more actions may be performed with Git commands.
The Executed button is provided on the right side for commands that may be run automatically without any command adjustments. The operation may be completed with only one click.
However, specific arguments must be included in the git command for activities such as cloning.
The git commands may be copied and edited from a terminal using the copy icon on the left-hand side of the git command.
The build may be accessible through ssh, but you'll need to create a public key in your profile first. You may use the command below to access it once it's been set up.
ssh <build_id> @<domain>
After inputting the public key, the executable command may be simply acquired from the right corner.
 odoo-development-book 

Submodules: Other modules that rely on a different repository than our repository can be used. We have the idea of submodules for this. The dependent modules may be added to our repository branch as a submodule.
 odoo-development-book 

If the repository is private, Git Commands can be used to complete the procedure.
Project Settings
The setting allows you to control some of the most crucial aspects of your project.
Project Name: Your project's name.
Collaborators: Add the people who will be working on your project as collaborators. The collaborators' access can be authorized via this page. We primarily have two privileges: Admin and User.
Admin: Can use all of Odoo's features
User: Access is restricted. Users have no access to the databases for settings, production, or staging.
Allow Public access: Visitors will be able to access development builds after they have been granted access. They have the ability to link to your structures.
Module Installation: The settings are part of the development build. The modules that have been installed will be put to the test.
Full Installation(all modules): You may access the submodules from here. The modules have all been installed.
Install a list of modules: Only chosen modules are installed when the modules to be installed are separated by commas.
Production Database Size: Provides a quick summary of the size of the production database as well as payment details. Your subscription is synced with the growing database size. The production database's storage capacity is displayed here.
Database Workers: Specifies the number of workers in the database. Depending on the number of incoming requests and use, the worker count should be considered. There should be sufficient personnel to handle your incoming requests.
Staging Branches: The number of branches that may be used in staging can be specified here. Your subscription is also synced with the staging branch number.
Activation: The subscription key is displayed under Activation. If necessary, you can modify the subscription code.
 https://lh4.googleusercontent.com/Ritrp6tH2jVKFhJpUwXQTrKdklMUgJ1ar7oiwvYnLOXjduOtpJyFlkyuv-9ySJJoVnwK7FuGsEoxZ--BoMYrEJ8UC0sqMIUsIKDagtZd9yRiIcWyFq6-53FpDqyE9yoWX4lokKrkt55TFIBU5w4DyV8 



14. Remote Procedure Calls (RPC)
XML RPC


It is a specification and a collection of implementations that allow procedure calls to be made over the internet by software running in different environments and on different operating systems.
It's a remote operation that's being asked for. XML is utilized for encoding, while HTTP is used for transport. Though it facilitates the transmission, processing, and return of complex data structures, XML-RPC is designed to be as simple as is practicable. 


Connection to Odoo
In order to access data inside Odoo, we must first connect to it. The xmlrpc/2/common endpoint, one of two types available in Odoo, does not require authentication.
Use this endpoint to get the version of Odoo or to verify the user's identity. The authenticating process returns the user's ID.


API Key
We may generate an API key for a user using Odoo 16.0. For adding a key to the user, enable developer mode. Select the Preferences menu from the user’s My Profile, as depicted below. 
 https://lh6.googleusercontent.com/MSK1yBo_ldPpzYrxHV-a-UUEIIXwDISoDLseT9rxG1FsHEvxSquWm96mhgDGEKsHWWGjBMgolAJmTo_5aYlX0pvRBoN9b7dXrkFgoaavAiZ7_vKo0xWsb3mMC56kZfYMXir-jtipKnqlnXGolxBhMew 



Select the Account Security Tab, and click on the New API key.


 https://lh6.googleusercontent.com/S0dHTJq_Luf-2WlO7g7X4Jz3Dbzw9IwHiepc4XtqByzK6t6QoopXBxVEgSZcSpJbZQk9TKD42vCK23Lzev44JaLDbu3j_J2h4zJRqJIKD4Et70zf6VlTBTmQtKZdUvaze4hEQimH8IAKqXb-kPANXtM 



Give the API key a name and confirm the account's password.


 https://lh4.googleusercontent.com/oGLw0d6jDuzcMtlqkHsZozlvddfy7S0d2T2EaLJoniWr_Zuv7QsFdDBKmmDbjQIp9LBOaGppMoMJQI9aWu6DOqdUfFeB4zCx2LBTkK7Ii_mdW6t91aKZ0dCNPlkMa-nMAUVsphpYs5n9RRBAaU0EF5Q 



You will then receive the API key.


You can utilize the API key to connect to Odoo.


import xmlrpc.client
data_url = 'http://localhost:8016' # odoo instance url
database = 'data' # database name
user = 'admin' # username
password = 'f2494e60974b564df60318c8782f169a5cc16463' # api key
common_auth = xmlrpc.client.ServerProxy('{}/xmlrpc/2/common'.format(data_url))
uid = common_auth.authenticate(database, user, password, {})
	

With the database name, user login, and API key as the password, we can authenticate the user using the xmlrpc/2/common. User ID is a result of the authenticate function. Jot down that user ID (Needed for accessing data from Odoo).


Calling Methods:


The second endpoint, xmlrpc/2/object, is used to access data stored in Odoo or to create new data within Odoo. We can get the data with the use of the xmlrpc/2/execute kw object's method.


data_model = xmlrpc.client.ServerProxy('{}/xmlrpc/2/object'.format(data_url))
	

The user ID created when connecting to Odoo will be used since xmlrpc/2/object requires authentication.


Read/Search Records:


Search:


search_partners_ids = data_model.execute_kw(database, uid, password, 'res.partner', 'search', [[['is_company', '=', True]]])
	

All record IDs in the chosen model are returned by the search function.


Output:


[14, 10, 11, 15, 41, 1, 12, 13, 9]
	

Limit your search to:


partners = data_model.execute_kw(database, uid, password, 'res.partner', 'search', [[['is_company', '=', True]]], {'limit': 1})
	

We are able to decide how many records we want by using the limit option.


Output:


[14]
	



Search with Offset:
partners = data_model.execute_kw(database, uid, password, 'res.partner', 'search', [[['is_company', '=', True]]], {'offset': 1})
	Using the offset argument, we can select the record from which to start our search.
Output:
[10, 11, 15, 41, 1, 12, 13, 9]
	Search Count:
partners = data_model.execute_kw(database, uid, password, 'res.partner', 'search_count', [[['is_company', '=', True]]])
	Search count returns the number of records that meet the requirement.
Read:
Partner_id = data_model.execute_kw(database, uid, password, 'res.partner', 'search', [[['is_company', '=', True]]], {'limit': 1})
	

partners = data_model.execute_kw(database, uid, password, 'res.partner', 'read', [partners_id])
	Each field's values are returned by the read method as a key-value pair. The IDs of the records we wish to get must be provided.
Output:
[{'id': 14, 'message_is_follower': False, 'message_follower_ids': [], 'message_partner_ids': [], 'message_ids': [], 'has_message': False, 'message_unread': False, 'message_unread_counter': 0, 'message_needaction': False, 'message_needaction_counter': 0, 'message_has_error': False, 'message_has_error_counter': 0, 'message_attachment_count': 0, 'message_main_attachment_id': False, 'website_message_ids': [], 'message_has_sms_error': False, 'phone_sanitized': '(870)-931-0505', 'phone_sanitized_blacklisted': False, 'phone_blacklisted': False, 'mobile_blacklisted': False, 'phone_mobile_search': False, 'email_normalized': 'azure.interior24@example.com', 'is_blacklisted': False, 'message_bounce': 0, 'activity_ids': [], 'activity_state': False, 'activity_user_id': False, 'activity_type_id': False, 'activity_type_icon': False, 'activity_date_deadline': False, 'my_activity_date_deadline': False, 'activity_summary': False, 'activity_exception_decoration': False, 'activity_exception_icon': False, 'name': 'Azure Interior', 'display_name': 'Azure Interior', 'date': False, 'title': False, 'parent_id': False, 'parent_name': False, 'child_ids': [26, 33, 27], 'ref': False, 'lang': 'en_US', 'active_lang_count': 1, 'tz': False, 'tz_offset': '+0000', 'user_id': False, 'vat': False, 'same_vat_partner_id': False, 'bank_ids': [], 'website': 'http://www.azure-interior.com', 'comment': False, 'category_id': [5], 'credit_limit': 0.0, 'active': True, 'employee': False, 'function': False, 'type': 'contact', 'street': '4557 De Silva St', 'street2': False, 'zip': '94538', 'city': 'Fremont', 'state_id': [13, 'California (US)'], 'country_id': [233, 'United States'], 'country_code': 'US', 'partner_latitude': 0.0, 'partner_longitude': 0.0, 'email': 'azure.Interior24@example.com', 'email_formatted': '"Azure Interior" ', 'phone': '(870)-931-0505', 'mobile': False, 'is_company': True, 'industry_id': False, 'company_type': 'company', 'company_id': False, 'color': 0, 'user_ids': [], 'partner_share': True, 'contact_address': 'Azure Interior\n4557 De Silva St\n\nFremont CA 94538\nUnited States', 'commercial_partner_id': [14, 'Azure Interior'], 'commercial_company_name': 'Azure Interior', 'company_name': False, 'barcode': False, 'self': [14, 'Azure Interior'], '__last_update': '2022-03-24 07:18:33', 'create_uid': [1, 'OdooBot'], 'create_date': '2022-03-24 07:17:52', 'write_uid': [1, 'OdooBot'], 'write_date': '2022-03-24 07:18:33', 'im_status': 'im_partner', 'channel_ids': [], 'signup_token': False, 'signup_type': False, 'signup_expiration': False, 'signup_valid': False, 'signup_url': False, 'property_product_pricelist': [1, 'Public Pricelist (EUR)'], 'partner_gid': 0, 'additional_info': False, 'property_stock_customer': [5, 'Partner Locations/Customers'], 'property_stock_supplier': [4, 'Partner Locations/Vendors'], 'picking_warn': 'no-message', 'picking_warn_msg': False, 'x_encrypted': False}]
	Read with fields:
partner_id = data_model.execute_kw(database, uid, password, 'res.partner', 'search', [[['is_company', '=', True]]], {'limit': 1})

partners = data_model.execute_kw(database, uid, password, 'res.partner', 'read', [partners_id], {'fields': ['name', 'email']})
	Using the fields option, we can specify which fields we want to fetch.
Output:
[{'id': 14, 'name': 'Azure Interior', 'email': 'azure.Interior24@example.com'}]
	Search Read:
partners = data_model.execute_kw(database, uid, password, 'res.partner', 'search_read', [[['is_company', '=', True]]], {'fields': ['name', 'email'], 'limit': 1})
	Search read is the combination of both search and read
Output:
[{'id': 14, 'name': 'Azure Interior', 'email': 'azure.Interior24@example.com'}]
	Create records:
partner_id = data_model.execute_kw(database, uid, password, 'res.partner', 'create', [{'name': 'Test Partner', 'email': 'test@test.com'}])
	Create method is used for creating a record in Odoo. It returns the id of the created records.
Output:
1
	Update records:
partner_id = data_model.execute_kw(database, uid, password, 'res.partner', 'create', [{'name': 'Test Partner', 'email': 'test@test.com'}])

partner = data_model.execute_kw(database, uid, password, 'res.partner', 'write', [[partner_id], {'name': 'Test Partner Updated'}])
	The write method is used to update the data in an existing record. It returns True if the record is updated.


Output:
True
	Delete Records:
partner_id = data_model.execute_kw(database, uid, password, 'res.partner', 'create', [{'name': 'Test Partner', 'email': 'test@test.com'}])

partner_id = data_model.execute_kw(database, uid, password, 'res.partner', 'unlink', [[partner_id]])
	A record is removed using the unlink method. If the record is erased, it returns true.
Output:
True
	

JSON-RPC


JSON (Javascript Object Notation) is a format for interchange data that is primarily used in applications and APIs. The primary benefit of using JSON is that it is simple to write and parse through the contents. It is simple to read and interpret. To make a remote call to a Python method, we can use RPC (Remote Procedure Call). 


Odoo's json-rpc API method allows users to connect to the Odoo server remotely. It is an RPC that has JSON encoding. It's comparable to XML-RPC but much lighter and doesn't need a response to send data to the server than XML-RPC.


Connection to Odoo


Let's look at how the json-rpc method can be used to connect to Odoo.


import json
import json
import random
import urllib.request
host = 'localhost'
port = 8016
database = 'DemoDB'
user = 'admin'
password = 'admin'


def json_rpc(url, method, params):
  data = {
     "jsonrpc": "2.0",
     "method": method,
     "params": params,
     "id": random.randint(0, 1000000000),
  }
  req = urllib.request.Request(url=url, data=json.dumps(data).encode(), headers={
     "Content-Type":"application/json",
  })
  reply = json.loads(urllib.request.urlopen(req).read().decode('UTF-8'))
  if reply.get("error"):
      raise Exception(reply["error"])
  return reply["result"]


def call(url, service, method, *args):
  return json_rpc(url, "call", {"service": service, "method": method, "args": args})


url = "http://%s:%s/jsonrpc" % (host, port)
uid = call(url, "common", "login", database, user, password)
print(uid)
	

(Py3.6_venv) cybrosys@cybrosys-shamsad:~/json-rpc$ python3 json-test.py
2
	

This will give output as the ID of the user.


url: Specifying the URL of JSON-RPC with host and port number


service: Set the service as common


method: Set the method as login


args: Pass the argument as given below:


        database: name of database
        user: login user id
        password: password of user


This will give output as the ID of the user.


Search/ Read Records


We can use JSON RPC to fetch data and to search/ read out data from the database.


import json
import random
import urllib.request
host = 'localhost'
port = 8016
database = 'DemoDB'
user = 'admin'
password = 'admin'


def json_rpc(url, method, params):
  data = {
     "jsonrpc": "2.0",
     "method": method,
     "params": params,
     "id": random.randint(0, 1000000000),
  }
  req = urllib.request.Request(url=url, data=json.dumps(data).encode(), headers={
     "Content-Type":"application/json",
  })
  reply = json.loads(urllib.request.urlopen(req).read().decode('UTF-8'))
  if reply.get("error"):
      raise Exception(reply["error"])
  return reply["result"]


def call(url, service, method, *args):
  return json_rpc(url, "call", {"service": service, "method": method, "args": args})


url = "http://%s:%s/jsonrpc" % (host, port)
uid = call(url, "common", "login", database, user, password)
task_ids = call(url, "object", "execute", database, uid, password, "project.task", "read", [1])
print("Tasks: ", task_ids)
	

url: Specifying the url of json-rpc with host and port number


service: Set the service as object


method: Set the method as execute


args: Pass the argument as given below:


        database: name of database
        uid: id of user
        password: password of user
        model_name: model name
        method: method as read to call the read method
        ids: list of ids in which data should read 


And the output will be:
 
python3 json-test.py
Tasks:  [{'id': 1, 'rating_ids': [], 'rating_last_value': 0.0, 'rating_last_feedback': False, 'rating_last_image': False, 'rating_count': 0, 'rating_avg': 0.0, 'rating_avg_text': 'none', 'rating_percentage_satisfaction': -1.0, 'rating_last_text': False, 'activity_ids': [], 'activity_state': False, 'activity_user_id': False, 'activity_type_id': False, 'activity_type_icon': False, 'activity_date_deadline': False, 'my_activity_date_deadline': False, 'activity_summary': False, 'activity_exception_decoration': False, 'activity_exception_icon': False, 'message_is_follower': True, 'message_follower_ids': [29, 30, 31], 'message_partner_ids': [3, 7], 'message_ids': [45], 'has_message': True, 'message_needaction': False, 'message_needaction_counter': 0, 'message_has_error': False, 'message_has_error_counter': 0, 'message_attachment_count': 0, 'message_main_attachment_id': False, 'website_message_ids': [], 'message_has_sms_error': False, 'email_cc': False, 'access_url': '/my/tasks/1', 'access_token': '4c36bc36-f60a-4da8-9aa3-c81e05a7079a', 'access_warning': '', 'active': True, 'name': 'Office planning', 'description': False, 'priority': '0', 'sequence': 20, 'stage_id': [3, 'Done'], 'tag_ids': [], 'kanban_state': 'normal', 'kanban_state_label': 'In Progress', 'create_date': '2022-06-05 07:29:59', 'write_date': '2022-11-05 07:29:55', 'date_end': '2022-11-05 07:29:59', 'date_assign': False, 'date_deadline': False, 'date_last_stage_update': '2022-11-05 07:29:59', 'project_id': [1, 'Office Design'], 'task_properties': [], 'display_project_id': [1, 'Office Design'], 'planned_hours': 20.0, 'subtask_planned_hours': 0.0, 'user_ids': [], 'portal_user_names': '', 'personal_stage_type_ids': [], 'personal_stage_id': False, 'personal_stage_type_id': False, 
'partner_id': [8, 'YourCompany, Joel Willis'], 'partner_is_company': False, 'commercial_partner_id': [8, 'YourCompany, Joel Willis'], 'partner_email': 'joel.willis63@example.com', 'partner_phone': '(683)-556-5104', 'partner_city': 'Bayonne', 'manager_id': [6, 'Marc Demo'], 'company_id': [1, 'YourCompany'], 'color': 7, 'project_color': 3, 'rating_active': False, 'attachment_ids': [], 'displayed_image_id': False, 'legend_blocked': 'Blocked', 'legend_done': 'Ready', 'legend_normal': 'In Progress', 'is_closed': True, 'parent_id': False, 'ancestor_id': False, 'child_ids': [], 'child_text': False, 'allow_subtasks': False, 'subtask_count': 0, 'email_from': 'joel.willis63@example.com', 'project_privacy_visibility': 'portal', 'working_hours_open': 0.0, 
'working_hours_close': 880.0, 'working_days_open': 0.0, 'working_days_close': 110.0, 'is_private': False, 'allow_milestones': True, 'milestone_id': [1, 'First Phase'], 'has_late_and_unreached_milestone': False, 'allow_task_dependencies': False, 'depend_on_ids': [], 'dependent_ids': [], 'dependent_tasks_count': 0, 'is_blocked': False, 'display_parent_task_button': False, 'allow_recurring_tasks': False, 'recurring_task': False, 'recurring_count': 0, 'recurrence_id': False, 'recurrence_update': 'this', 'recurrence_message': False, 'repeat_interval': 0, 'repeat_unit': False, 'repeat_type': False, 'repeat_until': False, 'repeat_number': 0, 'repeat_on_month': False, 'repeat_on_year': False, 'mon': False, 'tue': False, 'wed': False, 'thu': False, 'fri': False, 'sat': False, 'sun': False, 'repeat_day': False, 'repeat_week': False, 'repeat_weekday': False, 'repeat_month': False, 'repeat_show_dow': False, 'repeat_show_day': False, 'repeat_show_week': False, 'repeat_show_month': False, 'analytic_account_id': [19, 
'Office Design'], 'is_analytic_account_id_changed': False, 'project_analytic_account_id': [19, 'Office Design'], '__last_update': '2022-11-05 07:29:55', 'display_name': 'Office planning', 'create_uid': [1, 'OdooBot'], 'write_uid': [1, 'OdooBot']}]
	

If we want to use search read method, we have to replace the task_ids as given below.


task_ids = call(url, "object", "execute", database, uid, password, "project.task", "read", [1])
	



Create Records


We can create records in the database using JSON-RPC. 


Let us see how to create a record:


URL: Specifying the url of json-rpc with host and port number


service: Set the service as object


method: Set the method as execute


args: Arguments to create records.


project_args = {
 'name': 'JSON_RPC Project 3'
}
project_id = call(url, "object", "execute", database, uid, password, "project.project", "create", project_args)
#Create task only if project is created
if project_id:
 task_args = {
     'name': 'JSON_RPC Task 1',
     'project_id': project_id
 }
 task_id = call(url, "object", "execute", database, uid, password, "project.task", "create", task_args)
	

The screenshot below shows the project and task created.


 https://lh5.googleusercontent.com/bcGb90z0mMNe72FSy-8cH4bB_vyb-qHyHAdNqf3qvBa03EqB-MT4bJ9MMhjfrSITjbk4Ull5Y366ahGuejLKnQoMOLDIuUWE0o1WLSzaMVoT7akec6s1XkfDVr-DTTT-iF6T_DaVfG6QSWfoT84nGLA 



Update Records


project_args = {
 'name': 'JSON_RPC Project 3'
}
project_args_update = {
      'name': 'JSON_RPC Project updated'
  }
project_id = call(url, "object", "execute", database, uid, password, "project.project", "create", project_args)
#Create task only if project is created
if project_id:
 project_update = call(url, "object", "execute", database, uid, password, "project.project", "write",project_id ,project_args_update)
	

It is used to update the records.


 https://lh5.googleusercontent.com/nEfwKuduDa8nx-W1yaZnBTaGJQgy8F8RrAJOy6Jz--id_Ged42HBobLqmigAOdnhyO8Lj4mRV-rxe5a3_ofZtNA6tiThkGYXHZ44n4_eGoQH7SSkP50rd_VL7g-rO2MJ_wzCoLOmKQpCwXtt459gMlU 



Delete Record


project_args = {
 'name': 'JSON_RPC Project 3'
}
project_id = call(url, "object", "execute", database, uid, password, "project.project", "create", project_args)
#Create task only if project is created
if project_id:
 project_update = call(url, "object", "execute", database, uid, password, "project.project", "unlink", [project_id] )
	

By using the unlink method we can delete the record created using json-rpc.


Calling Method


import json
import json
import random
import urllib.request
host = 'localhost'
port = 8016
database = 'DemoDB'
user = 'admin'
password = 'admin'


def json_rpc(url, method, params):
  data = {
     "jsonrpc": "2.0",
     "method": method,
     "params": params,
     "id": random.randint(0, 1000000000),
  }
  req = urllib.request.Request(url=url, data=json.dumps(data).encode(), headers={
     "Content-Type":"application/json",
  })
  reply = json.loads(urllib.request.urlopen(req).read().decode('UTF-8'))
  if reply.get("error"):
      raise Exception(reply["error"])
  return reply["result"]


def call(url, service, method, *args):
  return json_rpc(url, "call", {"service": service, "method": method, "args": args})


url = "http://%s:%s/jsonrpc" % (host, port)
uid = call(url, "common", "login", database, user, password)
print(uid)
	

Here we mention the URL with host and port. Then we mention the database name, user login, and password. Then we use service and common and method as login to connect to the Odoo database.


Odoo RPC library (OCA)


It is similar to json-rpc, which is a python module that can connect to Odoo server using RPC




Installation:
pip3 install odoorpc
	

Connection to Odoo database:
import odoorpc
odoo = odoorpc.ODOO('localhost', port=8016)
print(odoo)
odoo.login(db='DemoDB', login='admin', password='admin')
print(odoo.env.user.name)
	

This is will give output as follows:
import odoorpc
odoo = odoorpc.ODOO('localhost', port=8016)
print(odoo)
odoo.login(db='DemoDB', login='admin', password='admin')
print(odoo.env.user.name)
	

Generate API Key:
To connect to the Odoo we use our login credentials, username, and password,  for external API such as XML-RPC or JSON_RPC to connect our Odoo database. We can use an API key to authenticate users using external APIs. 


 https://lh6.googleusercontent.com/qvemazm_JzJ0K9LFmEl5L8cS69eV0AGxPZNZAFhU6C3iPFZD6T99gbFYoTI75GBMWlKWd7gLNPQZLtnPWGAoUC5PopuL7m1onV4cTjtDMlR78Esw5wUKSGl4mdXyYLgP447yzfi3UuHWB1oWil1FB_k 
 


We can select a preference to generate an API key.


 https://lh5.googleusercontent.com/D1bGZXtmdgKa93QKnbnMrRYvX7uUvJXUzJwWOTaz-pbqy1BeK7gSNQ8t1lcoHvpZMlIUK2plbE0bVXRDTZOQjMYq5b-r1wwC1nePu4VeGxQZa6jcN2c1A3UES8FdPibOBqv0OidPQdPI79r2lsERa-g 



In the Account security tab, we can see an option to generate API keys.
 https://lh3.googleusercontent.com/oxHOQOIeFqAWFv5bctPi4oMABHLJqA0piqt5KTLlglPe61RXzFtOlT6q7V1jJHdZ7tN7ALHH1OgKLkndeJeJiuoAwp2yiaDunXJfu11OeBu6xW267EUjb8XQSmmqYz6wB09qVHQocvDO-R1RBifv0QI 



Click on generate key to create a key and enter the purpose description for the key.


 https://lh3.googleusercontent.com/cVRp5Ite2-DnZB0d7hRrjqYbjpYJAxhKkamoBhZlF3AAE-iyp45pK08jp0T35ikkraArnvlplE0BiMjOk_zPRkyJ1Rl5YyJ05Wl-vgYuB2wbu6R0Jl9TibzHUeLLyB03xVczxx8lMkNwMU9Sr_tpiPU 



Then we will get a key. Make sure to take a copy and save it because we won’t be able to retrieve it later.


Then click on the preference to view the history.


 https://lh5.googleusercontent.com/Jvuh_yb4r5xziekktc4QXwm6hQ4XuBKOREPAqCpMjcpM2AZkiEcaelSoxPy7iYmWUhpToNjVYKGlpnWIN9abztHqFixGfXor0rDxTXkK9_C1SDTrnskBT4O5VU1b1jSuyc-nYUZnUfSZZV8gL2jtMR0 



import xmlrpc.client
url = 'http://0.0.0.0:8016'
database = 'DemoDB'
user = '1'
password = 'f3a905f86f69f9f30fac089769d406dc8d42f965'
common = xmlrpc.client.ServerProxy('{}/xmlrpc/2/common'.format(url))
version_db = common.version()
user = common.authenticate(database, user, password, {})
if user:
 print("User is authenticated....")
else:
 print("Authentication Failed. Please check the credentials")
	

This gives an output


User is authenticated....
	

We have used XMLRPC to connect to our database. We have provided the URL, database name, user login and generated API key as a password. When we connect to the database and all the credentials are correct, we receive a message as the user is authenticated….
























15. Performance Optimisation
Prefetch Patterns


When you access information from a record, the record is queried. If you have a data set with various data sets, specifying different SQL queries can slow down the framework when fetching the data sets. In this recipe, we'll look at how to solve this problem using a prefetching example. You can reduce the number of queries required by following a prefetch design. This makes the execution more streamlined and the framework faster.


Examine the accompanying code. It is a representative processing technology. In this strategy, the self is a record with many records. Prefetching works perfectly at the point of highlighting the recordset directly.


# Correct prefetching
def compute_method(self):
  for rec in self:
      print(rec.name)
	

However, prefetching can be more complex, for example, when retrieving information using a browse strategy. In the accompanying model, the for loop searches through the records one by one. This doesn't use prefetching effectively and runs more queries than expected.


# Incorrect prefetching
def some_action(self):
  record_ids = []
  self.env.cr.execute("some query to fetch record id")
  for rec in self.env.cr.fetchall():
          record = self.env['purchase.order'].browse(rec[0])
          print(record.name)
	

Instead of passing individual IDs to the Browse method, you can get the IDs into a variable and pass them right away. Then you can perform operations on that recordset. With that in mind, you don't lose the prefetch element, and the information is captured in individual SQL queries.


# Correct prefetching
def some_action(self):
  record_ids = []
  self.env.cr.execute("some query to fetch record id")
  record_ids = [rec[0] for rec in self.env.cr.fetchall()]
  recordset = self.env['purchase.order'].browse(record_ids)
  for record in recordset:
          print(record.name)
	

Prefetching reduces the amount of SQL queries when working with different data sets. This is done by fetching each piece of information without delay. Prefetching generally works consistently in Odoo, but under certain conditions, this component is lost, for example, when splitting the dataset as shown in the attached model.




records = [rec for rec in record_ids if rec.id not in [101, 102, 103, 104]]
	

The above code does not take advantage of prefetching as it splits the recordset into parts.


Accurate use of prefetching can contribute to the overall representation of object-relational mapping (ORM). You should look into how prefetching works in your engine. When you highlight a record in a for loop and access field values ​​in the first iteration, prefetching retrieves information for the entire record instead of bringing information from the current record into the iteration. This is because once you reach a field within the for circle, you are likely to carry that information with you to the next record iteration. The main emphasis of the for loop, prefetching, fetches, and caches information for all records. The next iteration of the for loop will serve information from this cache instead of executing another SQL query. This reduces the number of queries from O(n) to O(1).


We should assume that the recordset contains ten records. Information for each of the ten records is retrieved when the name field of the record is accessed in the first loop. This is not only true for name fields. It also shows each field of these ten records. The next iteration provides information from memory. This reduces the number of questions from 10 to 1.


self.env.cr.execute("select id from purchase_order limit 10")
record = self.env['purchase.order'].browse(record_ids)
for rec in record:
  print(rec.name) # Prefetch name of all 10 records in the first loop
  print(rec.attention) # Prefetch attention of all 10 records in the first   loop
	

Note that prefetching preserves the values ​​of all fields (except *2many fields) regardless of whether those fields are used in this for loop idea. This is because, unlike the additional questions in each segment, the additional sections have a minor impact on performance.


In some cases, prefetched fields can interfere with execution. In such cases, prefetching can be disabled by passing False to the prefetch_fields setting, such as recordset.with_context(prefetch_fields=False). The prefetch component uses the environment cache to save and restore record values. This means that once a record has been retrieved from the information base, all subsequent calls to fields from the environment cache will be processed. You can access the environment cache using the env.cache property. To invalidate the cache, you can use the invalidate_cache() strategy in your environment.


When splitting a recordset, the ORM creates a new recordset with new prefetch settings. Executing a procedure on such a recordset prefetches information for individual records only. Assuming you need to prefetch each record after prefetching, you can do this by passing the prefetch record id to the with_prefetch() technique. In the companion model, it divides the recordset into two sections. Here, we passed typical prefetch settings for both datasets. So when you get information from one, the ORM will get information from the other and cache the information for some time.


self.env.cr.execute("select id from purchase_order limit 10")
record_ids = [rec[0] for rec in self.env.cr.fetchall()]
recordset = self.env['purchase.order'].browse(record_ids)
recordset1 = recordset[:5]
for rec in recordset1:
  print(rec.name)  # Prefetch name of all 5 records in the first loop
  print(rec.attention)  # Prefetch attention of all 5 records in the first loop
recordset2 = recordset[5:].with_prefetch(recordset._ids)
for rec in recordset1:
  print(rec.name)  # Prefetch name of all 10 records in the first loop
  print(rec.attention)  # Prefetch attention of all 10 records in the first loop
	

In the code above, Recordset1 prefetches only five records in the recordset, but Recordset2 prefetches all the records in the recordset. Prefetch settings are not limited to recordset detachment. You can also use the with_prefetch() strategy to have typical prefetch settings across different recordsets. Which means, when information is fetched from one record, information is also fetched for all remaining recordsets.
ORM Cache


The Odoo framework provides the ORM Cache decorator with the ability to handle in-memory caches. This recipe explores how to handle function caching.


The classes of this ORM cache are accessible at /odoo/apparatuses/cache.py. To utilize these in any record, you should import them.


From Odoo import tools
After including the class, you can use the ORM cache decorator. Odoo offers different types of in-memory cache decorators. These are described in the sections below.
ormcache
This is the simplest and most commonly used cache decorator. You must pass the names of the arguments on which the method's result depends.
Below is an example method using the ormcache decorator.


@tools.ormcache('key')
def _check_data(self, key):
  # some code
  return result
	

Calling this method for the first time executes it and returns the result. ormcache stores this result based on the value of the key parameter. Calling the method again with the same key value will serve the result from the cache without actually executing the method.


Method results may depend on environmental attributes. In such cases, you can declare the method like this:


@tools.ormcache('self.env.uid', 'key')
def _check_data(self, key):
  # some code
  return result
	

The method specified in this example saves the cache based on the values ​​of the environment user and mode parameters.
ormcache_context


This cache works like ormcache except that it relies on parameters and values ​​in context. The decorator for this cache requires passing a list of parameter names and context keys. For example, you can use ormcache_context if the output of your method depends on the lang and timezone(tz) keys in your context.


@tools.ormcache_context('name', keys=('tz', 'lang'))
def _check_data(self, key):
  # some code
  return result
	

The cache in the previous example depends on key arguments and context values.
Ormcache multi


Some methods perform operations on multiple records or IDs. If you want to cache this kind of technique, you can use the ormcache_multi decorator. You really want to pass multiple bounds, and during the function call the ORM will create a cache key by iterating over this bound. This method requires a multi-boundary component as a key to return results in a dictionary-style design. Examine the attached example.


@tools.ormcache_multi('mode', multi='ids')
def _check_data(self, mode,ids):
  result = {}
  for i in ids:
          data = ... # some calculations based on ids
          result[i] = data
  return result
	

Suppose you called the previous method with [1,2,3] as IDs. This method returns results in the form {1:... , 2:..., 3:... }. The ORM stores results based on these keys. If I make another call with [1,2,3,4,5] as ids, the method gets [4, 5] as id parameters, so the method does ids 4 and 5 and the rest of the operations. Results are served from the cache.


An ORM cache maintains its cache in dictionary form (cache lookups). The key for this cache is generated based on the signature of the decorated method, and the value is the result. Simply put, if you call a method with parameters x, y and the result of the method is x+y, the cache lookup is {(x, y): x+y}. This means that the next time this method is called with the same parameters, the results will be served directly from this cache. This saves computation time and speeds up the answer.


self.env[model_name].clear_caches()
After flushing the cache, the next invocation of the method will execute the method and store the result in the cache. All subsequent method calls with the same parameters will be served from the cache.
Least Recently Used (LRU)


The ORM cache is a least recently used (LRU) cache. This means that keys in the cache that are not used frequently are removed. Improper use of ORM caching can do more harm than good. For example, if the arguments passed to a method are always different, Odoo will first look in the cache each time before calling the method to calculate. If you want to know how caching works, you can pass the SIGUSR1 signal to the Odoo process.


kill -SIGUSR1 <pid>


Here 674269 is the process ID. After running the command, you can check the ORM cache status in the logs.


kill -SIGUSR1 674269


 https://lh4.googleusercontent.com/LllN6FvPx2pup4omTx3-DubnYN7bzhwPcTJ-f1GvSJXtTOxlGsdcITlFeyqA-SXHqxHFTg_HIwBt_UBqSA8eKkKyWbKdAD__ig2iGzZlNJuSnun3Eu48KAjQJ0l-E2HPTeS4e04U8bI3jywjrYCXUYk 



The percentage in cache is a hit-to-miss ratio. The success rate for results found in the cache. If your cache hit/miss ratio is too low, consider removing his ORM cache from your method.



Create and update multiple records


If you are new to Odoo development, you may need to run multiple queries to write or create multiple records. In this case, you can see how records are created and written.


First, let's see how to create multiple records.


Odoo allows you to create records in batches. Just provide a dictionary with field values ​​when generating a single record. Instead of passing a single dictionary, you can pass a collection of these dictionaries to create records in batch creation methods.


vals = [{'name': "Azure",'age': '20',},
{'name': "Deco",age: 21},
{'name': "Ready",age: '19',}]
self.env['student.student].create(vals)
	

Writing multiple records.


If you are working with different versions of Odoo, you should be careful how the methods are written in this case. A lazy approach is used for updates. This means that data is not written to the database immediately. Odoo writes data to the database only when needed or when flush() is called.


data1 = {...}
for record in recordset:
record.write(data1)
data2 = {...}
recordset.write(data2)
	

To create multiple records in batches, you need to use the value dictionary in list format. This results in the batch creation of records.
When generating records in a batch, a query is automatically inserted for each record. This means that no batch log is created for a single query. However, this does not negate the fact that stacking records improves performance.


When it comes to writing, things are a little different. The framework does most of the work. For example, if you write identical data to all data records, you can update the database with a single UPDATE query.


Even if you edit the same record multiple times in the same transaction, the framework will handle it.


recordset.name= 'Name'
recordset.email= 'name@example.com'
recordset.name= 'admin'
recordset.email= 'dmin@example.com'
	

In the sample code, only one write query is executed, and the resulting values ​​are name=admin and email=admin@example.com. The assigned values ​​are later written in a single query, which does not negatively affect performance.
Generate records through database query


Odoo ORM has limited ways to generate datasets, but it can be difficult to get data from ORM. In such cases, you can retrieve the data in a specific format. To get a specific result, you have to perform an operation on the data. This slows it down. You can run SQL queries against your database to handle these special cases. In this case, you should check here how to execute SQL queries from Odoo.


Odoo developers believe that running SQL queries instead of ORM queries speeds up operations. That's not entirely correct. It depends. ORMs are better and faster than RAW queries for most tasks because the data is delivered via the recordset cache.


There are two ways to access the database from records. One using self._cr and one specifically from the environment using self.env.cr.


Example for using self.env.cr


self.env.cr.execute("Select * from book_book where name like '%s'" %(search_keyword,))
	

Discuss examples of how to use self._cr in Python code.


self.env.cr.execute("Select * from book_book where name like '%s'" % ('%War and peace%',))
result = self.env.cr.fetchall()
	

It just outputs the data you can get if the name contains the string War and peace. The result can be in the form of a tuple or list.


If we want the result as a dictionary format, we can use dictfetchall() method instead of fetchall(), for example,


self.env.cr.execute("Select * from book_book where name like '%s'" % ('%War and peace%',))
result = self.env.cr.dictfetchall()
	

The output is in the form of a dictionary. It is also possible to retrieve only a single record. You can use the fetchone() or dictfetchone() methods. This method has the same functionality as the corresponding fetchall() and dictfetchall() methods.


Grouped data


Sometimes, you need data in keyed forms, such as monthly reports, sales reports, etc. Finding and grouping records manually are time-consuming. In this recipe, we'll see how to retrieve grouped data using the read group() method.


The read_group() method is primarily used for smart buttons and statistical data.


At that time, we may display the number of sales orders on the affiliate form. Find the customer by sales order and find the number of sales orders.


purchase_count = fields.Integer(compute='_compute_purchase_count',
                          string='Purchase count')

def _compute_purchase_count(self):
  po = self.env['purchase.order'].search(domain=[('partner_id', 'in', self.ids)])
  for partner in self:
      partner.purchase_count = len(po.filtered(lambda purchase: purchase.partner_id.id == partner.id))
	


In this example, when the purchase_count field is displayed in the tree view, we can see that the Purchase orders are retrieved and filtered against all partners in the list. The read_group() technique doesn't make much of a difference for modest amounts of data, but as the amount of data increases, this can become a problem. The read_group method solves this problem.


There is another example of this, but it only consumes one SQL query, even for large datasets.


purchase_count = fields.Integer(compute='_compute_purchase_count',
                                    string='Purchase count')


def _compute_purchase_count(self):
  po_data = self.env['purchase.order'].read_group(
      domain=[('partner_id', 'in', self.ids)],
      fields=['partner_id'], groupby=['partner_id'])

  mapped_data = dict([(p['partner_id'][0], p['partner_id_count']) for p in po_data])
  for partner in self:
      partner.purchase_count = mapped_data[partner.id]
	

In this example, the read group() method uses the SQL GROUP BY function internally. This can speed up the read group method even with very large data sets. The Odoo web client uses this function internally for charts and grouped tree views. Various arguments can be used to change the behavior of the Read Group method.


Various parameters that can be used with the read_group method


   * fields: This is the list of fields obtained from grouping. If you are not using aggregate functions, you must include the following fields in the group by parameter.
   * domain: This is how the records are filtered. This is where to look for reading group methods.
   * groupby: This option is a list of fields used to group records. You can sort records by multiple fields.
   * offset: This option is used for the pagination of results. This argument is useful for skipping some records.
   * limit: This is a pagination option that specifies the maximum number of records to retrieve.
   * lazy: You can use boolean values ​​for this parameter. Its value is True by default. Setting this parameter to True will only group the results using the first field in the groupby argument.
   * orderby: An optional specification order that overrides the group's natural sort order. See also search() (currently only supported for many2one fields).
Image Generation With Different Sizes


Huge images are impractical for any website. It increases the page size and slows down accordingly. This leads to terrible SEO rankings and guest unhappiness. This recipe explores how to create images of different sizes. Using the right images can reduce the page size of your website and further improve page stacking time.


Odoo uses the image.mixin class to generate images of different sizes. To do this, your model should inherit image.mixin. The image.mixin model is an AbstractModel, so its tables are not in the database. I really want to include it in my model to use it.


This image.mixin allows you to save images with a maximum resolution of 1,920x1,920. If you save an image with a resolution higher than 1920x1920, Odoo will scale it down to 1920x1920. At the same time, Odoo also preserves image resolution and prevents distortion. For example, if you send an image with a resolution of 2400 x 1600, the image_1920 field will have a resolution of 1920 x 1280.


class ProductImage(models.Model):
        _name = 'product.image'
        _description = "Product Image"
        _inherit = ['image.mixin']
	

As a result, image.mixin is inherited, so five new binary fields are added to the model to store images of different sizes. Here is a list of fields and their resolutions:


   * image_1920: 1,920x1,920
   * image_1024: 1,024x1,024
   * image_512: 512x1,512
   * image_256: 256x256
   * image_128: 128x128
In the above field only image_1920 is editable. If you change the image_1920 field, the other image fields will be read and updated. Therefore, the backend tree perspective of the model should use the image_1920 field to allow the client to upload an image. Either way, you're stacking a huge image_1920 image in your tree view. Nonetheless, there is a way to evolve the execution using the image_1920 image in a tree view showing more conservative images. For example, you can use the image_1920 field to display the image_128 field. You can check the following code to do this:


<field name="image_1920" widget="image" class="oe_avatar" options="{'preview_image': 'image_128'}"/ >
	

With image.mixin, you can get the image with specific resolutions, yet imagine a scenario where you need to utilize an image with another resolution. To do as such, you can create a parallel field image to your model.


image_1600 = fields.Image("Image 1600", max_width=1600, max_height=1600)
	

This will create a new field image_1600, and when you remove the image, it will resize to 1600 x 1600 resolution. Note that this is not strictly necessary for image.mixin. Since we're just shrinking the image to 1,600 x 1,600, we need to add that box to the tree view. Changing this does not change the following image fields in image.mixin. Add the related="image_1920" attribute to the field definition if you want to relate it to the current image.mixin field.




















16. Emails
Incoming Email Configuration
We can configure incoming emails to connect the email with Odoo efficiently. The incoming emails will be received in Odoo after configuring the incoming email. Let’s see how we can configure the incoming mail. To set up this, go to Settings > Technical > Custom Email Servers> Incoming Email Servers. Then click on the create button, Then you will depict a window as shown below.


 https://lh3.googleusercontent.com/zICSogZB0Z5-FMq2QqxzjCQ1HnD0ig71Cs1uzFezVjoTdUqWEBUJicdUkhgqzbfKdxGJgnKdQk-jFCk_PXBp42xQhwAdfqPOU0DpoOOrEAm9y7DJEOaXKeIfFUlYsBpThw1qf4goeS33GJtIZjzLEqE 

Let’s take a look at a few fields that need to fill once you create the incoming email server.
Name: Enter the name of the email server. Let you know which server this is.
Server Type: This is the server that contains your email. From here the email reaches the client. There are three types of servers: POP server, IMAP server, local server and Gmail AUth authentication. POP servers are the most commonly used.
It’s the server in which the emails are contained. From here, the emails may be attending to a client. There are three sorts of servers like IMAP Server, POP Server, and Local Server. POP Server is the most usually used one.
Server Name: It indicates the IP or Hostname of the mail server.
Port: It’s the port number.
SSL/TLS: The connections will be encrypted using the dedicated portSSL/TLS after enabling this option. The port will be 995 and 993 for POP3S, and IMAPS, respectively.
Username: It carries the email address from which the system wishes to fetch the mail.
Password: It will be the password for the given email address.
After filling in the required info in the document, the button ‘test&Confirmed desires to be clicked. This may authorize the credentials. If the authentication is successful, the state will be changed to ‘Confirmed’; otherwise, arise a popup that indicates user error.
For Gmail, the configuration will appear to be this.


Outgoing Email Configuration
Odoo's outgoing mail setting is simple. It allows effective and efficient communication for a company to succeed in its industry. Outgoing mail servers are a useful feature with the intention to contend with the transfer of outgoing emails. Outgoing electronic mail servers end up essential for e-mail advertising and marketing and other easy wishes.
To set up the outgoing email configuration, 
Setting > Technical > Custom Email Servers> Outgoing Mail Servers.
Then click the button ‘Create.’ You will get a window like this;
 https://lh5.googleusercontent.com/X8U_sYeugxfJ6KjA3cVc4TNgufyBraxoSM5AhyTPXZapiMSDZwAOFZGQ3Al4PQ2XADl23f-VKqAv7CvT9jLmXlR_trHEXtDH-CvLv1-D2uSb0daGRxCHgA_O_9xjstVyjJ8f2rjahW6sypLf73ig6uQ 



Now, let’s check the fields;
Name: Allows you to enter the name for the outgoing mail server.
From Filtering: Define for which email address or domain this server can be used.
Priority. If not a specific mail server is requested for mail, then the highest priority one is used. The default priority is 10.
Authenticate with: Here, we can pick the alternatives which might be used as authentication. If it is the username, then the optionally available email for the SMTP authentication and its password. Suppose it’s the SSL certificates, then the SSL certificates and SSL private key.
SMTP Server: It denotes the SMTP of the server.
SMTP Port: This is the port of the SMTP server. For SSL it’s 465, and for others, it will be 587 or 25.


 https://lh4.googleusercontent.com/AGYG_4VeluZ4nHobhgeOrkgGRAv6iXxb3Ol468lgerAMkr04egK6vH6kwB0VfaU7tyQijhKu-Lm_LNrtOqde2E-5RUSz8M5dSc5RdkMgbudg-kiJE7QLuAHRCbr6FXO50MVp2bf5urCVLM08H_3Lbgc 

There is a button called ‘Test Connection’ that is used to test the connection after providing all required data. Then we can see the message ‘Connection Test Successfull’, which means now the outgoing mail server is ready. The configuration is given below.
 https://lh4.googleusercontent.com/zMwV0e3K6vObxP0TSXf1w2_CSA3D12HUALIODYhSUDbNnE2EYsQfFtl9FzL2QnM5oLGLG_eTDiPdyQSfFMd_b-6hAUrIsBiDvLW_mkLPnxlgaXYhlH7hZA7k6NBoc9jCtVjgWKvHGF_IJ79_1T2U_xU 

When the authentication fails, there will be certain exceptions. Suppose you get a warning like Invalid Credentials (failure) [AUTHENTICATION FAILED] while testing your Gmail account, in that case, the less secure app gets the right of entry to an alternative to have to be activated.
Email setup in Odoo is one of the important features of Odoo, it allows users to send emails immediately from Odoo to customers. It can be simply configured by the user.
Chatter
Chatter is the method of communication tool placed on most of the data in Odoo. It helps you to e-mail clients without delay from a buy order, income order, and so on., for example, to discuss info and live in touch. employees can use internal notes that are not seen by clients to inform each other approximately development or problems in the workflow. Other users also can be brought about to enroll in communication by using being introduced as a Follower to the document, even if they were not initially worried.
For example, if we take any sale order in the shape closer to the bottom or to the right of the document. Let's look for the chatter.
 https://lh5.googleusercontent.com/jk2GbemfC6VqVbV9MThGd7YoAKNfe5Fq143QN_xJYUWG5Z-zT4U8kJD9cwJ4fiylZqfcnCegvkyJy4ACWYIlLgmMfihGqtCpTNZOuWTNz-KRGmQLhixkYnaw3FluXsfM-n-RJBh8BMz_dAyYKfq5EKA 

You'll find the following options there:
The symbol ‘@’is used to mention a person, and to mention the channels, ‘#’ is used. Here we can use emojis for posting the reactions. Attachment of document is also possible if needed.
Log Note: This is useful for keeping track of progress with customers. 
 https://lh4.googleusercontent.com/nmyignq6LTpY8VeSd0gu1QSKiEpl5SNV_q5aB-9ctVlB3_0hbFXFWjd33Z2-sXjkCR09riOFfR4HbrGODZV9n-m-YISFr5RHs9KGupSpZZMYewZuepqjIo40BBetnjY2xxGSsYPSA4wCsOfZGHlEPsw 



Here also can add attachments.
Schedule Activity: By this, one can assign scheduled activities to people.
 https://lh3.googleusercontent.com/V8BIqmuoPnZZ-mZk5Qugt4w0y9x9hyg65PJg0ycail5A7cQJgBhH_ZOqYd7lkObfgxpMcFKomfVh0gzzHKCVZcYUD_3MMyx5SvT4vEU8neshPUgO2pegM4sT8r9bF-Ylnoht1vmoyYl227FL-FsnXjw 













📎: It shows the number of attachments and lets you add attachments
 https://lh4.googleusercontent.com/LMawDaFRJuvu6Z_nfxpkyMwrhN5OAp9GRUHn8QNcFhav8dxs7IuNRMbt0INwNMoKdc1vtgu7kT2fEfeOKMPb_VVgkvzu8UojnGLJo9lmhEK3Sa17VQDFomVoM53fSu438dUFRTcd7VsbRrIEmvp64dI 



Follow/ Following: It indicates whether you're following it at a look. You may unfollow the file by hovering over the ‘following’ and clicking on the ‘unfollow.’
Also, one can view the followers by clicking the button near to followers. By clicking the button you can edit and remove the followers and add new members to the existing follower list.
 https://lh6.googleusercontent.com/fL82K1X6MbsOKV8r9kGH9kuId0ervvK0C7cUAJywkY-K0zXkywR3pjvkGM6fiTZIaqGlV1g4eLd0vpvh4-E-Qjy1TtIohU7PcvmluEPrLi2QxwTWeJAYJzPlf9eDR0bFGz-OTbAqTyVGuGzqC8OXdG4 
        
You can click  ‘Add Followers,’ then the below window will pop.
 https://lh5.googleusercontent.com/toBvk1V1CzsNaQNN5qPB6j3MjG4xyMDG60pIdJX3CF6BCvWX1lZ46bjrJ382OPKfOkIK51fs0fVrGWusIV8CvBmjJAhRTUbgKmCUETMdH6XRCFRUO5AMRyIEFFwqnWhGnw3du6ed3OB0KQjWiRG32rg 



Required followers can be added from here.
Editing options are available in the followers list. A list of subscriptions that can be allowed or disabled for the selected follower.
 https://lh4.googleusercontent.com/kevsTJVeQf1_AmXKNu4vLi9gU5NqF-y_zAX6uGB9SHt8QnFu6aE5C--KCUxJMpwmK27UrUx0U040ezxwvsggH021d31U5QWCWUSec8S-UnYRUj3f0oBMCnL0nkdl7SWBGw5PHjvyc6mykU1I0GIY40A 

After including the messages, logging notes, or scheduling the activities, the entirety will appear inside the chatter of the form view. So this is the feature defined at the chatter.


Every so often, if we change a few fields within the form view, the alternate will trigger and be shown within the chatter. This feature is called “Tracking”.


 https://lh6.googleusercontent.com/nZL-c5JttcffIiXN6tfRn_5txLo1c4bwIJQUCxdr3ula5SIoKlYI9SmWQBJM2MKMv7Lm4pcQ-WT_4ZZCg2LmGi_rzi3ofBHCrPAvFqjNl6tkvjkK05UH_GV_UrFVJAqOA59dV5yFlm2g7TO180vj3Gw 



It is simple to enable tracking for a field. Field declaration when referring to tracking attributes. You can enable tracking by setting this attribute to true. Within the field declaration, you can set Tracking='True'. Odoo is a multi-user platform, and any user can access and update the same records at any time.
In these circumstances, we must keep track of the field values. Odoo chatter keeps track of this information automatically.
How to Add Chatter to the Form View
Chatter is a basic feature available in Odoo. You can add it to your form view in a few steps. To get the basic chat into the form we want, we need to inherit the mail.thread model in our python file.
        


class ClassName(models.Model):
    _name = 'custom.model'
    _inherit = 'mail.thread'


	

Also, the dependency should be added to the manifest file as "Mail." These are the things you need to add to your Python file. Now we need to move on to the XML file. After a sheet of forms, you can define chatter; For example,


<record id="view_id" model="ir.ui.view">
   <field name="name">name.name</field>
          <field name="model">model.model</field>
        <field name="arch" type="xml">
       <form string="">
           <sheet>
           </sheet>
           <div class="oe_chatter">
               <field name="message_follower_ids"
               groups="base.group_user"/>
               <field name="message_ids"/>
           </div>
       </form>
   </field>
</record>

	

Here the division ‘oe_chatter’ defines the chatter. It contains two fields: "message_follower_ids" and "message_ids." These fields are related to chat base fields. There is another function called "Schedule Activity." To do this, we need to inherit from another model. It's a "mail.activity.mixin" that allows you to add fields to your XML file. 


<field name="activity_ids" widget="mail_activity"/>
	

Together the basic chatter including the activity option can be added by inheriting the models;
_inherit = ['mail.thread', 'mail.activity.mixin']
	

The XML file should be like the following code, 


<div class="oe_chatter">
  <field name="message_follower_ids" 
  widget="mail_followers"/>
  <field name="activity_ids" widget="mail_activity"/>
  <field name="message_ids" widget="mail_thread"/>
</div>


	One of the most crucial reasons to enclose ‘chatter’ in your module is to maintain track of activity in a certain region of the module. So that is how we will make use of the chatter in Odoo.


Activity
Activities reduce the risk of uncertainty by providing clear instructions for the next steps. Planning activities is a stunning method to keep focused on the work. Schedule activities supported by most of the Odoo records. We'll use an opportunity in the CRM software for the example.
 https://lh3.googleusercontent.com/OP0hig3a_AQMaWTPJLBxWkoLKarFQkqWNg4XGJJFfKGIIRtQcwmetwma7EsS0XDNaWjMCzdx7_NlnT2HmsGfHJioDZx3z83QtkOUupGGFIzGw1bvsOomeR6eiN6QpqST9O_Jt4h07iVBTaIVxgwn8OU 



Here inside the pipelines, we can see the opportunity. Click the clock symbol to see the option to schedule the activity inside the opportunity card. From here user can schedule an activity.
 https://lh6.googleusercontent.com/HWoI3JJvtefEgtjSHXPty2GueCHhxNd1LsSBFF863aXzH1xxVRa_CSY9kY42XyjyuNE4NvnSgQMGmRHqyKQM40MzfCG1ucaVIgCkJtpAt08rS_e2Dyrom5Va5xFgHbpGEzLMWt0XRNizl9SGJUF8xPM 



Here fields are;
Activity Type: Choose the activity type as per our wish.
Summary: Description of the activity that is specified.
Due Date: Deadline for completing the activity.
Assigned To: The person who is responsible for the activity.
The activities can be planned from the tree view, form view, and calendar view of the records as well. The opportunity cards have the clock symbol with different colors with respect to their activities. One can schedule the activity by clicking the schedule button. If it's grey, there aren't any activities planned right now. Scheduled opportunities are in green color. Activities that due today are in yellow color, and the last one, red, is time to get work. 
Also, users can create the types of activities they want in the configuration from the CRM module or in the general settings of Odoo.
 https://lh5.googleusercontent.com/YR8iwo_5kmEwAAW_pEQon9MEheJfSB3b0NitccBiJFWca8O5g2e6CHsVJiVQ83Rm3ksw4T3b_fMhzoxZBNrmTCrhzXJObGJcHAxg5Q98s_yfv-F6bYokBcpZGMzyJMYrFFYfrURuIrHJsugPqyAC4ao 



Name: This is the name of the activity type.
Actions: Certain actions can trigger certain actions, like opening the calendar view.
Default User: Assign users to activities. If it's not assigned to anyone, you can assign it manually when you select it.
Models: Start Comment If you want to make the expand model activity specific to one model and not use it when managing the activities of other models.
Default Summary: A brief description of what the activity entails.
Icon: Font for icons such as fa-phone, etc.
Decoration Type: Change the background color of the associated activity. For, Next Activity
Chaining Type: You can select either Trigger Next Activity or Suggest Next Activity as the next activity to select the next activity. 
Suggest: The selections displayed depend on the action selected and the consolidation type selected. If you want the Deploy Comment Start model activity to be specific to one model and not available when managing activities for other models.
Email Templates: E-mail templates can be used for activities if desired.
Schedule: Set the number of days, weeks, or months for the next action and when it will occur. B. After the completion date of the first activity or after the deadline of the previous activity.
Log Note: Any notes displayed about the activity. 
In this way, you can create activity types. 
Click the icon in the upper right corner of any page to view all upcoming events. A number next to the icon indicates a slow action.
Send Emails Using Qweb Template
Email can be the most powerful, effective, and cost-effective strategic marketing channel available to businesses. The advantage is that emails are sent and received instantly, regardless of whether the recipient is next to you or thousands of miles away. We all know how important it is to craft perfect emails for maximum reliability, but who doesn't want to rehash the same structure over and over again? In such cases, email templates can help. It saves time by allowing you to focus on your content instead of having to rebuild your entire email structure each time.
QWeb is a multilingual web framework and primarily an XML template engine. Due to QWeb advantage, Odoo uses his QWeb for email templates. Email templates can be customized quickly and easily in Odoo. We also offer a wide range of customizable business operations solutions.
Here's how to create an email template:
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <data noupdate="1">
           <record id="mail_template_presence" model="mail.template">
               <field name="name">HR: Employee Absence email</field>
               <field name="model_id" ref="hr.model_hr_employee"/>
               <field name="subject">Unexpected Absence</field>
               <!--        Sender email            -->
               <field name="email_from">{{ user.email_formatted }}</field>
               <!--   Recipient email             -->
               <field name="email_to">{{ (object.work_email) }}</field>
               <field name="auto_delete" eval="False"/>
               <field name="body_html" type="html">
                   <div>
                       Dear <t t-out="object.name or ''">Abigail Peterson
                       </t>,<br/><br/>
                       Exception made if there was a mistake of ours,
                       it seems that you are not at your office and
                       there is not request of time off from you.<br/>
                       Please, take appropriate measures in order to
                       carry out this work absence.<br/>
                       <br/>Best Regards,<br/><br/>
                   </div>
               </field>
           </record>
        </data>
</odoo>


	

This is a basic template used. Now let’s check the details regarding the templates;
id: Unique ID of the record. You can see this when you go to Settings > Technical > Email > Templates and check all templates. 
model: A model associated with a mail template, ie mail.template.
name: Helps to identify the created template quickly.
model_id: It is the reference to the required model.
email_from: It is the email from which the template was sent.
email_to: Email for receiving emails. 
Subject: It is the subject of the email template.
body_html: The design and content of the email is contained in the body HTML.
After creating the template, it will appear in the menu called “Email Templates” from the settings. From there, we can see the templates and their preview.
If you want to send an email using this template from any custom function, then the python code can be used to send it. Let’s see how its works;
def custom_function(self):
    template = self.env.ref(module_name.mail_template').id
    template_id = self.env['mail.template'].browse(template)
    template_id.send_mail(self.id, force_send=True)


	

Email Alias
In Odoo, email aliasing is a built-in tool that allows users to extract data from incoming emails and save it to ERP records. This function is an example of automation. We may configure Emails to automatically fetch content, eliminating human work and streamlining the business process. Any email sent to your domain that does not have a designated mailbox will be sent to your catchall email address. The applications retrieve the emails and forward them to the appropriate virtual mail account, and this is how an email alias works.
A Mail Alias is a relationship between an email address and an Odoo Document object.
Odoo's mail gateway uses it to process incoming emails delivered to the system. If the message's recipient address (To) matches a Mail Alias, the message will be processed according to the rules of that alias. If the message is a response, it will be added to the associated record; otherwise, a new model record will be generated.
This is intended to be used in conjunction with a catch-all email setup on the company's mail server so that when a new mail.alias is generated, it is utilized, and Odoo processes mail for it.
Let’s check how the email alias is configured in Odoo.
If we need to use the email, for example, example@mydomain.in here, ‘example’ is the alias name, and mydomain.in is the alias domain.
First, we need to set up the alias domain. For that, you will need to go to the settings > general settings > Alias domain


 https://lh5.googleusercontent.com/6QiKLDLGOAr1SUtFS2iPhoVDo7DILg_uu_t8GFkH1dUltrMctlJ777QDzODKHByFyZhH8qFXNj1nvvsPPuHUWfqLp_CAj1SqOa2Ql7RCWvlb7HFApCLQ8lUFYZByYofl21ETLHFNLiRaJ9Hfs2TNkBU 



We may enable the field 'Custom Email Servers' here, which will bring up another option below where we can enter the custom domain. After creating the custom domain or alias domain, the next is to create a record in the model ‘mail.alias’ from Settings > Technical > Email > Aliases.
This can be done using the XML code given below.


<record id="mail_alias_jobs" model="mail.alias">
           <field name="alias_name">jobs</field>
           <field name="alias_model_id"ref="model_hr_applicant"/>
           <field name="alias_user_id" ref="base.user_admin"/>
           <field name="alias_parent_model_id"ref="model_hr_job"/>
        </record>
	

id: id of the record
model: model in which this record is being correspondent
alias_name: alias name needs to be provided
alias_model_id: id of the model in which the alias is defining
alias_user_id: XML id of the user
alias_parent_model_id: parent model holding the alias
After creating this record, it will be visible on the menu Aliases;
 https://lh6.googleusercontent.com/Nl8wcP4SpuoNAvgpVkkiFQFk1xlZS4gNcwu04m85vAtW9f--enGxuBFuyOTloYJWVbZpAABtKdnlwo9BbEjgPom-xwj4W7e-uJXjCkiPuIl_HywOCPlh4zz-htg4j5-pCFoWoEM4UzRtYY7Wufjsn7o 

After this, the outgoing and incoming email servers can be configured.
 https://lh4.googleusercontent.com/i8sPCi8eUl8HxJpJ_4EU2jGVXgB3ArXm3XZFPe9GuCmOm09Qcef1v0oyUYCTfzKZVitnLQjz7oHC8WeqGVzVfXLpwZaw6uDEVC5nx5AxccVVakqJTUdrdiCvIQOUeuC-MACGf5BRw5Q9-2i7couDW24 



 https://lh5.googleusercontent.com/owMrtr57bk3-TPWW5QGGbeCb5N7TG-3F7796X4wnBQQzSLK-ixClxbbBKK7Z45aQGi-AMIuh8L8tHzalqCG5TDkwnfFFdqqrlG0Xys1F4ELoBQfJ8fMr3Zaqhn-IPIizsg2_ScWgsiS25662EbXK0U8 



Odoo will connect via a scheduler and will check emails every 5 minutes by default.
It is recommended that in developer mode, go to Settings >> Technical >> System parameters, then search for "mail.catchall.alias" and set its value to the name of the catch-all mailbox so that replies go where they should.


Periodic Digest Emails
Periodic digest Emails are high-level views of how your business operates that are provided to your organization regularly via email. The Odoo framework can send out digest emails on a regular basis. We can send an email containing information about business KPIs using digest emails.
It can be configured under settings > Statistics > Digest Email


 https://lh3.googleusercontent.com/FLxtaMNfG5Cwo4ORDxb_n4zA8CCNcUncaVl9eEm809f9qx-YM974NbvHg2vqgPjGmTvph5R0NM5qajCcBCWXDVLbsoMUHWWvpsKAsYpZn-TAQjWBOKrOJ_5x9sG_wpNhXyWWwmCo0JyR6-jmskrtTNo 



The field to insert the digest email records will appear after the Boolean field has been enabled. The default one made by Odoo will be displayed, and it may be modified by clicking on the hyperlink button, or new records can be created by clicking on the 'Configure Digest Emails' button. It will take you to the list of records that are displayed there, and by clicking on the button ‘create,’ a new form view for creating the record will appear.
Given below is a default template created by Odoo. This will send an email on a daily basis by considering the mentioned specifications in the record.
 https://lh5.googleusercontent.com/n5SuwOAuB2hOjT0cYjrSaDIDVDDc4TMYx7fe10BRRsp0Eyf75XVYsHE58PkTFCT0xCpFlvuAv59ZBeZI5AUqee6MI-ik57jEDximpjA0awYrtuVLSuoCvMmmSB6N3sskydvLDWEuctDzlZTBcVm2g6k 



In the header, there are a few buttons;
   * Unsubscribes Me: It will unsubscribe this mailing
   * Deactivate for Everyone: This template will be disabled for everyone
   * Send Now: Send an email to the subscribed users
There are two basic fields that determine the nature of the email, that is;
   * Periodicity: periods that will trigger the email. It can be daily, weekly, monthly, or yearly by default
   * Next Send Date: The date on which the email will be sent next
The page ‘KPIs’ contains the general information regarding each module. This information can be included or excluded based on the need.
 https://lh4.googleusercontent.com/uVr6z5i0u9q_gb4-u6Vv4X-7furBQvaOc2Kr2LuXwdXjYkTP-UHM3QLPlXlo1AqjtjfIPuVJrc3koMb3hD5nHCugMyWTDOGOzLWISjagzWtqXtakkXxIhb_98R951cISyqOrXjSYA37crCQr7AKXZIw 

On the 'Recipients' page, we may list the people who should receive the digest email.
 https://lh6.googleusercontent.com/03x2KJCAz_tapyZ63zrQJ43w7EeiF1i2iJhVN5h9wSitGn7Wa2WWidFzJTR19vcNtZQ3gsIsk35MAymMVRJaKIhsxxc8bt0F7B8_o0-U_dMJBRqNlL4k5a60RkHti5PN-FsIH2teNLQJHQSNACFDq9c 



Digest Email is enabled by default, and the primary template is Your Odoo Periodic Digest, which covers all KPI metrics across your Odoo database and is delivered daily to administrators.






17. Point Of Sales
Custom Javascript Files in POS
Point of Sale use a wide range of assets. The loading of assets in Point of Sale assets in Version 15 has undergone significant changes.  Let's check how we may do this.
1. Here is the module structure for adding a custom Javascript file to POS,
 https://lh3.googleusercontent.com/ePDOUDFfVSmZJ1aXtxvfDlnmo1TH9PYPlegolsggznC4Zvtc-ofczZ9Ssokr4l0xyH7q7igPId088VAUTFyhuzrMljXL-fJC8HOMYbu-yySfLOlnVDmajiPAEpgMiQF6hnBmS-g3yosrXNwmAoEkSQs 




2. During the start of the POS session, define the console.


odoo.define('custom_pos.pos', function (require) {
"use strict";
  console.log("Custom JavaScript In POS")
});
	
3.JavaScript asset registration at the point of sale:




'assets': {
  'point_of_sale.assets': [
      'custom_pos_javascript_file/static/src/js/**/*',
  ],
},
	

Enter the custom_pos_javascript_file module. Start a new session from the point of sale area to see the changes in action.
How it works
Including javascript in the module. Create a console log. To view the message, you need to open the developer tools in your browser. The following log can be seen on the console tab. This shows that your javascript file was successfully uploaded.


 https://lh3.googleusercontent.com/X5YtRzaiLZkaD8URXKvOWBLOrx--S6OoWB0I0airLLDiUpTffX4fFCMy18pBHw3F9X0TvveM3p39jO94CHT8T-vwo8t0oCZQTzPzluJSUY9vbjaj8p1Zwdl2CLT7WanlyWXcltWNA9rf92QgO9Ap5Bs 




Custom POS UI
Let's look at how to customize the user interface for the point of sale.
OWL Qweb Template-written point-of-sale application.


 https://lh3.googleusercontent.com/Z5O2uX4GFwRktp3famXV23aGaU2q8-ZbY_mlYNYTocfIxSVzPrS7mmPAMH6u8YEPQNNJFRlpmEbUKfz2sUOIhWQAPpZ68nD7gRWkOKULZg9Q2jDAGm2Jrl2J__kRKYFAL69q_gCYULKsAF__wY3x9Gw 



This is the standard user interface for a point of sale.
Now we are going to customize this UI of POS. We include the quantity available in the product box.
To include that, First, we need to create a python file named pos_session.py to load fields that are not in the list like this. 
class PosSession(models.Model):
  _inherit = 'pos.session'

  def _loader_params_product_product(self):
      result = super()._loader_params_product_product()
      result['search_params']['fields'].append('qty_available')
      return result
	Here we are loaded the qty_available field to the product.product pos model. The qty_available field is not loaded default. After loading the fields from the product.product model, we can use it in the Qweb template. So now we can customize the product card of the POS. In version 16, no need for a JS file to load the fields for existing models in POS. 
For customizing the product card, first, we need to inherit the template ‘ProductItem.’ It is the default product card template.
Add the XML file ‘pos_screen.xml’ to the module and inherit the template like this. We need to extend the existing product card template and display the additional information using the XPath.
<?xml version="1.0" encoding="UTF-8" ?>
<templates xml:space="preserve">
  <t t-name="ProductItem" t-inherit="point_of_sale.ProductItem" t-inherit-mode="extension" owl="1">
    <xpath expr="//t[@t-esc='props.product.display_name']" position="after">
         <br/>
         <span>Available Qty: <t t-esc="props.product.qty_available"/></span>
     </xpath>
  </t>
</templates>
	Using the XPath, we can see the available quantity of the products in the product card after the product display name.
Finally, add the js file and qweb template in the assets.
'assets': {
  'point_of_sale.assets': [
      'custom_pos/static/src/js/**/*',
      'custom_pos/static/src/xml/pos_screen.xml',
  ],
},
	

Currently, the product card displays the quantity information.


 https://lh5.googleusercontent.com/Zpatmb2jn53V9xCqWFpYmZydiWEthuAfkzulb20lqM8LhXpk4rD9xuxKz_m7Wc68ubZHnIDbkicjtNWevH-Tvo-vhU8SMWolmR1bkeH4smqQ6LTwVbrza_oIlWmqHncrS05HlwMO7oeUdChsEcY3Lww 

Customize Customer Receipts
This section demonstrates how to modify POS receipts.
 https://lh4.googleusercontent.com/Icracm1bC6YhOMw6V0uTQtR02FoV1EZdknupKCFisCGQNP8BYwJ_giQPfbviSyajUY6jo37HpzAXBq522ZgCBJ3NyWwI1Lr3xioO9Hid3vsXICxBAIJUSp8FQozgCgfJHR6AFUt3qFYCq-k0QwCA65M 

This receipt is the default receipt in the POS.
Now we are going to display the customer's name below the cashier's name on the receipt.
For that, we need to add our customized changes and inherit the template "OrderReceipt."
<templates id="template" xml:space="preserve">
 <t t-name="OrderReceipt" t-inherit="point_of_sale.OrderReceipt" t-inherit-mode="extension" owl="1">
     <xpath expr="//t[@t-esc='receipt.cashier']/.." position="after">
         <t t-if="receipt.partner">
             <div style="font-weight: bold;">
                 Customer: <t t-esc="receipt.partner.name"/>
             </div>
         </t>
     </xpath>
 </t>
</templates>
	We modified the Odoo default OrderReceipt template, and using XPath, we inserted the client name to the template below the cashier name. When a customer is set on the order, their name will display.
The assets in the manifest file should include the XML file.


 https://lh3.googleusercontent.com/FCa3cxWztIk2fQw84_owG-aCOAFVLsHJRFmxws13T5zh-b3S0D0lbvgZb18Yd9O86w8O80gMRF3jRI8VvbaCCCG6T9FwIHAhb5EV_NvIWxyBPxm9-lGxmV0Nwyce2lNTvg7KqDrsd2MG43y8R81dwZg 

If a customer is set in the order, then the  name of the customer will be displayed on the receipt. The customer details are already available in the receipt environment. If we need to display other information that is unavailable, then we need to override the export_for_printing() function to send more data to the receipt environment. The Qweb template of the receipt will include all the data sent by this function.
For example, since we reward customers with loyalty points for their purchases, the receipt must include their earned points for this order. Give 2 points for every amount spent.


In the js file,
odoo.define('custom_pos_javascript_file.receipt', function (require) {
"use strict";

  var { Order } = require('point_of_sale.models');
  var Registries = require('point_of_sale.Registries');
  const CustomOrder = (Order) => class CustomOrder extends Order {
      export_for_printing() {
      var result = super.export_for_printing(...arguments);
      var loyalty_points = Math.floor(Math.round(result.subtotal * 2))
      result.loyalty_points = loyalty_points
      return result;
  }
  }
      Registries.Model.extend(Order, CustomOrder);
  });
	Here, we override the export_for_printing() function, calculate the  earned loyalty points from the subtotal, and pass it to the receipt environment as earned_points.
In the XML file,
<templates id="template" xml:space="preserve">
 <t t-name="OrderReceipt" t-inherit="point_of_sale.OrderReceipt" t-inherit-mode="extension" owl="1">
     <xpath expr="//t[@t-esc='receipt.footer']/.." position="before">
         <div style="font-weight: bold; text-align: center;">
                 "You have earned <t t-esc="receipt.loyalty_points"/>
             points from this order"
             </div>
     </xpath>
 </t>
</templates>
	Now, the receipt environment has the key earned_points, which holds the value we passed from the export_for_printing() function. Using XPath, we extend the OrderReceipt template and display it in the appropriate position.
The receipt will now display as shown.
 https://lh6.googleusercontent.com/HDu0Wn1BNAfjL_hnWZiL_xNfrCFbL5klH_Jl5n-Vc4QQ67-t55iO6VZdbk9WP1yXatLWWmSgzvzb3onY57SbIW3BYKiHt4C_OR2TNIc0T3Nnm5Ism79da19gLBDoSoEY5GUFP7SKjyd_BdkjH-OHMEU 

The Odoo POS module supports the proper management of your company's operations. Using Odoo POS, you may manage multiple shops or restaurants. Even if you are not online, it will still function.


It also uses a different architecture from a development perspective since it needs to be worked offline.
We can customize the POS applications given by Odoo to meet our demands. We can modify the current business logic and customize the POS UI and customer receipts.




















18. IOT Box
Connect IoT box to a network


The Odoo IoT Box is a Raspberry Pi-based device that is used to connect different external devices such as printers, scanners, etc. We can connect these devices using WiFi or Ethernet cable to the IoT Box, which itself is connected to Odoo ERP. Connecting IoT Box with the network is a crucial initial step for error-free workflow. 
First, install the Internet of Things module.
 https://lh3.googleusercontent.com/jH80To9YNodgHtzedTrIzNUrhOtN-sIVxHz4cEgIUAp3ZexYYU-kMun9L_GKGK669qGMaW9eK1-FHn9ZzyvW6ui7ee4vDvkAsfgsy9gLdyHc05jJT8zwMip2tGrgmzBeTVF4VKi482o1iG0VUzCzKWI 



The IoT app will be available on the homepage. Open the app to see the available IoT Boxes in the system. 
 https://lh5.googleusercontent.com/5K27YKg23buuiTYyEVFfu_X-RdP816P3BM8aBxGcEo9llroEya3752DPnOFEfr2gGo80wlw-ge2K18m3KWVkTArzXU4xaLQxFpZY_q6R4UPaovh0lxnwd_ECLduoeh9LV1VJ7_EBnN3SYl1CCeEzkoQ 



For connecting a new IoT box, there are two methods either using Ethernet or WiFi. Initially, connect all the devices to the IoT box and power it on. 


In the case of an Ethernet connection, we can connect the IoT box using a pairing code which can be read from a screen or the receipt printer connected to the IoT box.
 https://lh6.googleusercontent.com/8w66_uXttVBfpZYNNCNnv-kFNcxbJuwhCxr2Q09AJq5vMiufAIoDEEVvLtKnbvYtokI4hwiBValCDS4gGQPOiVtJVgQ8XbFa5J_OIxuaDlxUVF7fi_pqoglmM9GraMQA8SsTBUYzDUhzoVJ1h45lVRQ 

Enter this pairing code in the popup after clicking on the ‘Connect’ button from the IoT module dashboard.


 https://lh4.googleusercontent.com/zryaOedF4ogwvlUN5yWSMXXu96mJB4yRPUog3ITs6Nu8LyaZ5jGmB3sALT7WidPmEY_qMKCYYhobGjXwInnsm0M1cL2w3uQym7A336DHZoxRz5vfxTsVs-VQANZVBdrtG8XfOmbIwuzxzD3RudBDSAM 

￼
The first steps are the same for the WiFi connection also. Before we power on the box, we have to connect the devices to the IoT box. Copy the token when we click on the ‘Connect’ button.
 https://lh3.googleusercontent.com/v13wSDB0N9VfWb-FMsJJF1yzI1tVhkiaYqj0ggw60fh6w_y71d--XRb5uZLglvrCcZP4DkVvW-YT0fnOIJ8VXtymeYi9Qg0AJyvfT-j4j3_EFNDkEGNMwOMvc9i6n2FhHdvTFh8uojrpJnn-gepp7rk 

Make sure there is no Ethernet cable connected to the computer and connect to the IoT box WiFi Network.
 https://lh6.googleusercontent.com/tmWtEUTMvG-s3JBX4iI1ZHaCHsObKhBOJsonQBmfkvcFZYvkW0VKLDmNtQixvidIQTdfWnp8iswPMfXObOyngiCRbI6_ILcWgNjCZqvl-0L0M4Hxi0ajcgsds9YFTHv9QlV-R_Y0YnYaUqNzx7QBaZo 



We will be redirected to the IoT Box homepage. If not, we can just connect to the IP Address of the box. Paste the token in the ‘server token’ field and provide a name for the IoT box for identification.
  https://lh5.googleusercontent.com/VbSVGBeS7Kv4y67wOaMu8BadQyA2V2vfHkM_01SnmOE7YijnXHOIPrqIp_fInlyz4NHGsjgrofxbqUZyP75Xjqav9TIsmJZ2u1uVeTP_rO3vaGMcVcVrvfJdUxzahJQe4L4VTIhoiDr-Vcn17GgMlLM 


The new IoT box will be listed in the IoT application.


Connect IoT box with Odoo


In the previous step, we connected the box with the network. Now to use it on Odoo, we have to connect it with the Odoo instance.
Make sure both IoT Box and the computer running the Odoo instance are connected to the same network. If we are testing it on our local machine, use the local IP instead of using http://localhost:8069. Else it will not be added to the Odoo instance. Also, we have to use db-filter if we are running multiple databases on our Odoo instance to avoid auto-connection issues.

First of all, install the Internet of Things module from the apps.
 https://lh3.googleusercontent.com/rYMJuVqszo1075CA614TgzWTEvnffLE-Ubr_-4yLZlii9pXIVYbvfqlEndHTL65-t2XRU1izZvA4y6_pzo-eKI6UEL_-jQGyNJsOMzliHVnkV9WXR1MRBi8FV5NzRcI3WsBCGCiPy12gL0gsDRddIgU 

   1. Connect the IoT Box manually by clicking on the ‘Connect’ button from the IoT App.
   2. Copy the token from the popup.
 https://lh6.googleusercontent.com/TMyyifPFE7sgRXjd2ix4pcZVYhhRpaX4olUgbEmvtSuMUMl92wTAEXw9TtwD9NPGdvxbFZxSkftB7jmJPZttPA7e3ZZ-XyR6D-utQJpVCj4XkUMW1IPeYioUJJbAcPapgJaDxKQ9wjOizSMAcGZMAYw 
   3. Now, for configuration, we have to open the IoT box homepage using the IP address with port 8069. Click on the ‘Configure’ button next to the name field.
 https://lh3.googleusercontent.com/ztSnJTIvxA9aOqrLU2vcmiBxtWbaMoyHQlwEh5CV0t77wMyfLzQBC2lG6wVV2DxjwOkemCVg_JViK09QmiyQ5FNv1P3PnipralAlUEYAFDZvKujjII9-7AOp6-zDK-bgd-r5I_Uft4noHTybWOudBTg 




      4. Provide a name, and paste the token that we copied from the previous step. After that, click on the ‘Connect’ button and wait for the proces to finish. https://lh3.googleusercontent.com/lf5tU4YGCRhFr9nKd6Alr72YCZ4kWReXXyHJTo8tMOZsAf-I7CLfY5qdNcRYj6SffrwkjaRgR7kS26EW7zgKT7mlSfJ2ODQI54-JXI97IXMrelYHmwZV22MHSJPI-LMdfHn2CWWcNefSz0VmyRlf_jE 
      5. The IoT box will be added to the IoT app once the above steps are successfully completed.







Load Drivers


For a hardware device to communicate with a computer’s OS, we need a set of files called drivers. When a new device is connected to the system, the interface will fetch all the connected devices, and it will loop through all the drivers that have the same connection type attribute and test their respective supported methods on all connected devices. And if one of the driver methods returns True, an instance of the corresponding driver will be created for the device.



         1. Open the IoT box homepage using the IP address, and click on the ‘handlers list’/’drivers list’ button.  https://lh5.googleusercontent.com/QjbpYsD171CT-y_wZKzjNLArCVlZ9uidrRLCeBL4t4yUA0TJUAYjvNn_A5kRcUKMHhSaGX2aRjwec7URT4FfAfNPU1KHWOgizCq88mulOxwfUilmouDsKgsnti-GuJkxolOD0slfDVCuP5PSo0ZrWwI 
         2. On the resulting page, there will be a ‘Load drivers/Load Handlers’ button at the bottom. Click on the button to load the drivers.
 https://lh3.googleusercontent.com/4MpU8E1SI5ZC_2iMMD_IUBiIGjFfzjR4FS5zKJ8qZdvylk3AZ86z5L23IdGZCtrbCovNYOPd61b2EhAICiM-Cutzcelugv_gXU9-IjryRvutg-kBfn5mr9oiA53C8MJjh26OedMw3CT2jv5wdTFLv0M 
         3. To see the list of connected devices, go back to the homepage. 


For creating a driver for a new device, we have to first extend the Driver class, then set the ‘connection_type’ class attribute. Then set the device_type, device_connection, and device_name attributes. And finally, define the ‘supported’ method.




from odoo.addons.hw_drivers.driver import Driver

class DriverName(Driver):
    connection_type = 'ConnectionType'

    def __init__(self, identifier, device):
        super(NewDriver, self).__init__(identifier, device)
        self.device_type = 'DeviceType'
        self.device_connection = 'DeviceConnection'
        self.device_name = 'DeviceName'

    @classmethod
    def supported(cls, device):
        ...
	

List Connected Devices


After successfully connecting the devices and the IoT box with Odoo, we can see the connected devices from the IoT App > Devices. By default, it will display the list of devices grouped by the IoT Box. We can also see the connection status, whether it is connected or not, and the connection type, like over WiFi, USB, or Bluetooth.


 https://lh3.googleusercontent.com/fkbVYW2wyHe_fyl3bKABgJwFNUlo2j6cN7xtm6rlt-liNEl7b3AswJzJz145OaYk7kS2aqWxaOyelIrQvp6JYSvrM1aPb2j_f07g-gyapsA0UjGaQKJ2oWqSHVC27nfv7z67eSSd-3uMDZ2ruLFhKs4 

We can see more details about the device by clicking any of the tiles. 


 https://lh5.googleusercontent.com/4EgaYxdBEySFIiznmCG8TrfpM0tkWhsY_Xwcmq2vhNt46wxvhrMGfiUOA94dNpEhcEhovNmYhPAmb1jvo9PAYJjE8dKTRr2r42MLMaaQAfd9b8t8rbFIahat_tYM0GRmQmVhjSNHu6VKEYDWDOTLOSU 
 
Input from device


The IoT Devices that are popularly used is QR code scanners, cameras, etc. Odoo IoT Box may not support all the devices out there, so we may have to provide support for the device to communicate with the IoT box. You can find the list of supported devices on this page https://www.odoo.com/page/iot-hardware. If your desired device is not on the list, we have to develop the driver for it.


Let’s say we are trying to connect a camera to the IoT box to capture the image of incoming products in our shop. After connecting the device to the IoT Box and loading the drivers, the camera will be ready. Now we have to fetch the image from the camera. For that, we can add a new field on the stock.picking model. 


class StockPicking(models.Model):
                _inherit = 'stock.picking'
                
                device_id = fields.Many2one('iot.device', string='IoT
Device',domain="[('type', '=', 'camera')]")
ip_device = fields.Char(related="device_id.iot_id.ip")
device_identifier = fields.Char(related='device_id.identifier')
                input_picture = fields.Binary()
	

There is a quality_iot module which is part of the Enterprise edition, and it contains a widget that allows us to request an image from the camera through an IoT box. We can use this widget to capture the image. So we can add this module to our depends list. We can also create our own widget if we want.


...
        depends : [ 'quality_iot'],
...'
	

Now we can use the widget in the form view of the receipt transfer,


    <group>
                <field name="device_id" required="1"/>
                <field name="ip_device" invisible="1"/>
                <field name="device_identifier" invisible="1"/>
                <field name="input_picture" widget="iot_picture" options="{'ip_field': 'ip', 'identifier': 'device_identifier'}"/>
        </group>
	

The user should select the Camera from the list of devices, and the IP and identifier of the device are necessary for the widget to communicate with the camera.
Install and update the module, and you will get a button to capture the image in the Receipt transfer form view. Clicking the button will request the IoT box to capture an image and will return the image data as a response. It will be saved in the binary field.


Access IoT box with SSH


The Odoo IoT Box is a raspberry pi based device that runs on the Raspbian OS, and we can access the IoT Box using SSH.


For this, we must first make sure that the IoT Box and the computer are on the same WiFi network. We need the IP address of the IoT Box, which can be fetched from the form view of the box. For this example, let’s take 192.168.44.8 as the IP address of the IoT Box.

            1. In the terminal, execute the command,
$ ssh pi@192.168.44.8
pi@192.168.44.8's password: 
	

            2. raspberry is the password, enter this into the prompt.
            3. After entering the password, the shell will be accessible. Now you can access the directory. The full filesystem will now be ready to explore.


We can use this SSH connection to perform any debugging with the IoT Box. In most cases, the IoT box does not shut down properly, so to avoid corruption of the system, the IoT Box filesystem is read-only.


As the IoT Box is connected only to the local machine, we cannot remotely access the IoT box through SSH. For that, we have to use the ‘ngrok’ service. The ngrok authentication key has to be provided on the Remote debugging page of the IoT Box.
 https://lh5.googleusercontent.com/nDMB8_HWObq5o2hl7L8fEvsOhkc6y4ufd1PviVlfd0vJ8uvifTKRFO2xqhL7phxttrMD3j9ggwjfhs06gip5ZzBHPCYsPh4vOxoD9-Q7oGuZ9T_iH2tIZyQfXunkc9MQ7MrPxc4SomrwqSoqdG4ExAk 

POS Configuration


If the Point of Sale application is not installed, do so after making sure that  the IoT Box and the computer running the Odoo instance are connected to the same WiFi network. 
Now let’s configure the IoT Box with POS.


            1. From the ‘Point of Sale’ application, open the settings of the PoS session  
            2. On the settings page, there will be an IoT Box checkbox under the Connected devices section. Enable the checkbox, and more options will be visible.
 https://lh3.googleusercontent.com/OmnymaO503vbmyVAhCc6enpfAGbXvuHzgQFh5aOnlkxA2ijI6oIYnX6BjO1cKqSDoVh2KLkj9wqvdvJ12jzCO23ci86wvmgxvVBQnfjHpPJ41P1xwb7MROcfcfb6LT7Q7ZhLVkVUlT08KaMmYCdHdG4 
            3. Now, select the corresponding devices in each field, such as the printer, barcode scanner, etc.
            4. Click on the Save button.


After completing these steps, you will be able to use the IoT Box in the PoS session.


If we want to integrate any hardware in the Odoo community edition case, we will also need to enter the IP address of the IoT Box in the configuration.


 https://lh6.googleusercontent.com/r0YdtgFieRjuXD4CUezr2i92cBpNmNubm8d3NMRBM8TdWLCoDvi7HVF1x0jAOuj997qK7DcFlTzxavOWDDFrbwBsX2VNv6gwTbxlkhT8tU69V87X7IGilViPRWTjf3Agl3_hDpzBAsvfd7x4uXXB00s 



Print Reports


CUPS is a printing system that allows a computer to act as a printing server. We can connect network printers with the IoT Box as it runs the CUPS internally.


               1. First, we have to open the IoT box homepage via IP address.
               2. At the bottom of the page, you will find the Printer Server button. Click on it.
               3. We can configure our printer here once it opens the CUPS configuration homepage. Once the configuration is done, the printer will appear in the IoT device list. Now navigate to Settings > Technical > Reports after enabling the Developer mode in Odoo.
               4. From the list, find the report you want to print. Open the form view and select the printer we just added in the IoT Device field.
 https://lh4.googleusercontent.com/VSB51DfARRhQHbyZPuiLnc-tdvX0vR42gQ8aqB_GePYB_sWpNLCdaDi7ZVr_3CzuX3T8znnaRAK51tp0hyw2C0TVfnccmKFnGQPjV1m85S2bGNDxDISb-PK_nXw9PnVbXv0myCcNNh-C6AIqyfeaGDU 
               5. The report will be directly sent to the printer once these configurations are done.
















19. Others
How to create Qweb-based pdf reports


Odoo plays a vital role in making a business efficient. The analysis of various areas is important in terms of the organization's growth in the ERP system. This is where we use reporting. 


Qweb is a reporting engine that generates PDF reports. It handles data easily using XML. The Qweb template engine usually converts XLM to HTML. And PDF rendering is done by wkhtmltopdf. Reports are generated using report action and report templates for the action to use.
Report Action: 
Report actions are triggered when reports need to be generated. The report action is written inside the XML file created in the report file of the module. The report action can be written like this;


<record id="action_report_vehicle_order" model="ir.actions.report">
 <field name="name">Vehicle Order</field>
 <field name="model">vehicle.report</field>
 <field name="report_type">qweb-pdf</field>
 <field name="report_name">vehicle.report_vehicle_order</field>
 <field name="report_file">vehicle.report_vehicle_order</field>
 <field name="print_report_name">'Vehicle Report - %s' % (object.name))</field>
 <field name="binding_model_id" ref="model_vehcicle_report"/>
 <field name="binding_type">report</field>
</record>
	

The fields of the report action are mentioned below in detail;
                  * name: Name of the report to be specified.
                  * model : It’s a mandatory field from which the records will be retrieved into the report.
                  * report_type: It specifies the type of the report, such as ‘qweb-text,’ ‘qweb-html,’ ‘qweb-pdf’. This used mainly two values qweb-pdf and qweb-html. The default value is qweb-pdf.
                  * report_name: Here, it specifies the external id of the report template.
                  * print_report_name: It specifies the report file name, and here the python expressions also can be used.
                  * binding_model_id: If the reports need to be printed from the Print action, then the required model id can be specified here. 


Report Templates:


The structure of the report species in the report templates. It’s an XML file created inside the report file of the module. Inside the template, HTML is used to design the report as required.
<template id="report_vehicle_order">
  <t t-call="web.html_container">
      <t t-foreach="docs" t-as="o">
          <t t-call="web.external_layout">
              <div class="page">
                  <h2>Sample Report</h2>
                  <p>span t-field="o.name"/></p>
              </div>
          </t>
      </t>
  </t>
</template>
	

The id of the template is external if that is mentioned in the report action. By calling the external_layout, the report will get the default layout of Odoo. The template always contains the variables like time, user, res_company, website, web_base_url, and context_timestamp.


Manage kanban stages


The kanban view in Odoo provides the simple and easiest way to use the workflows. It's a kind of view that organizes the records in columns with each stage. Under each stage, the records will be listed; thus, it’s possible to handle the record between these stages quickly.


Let us see how these stages and the kanban view are created;


Similar to the definition of form view and tree view, we have to mention the view type of kanban view in action. This can be added as follows;


<record id="action_mobile_service" model="ir.actions.act_window">
  <field name="name">Mobile Service</field>
  <field name="res_model">mobile.service</field>
  <field name="view_mode">tree,kanban,form</field>
  <field name="help" type="html">
      <p class="o_view_nocontent_smiling_face">
          Add a new analytic account
      </p>
  </field>
</record>
	Here the view_mode includes the tree, form and kanban views.
Now the view definition will be like this;


<record id="service_request_view_kanban" model="ir.ui.view">
  <field name="name">mobile.service.kanban</field>
  <field name="model">mobile.service</field>
  <field name="arch" type="xml">
      <kanban default_group_by="service_state">
          <field name="service_state"/>
          <templates>
              <t t-name="kanban-box">
                  <div class="oe_kanban_global_click">
                      <div class="oe_kanban_content">
                          <div class="oe_kanban_card">
                              <div>
                                  <b>
                                      <field name="name"/>
                                  </b>
                              </div>
                              <div class="text-muted">
                                  <field name="partner_id" widget="res_partner_many2one"/>
                              </div>
                          </div>
                      </div>
                  </div>
              </t>
          </templates>
      </kanban>
  </field>
</record>
	

This is a basic kanban view definition. Apart from this, more classes and attributes are available to enhance it.


As mentioned above, the kanban view contains records in a card along with their states. Kanban states are really useful, and the records of each state will be draggable. For showing the states in the kanban view, we have to use the attribute ‘group_expand.’ By using this attribute on the field declaration, the kanban view will display the states even though no records are available on the state. So let’s set how it’s defined;


service_state = fields.Selection([('draft', 'Draft'), ('assigned', 'Assigned'),('completed', 'Completed'), ('returned', 'Returned'),
('not_solved', 'Not solved')], string='Service Status', group_expand='_group_expand_states',default='draft', track_visibility='always')
	

	

As you can see, the attribute group_expand contains a function named ‘_group_expand_states.’ It’s defined as follows;


def _group_expand_states(self, states, domain, order):
  return [key for key, val in type(self).service_state.selection]
	

This function returns a list of states; thus, here, the function tries to pass all the selection fields in the list form to the method ‘group_expand.’
In the XML, the state field is defined as a normal field definition; here, we have defined it in the above example.
After following these things, the kanban view and its states will be as given below.


 https://lh5.googleusercontent.com/QlNWWOMKjVzAMCIfJ_enGoxR-1Cp1j7Ii8ynfauVZ9oV5q8ciWIJjW01BCLkeEEbc9L2hu7Mxgs7mQ9rDQOJUzgyaOBLLs_rfT1pt8Hrjca30Qjfkr8Sh31wnlKeOK26_AtfPhsd4RN_UPY-r90j8vU 







Progress bar in kanban view
Progress bar is another feature of the kanban view. Sometimes it is difficult to understand the states if the records are huge in number. Here the progress bar will help show each state's status on top of it. Let’s check how it’s defined;
Here, as an example, the progress bar is based on the field priority;


priority = fields.Selection([('0', 'Normal'),('1', 'Low'),('2', 'High'),('3', 'Very High')], string="Priority")
	

Three attributes are there used in the progress bar they are field, colors and sum_field
Field: The progress bar is shown based on the value of this field.
Colors: Mainly, there are four colors to assign to the values of the field. They are a success, warning, danger, and info.
Sum_field: This is an optional field for displaying the sum of any field in the record.
The progress bar is defined in the XML using the tag <progressbar>. 

<progressbar field="priority" colors='{"3": "success", "2": "warning", "1": "danger", "0": "info"}'/>
	
Once the module is upgraded after adding the progress bar the kanban view will look like this;

 https://lh6.googleusercontent.com/JtwrtHNmvfGuy5-k4xXv0J6Hn73o-Sfsp8Oiy-IkI9YnXgkU_-3EM38xBc0ZRl2slveiu04UgJX6dIYdJs9ItOBTTLSlB-mODRjbFi7eVT67a-psDda5EBMXPPDyAWyO14QQyNQFPwm3LtppJ-kDyvI 


While placing the mouse over the progress bar you can see the records belong to this field and the total number of the records will be displayed right to the column. This is by default, and if you want to show the sum of a particular field in a record, then it can be achieved by the attribute ‘sum_field’, but this is optional.
Kanban Cards
Kanban view is an application of the kanban board that organizes data as “cards.” Kanban cards are actually halfway between the listview and the read-only form view. Kanban cards can be viewed as a content area where the details of the records are displayed. This is usually defined inside kanban-box templates.  A Kanban card is a structure that supports all the HTML tags. Along with Odoo provides its own simplified ways so that the cards can be more interactive. 


<progressbar field="priority" colors='{"3": "success", "2": "warning", "1": "danger", "0": "info"}'/>
	
As mentioned earlier, the kanban cards are included in a template called kanban-box. This can also have sub-containers for footers that can be further divided into left and right footers using classes or_kanban_bottom_left and or_kanban_bottom_right. 
The example given sets an overall structure of the kanban card. The color field at the top is used to dynamically set the color of the map.




<div class="oe_kanban_content">
  #Content elements and fields go here.
  <div>
      <field name="tag_ids"/>
  </div>
  <div>
      <strong>
          <a type="open">
              <field name="name"/>
          </a>
      </strong>
  </div>
  <ul>
      <li>
          <field name="user_id"/>
      </li>
      <li>
          <field name="date_deadline"/>
      </li>
  </ul>
</div>
	
In the footer in the left side, let us add the priority widget;


<div class="oe_kanban_footer_left">
  #Left hand footer
  <field name="priority" widget="priority"/>
</div>
	

This is similar to the field adding in a form view.


In the right-hand footer, the state widget and avatar can be added like this;


#Right hand footer
<div class="oe_kanban_footer_right">
  <field name="Kanban_state" widget="kanban_state_selection"/>
  <img t-att-src="kanban_image(
'res.users', 'image_small', record.user_id.raw_value)"
       t-att-title="record.user_id.value"
       width="24" height="24"
       class="oe_kanban_avatar"/>
</div>
	

In the kanban view definition the element <field> acts similar to the other view modes. The avatar image is inserted into the view using <img> tag. The kanban view of the contacts module used this tag to show the images of the contacts. This is done as follows;


<img t-att-src="kanban_image('res.partner', 'image_medium', record.id.value)" class="o_kanban_image"/>
	

Interactive kanban cards


Odoo has its own built-in features to make the kanban cards interactive. It’s also possible to use HTML tags, and along with this Odoo, it provides more ways to make it compatible with the user interface. Let’s go through some of the built-ins;


Color field in Kanban view:


<field name="color"/>
	

Drop down to choose a color in the kanban view:


<t t-name="kanban-box">
  <div t-attf-class="oe_kanban_color_#{kanban_getcolor(record.color.raw_value)} oe_kanban_card oe_kanban_global_click">
      <div class="o_dropdown_kanban dropdown">
          <a role="button" class="dropdown-toggle o-no-caret btn" data-toggle="dropdown"
             href="#"
             aria-label="Dropdown menu" title="Dropdown menu">
              <span class="fa fa-ellipsis-v"/>
          </a>
          <div class="dropdown-menu" role="menu">
              <t t-if="widget.editable">
                  <a role="menuitem" type="edit" class="dropdown-item">Edit</a>
              </t>
              <t t-if="widget.deletable">
                  <a role="menuitem" type="delete" class="dropdown-item">Delete</a>
              </t>
              <div role="separator" class="dropdown-divider"/>
              <ul class="oe_kanban_colorpicker" data-field="color"/>
          </div>
      </div>
  </div>
</t>
	

For displaying the color of the kanban card, here the class t-attf-class=”#{kanban_color(record.color.row_value)} is added. Here value for the corresponding color field is used, and prepare a class based on that.
The given dropdown is used to show the options like Edit, Delete, and the kanban color picker. It is based on the access rights of logged-in users.


Now lets add the tags and popularity field;


<span class="oe_kanban_list_many2many">
  <field name="category_id" widget="many2many_tags" options="{'color_field': 'color'}"/>
</span>
<field name="priority" widget="priority"/>
	

Here the priority widget as well as the many2many_tags are used. The priority field displays the field using the star icon.  And the many2many_tags widget will show the field values as tags. The color_field is used to enable the color feature on the tags. 


Activities and kanban cards


In order to keep track of your work, it is important to plan activities accordingly. Activities are planned to remind of the work that is needed to complete and schedule the upcoming activities. Activities can be managed from anywhere in Odoo. Thus, it is able to view and manage the activities from a kanban view. Let’s have a look at how the activities are used in the kanban view.


To achieve this, we require the dependent ‘mail’ to inherit the model activity mixin. 


class MobileServices(models.Model):
  _name = 'mobile.service'
  _description = 'Mobile Services'
  _inherit = ['mail.thread', 'mail.activity.mixin']
	

Now we are able to make use of the fields that are declared on these models. And hence the field activity_state can be added to the kanban view as normal.


<field name="activity_state"/>
	

Then the field activity_ids can be placed inside the kanban template to view and manage the activities from the view itself.


<field name="activity_ids" widget="kanban_activity"/>
	

After adding these in the kanban view template, the view will be like this;


 https://lh5.googleusercontent.com/cyfy11ifOQZybjTNGfRfxDLBD5L2220KnPCYgiTacYIyu4QUdRhsF4IB5YXFtgFX_6x9K3g2uP1WoU-0kbiF1ROC3UzNf_aRBLzhiSnLO-DpwK1mUzhjtrjRL6POed-bKJe7acvgDOCp5f8gCFcRwxI 



By clicking on the widget, it is able to view the already created activities, and also the activities can be scheduled.


 https://lh5.googleusercontent.com/Y-DGPAj6qK9_kM3plVRKYlBs12yrjgsU5hYS7Bg4vcy_SuLe0nKGCGy1Ju-E9nGpCHRhEZ-t3PPZzXm-vtBhTXH4SmhTAERBzEL5LFJuKF9I5R6jrJsgMdESXdWXxK0kIW_TDekjAR7d0Zz4v9yVTg0 




Quick create


Quick create is a feature uniquely available to the kanban view in Odoo. Generally, this feature allows you to create records of any particular model to create its record from the kanban view without rendering the form view. Instead, it will bring up a minimalist form from the kanban. This is achieved by clicking on the ‘+’ icon shown on the right top of each column. 
This can be created with simple steps as follows.


Firstly, a form view needs to be created with the minimum required fields. This is actually used for displaying it once the ‘+’ icon is clicked. 


<record id="mobile_service_view_form_minimal" model="ir.ui.view">
  <field name="name">Field Service Form</field>
  <field name="model">mobile.service</field>
  <field name="arch" type="xml">
      <form>
          <group>
              <field name="name"/>
              <field name="partner_id"/>
              <field name="priority"/>
          </group>
      </form>
  </field>
</record>
	

After creating the form view, in the next step this view needs to be mentioned in the kanban view declaration. Here we use the attribute quick_create_view, which refers to the view's external id.
Here is the way to show how to add the quick create;


<kanban default_group_by="service_state" quick_create_view="mobile_service.mobile_service_view_form_minimal" on_create="quick_create">
	

This will add the view to the kanban view. Thus when the plus icon is clicked, a small form view will appear to create the record from the kanban view.
 https://lh3.googleusercontent.com/shAdJbcHTXFnWu5V97145_P9576f_QUl9DCJbCpJy4MaQnOWUx3B6v_eCTgENZ-RAkN-VUpzNPtGzVfpupJLaHKJDnigeSahfbCeVZrjEv1JDgiXaiCmgGPEc7dqBDNvItCcXxUXjWHJ4irpeJ1cSy0 
                                
Create server actions


Server actions are actions that work on the base models. These actions are executed automatically. Let’s check the way how it is created;
After enabling the developer mode, check out the menu Settings > Technical > Actions > Server Actions.
 https://lh3.googleusercontent.com/rnf1wTIL2WL0lmwFEDkdgJj6VmcCYveXTbkf6xIVAr1QlGjJAsWD8W12ORpnzQ187T6eKXALItEqlojjxBzwVq4lYdPQyqKpIUHAZKhxS1TbX2JnKlSjp2FGyoZFO-ZE68jdCnTNCD8u9QrUp-3lPWg 


Let’s check the server action types;
                  1. Update the record
                  2. Create a new record
                  3. Execute Python Code
                  4. Execute several actions
                  5. Send Email
                  6. Add Followers
                  7. Create the next activity
                  8. Send an SMS text Message


 https://lh4.googleusercontent.com/DJ3GhRrEReHkWuETkFHK0bSN6uDKwsJko8wE8uPOhr0IjmLJfX_EGV0R8iSUHCDLxpHMPZxP8u4kIIhHvKts8Elq2ys2atkBEVhH_I7xOdJWcGeQJcmiU4UidcmrgN5TMVo9EuGcuMVtP1LeMC1lMMY 



Once you click on the ‘Create’ button, this form view will appear. Here the ‘Action name’ needs to be filled, and also select any model upon which this server action needs to be acted. The next mandatory field is the ‘Action to do,’ which determines the action type. 

XML code for creating a server action. It is placed in the data file of the module.


<record id="action_set_salesperson" model="ir.actions.server">
  <field name="name">Set Sales Person</field>
  <field name="model_id" ref="base.model_res_partner"/>
  <field name="state">code</field>
</record>
	
In this record, as with every record, it has a unique id and also a name used to name the server action. Another field is the ‘model_id’ used to mention the model to which this action is linked. Next is the ‘state’ field that is used for specifying the type of server action.


Let’s go through the type of actions;


Update the record


This type of server action is created in order to update something in the specified model.
For example, If we need to set anyone as the salesperson for the records of contact, then the server action will be like this;


 https://lh4.googleusercontent.com/__YaqOcp1ZDZmXGsycqDp3RIXmi_OdtaR3dOHgxMKaQRs5nhTY0747rHMGNi31VsmYqgJLTdf5qwiNRCHxEmk8qbNt-x4vVi0xiq4z-Gx8c2z65zumEpMfQ4cWZtg-H7XCyZzvZeSU-stn0Szdpjw0U 

Here, the page ‘Data to Write’ refers to the fields and their corresponding actions to be done on the model. The field ‘Evaluation Type’ contains three modes like ‘Value, ‘Reference,’ and ‘Python Code.’ If it’s Value, then it will be specified as a literal value. If it is ‘Reference,’ then the existing value will be available to select and set its field. Otherwise, if it is the ‘Python Code,’ then a python expression is required.
Once the details are filled up then, the button ‘Create Contextual Action’ can be clicked. As a result, you will get a new menu in the contextual action in the view as given below.

 https://lh5.googleusercontent.com/StG5C0vsBGKSY4tFK1ShoxFsI0Z5Fm5w5NukH3u2h-A9LSiKe_oQyHO9YQop3qRjrBkFrB4xPiFb0YNtPCqmhxEbMA-MwhxTMPfISCBy1aKu_EQNZ98D5UpGhP9S3UUaYlAEoTae09XXONbkd-3JwEo 

If the option is clicked, the salesperson field will get assigned the value for the server action. Hence the record can be updated.


In the code, the update can be used as;
<field name="state">object_write</field>
	

Create a new Record


Here, the server action created a new record in the specified model. 
Its server action will be like this;
 https://lh5.googleusercontent.com/i98DGQtV64gooT2XsyRJLNV0pW0f00yCLC_977_c5KAvyHzrtBBX7cbK5dLfsdeLBtOM_upW-7m3bt5JPDt5NQftutQ1ta0Eo3hzjdPMzLNHCB6UwCL3lDc251TwEuUCSvsotFMqRPzOoFBJLJ8s5fg 



After creating this action, the model ‘Contact’ will have a contextual action to create a record based on the values set in the action. Its target model is also specified here.
The code will be like this;


<field name="state">object_create</field>
	 
Execute Python Code


This type of server action is used to execute python code.


This is done in the code as follows;


<field name="state">code</field>
	

 https://lh3.googleusercontent.com/c49BpELgJFLELJk1tkeiUSDKD4akcWWSw7m6DyUGj_ksRSjYAhW9JSavCkXp2qRFpuyqAEv1ION5yW3t-AVq0Wanuz7AtqQpg31Z1giOxyR7SjBHz3UvdwMkglCdlgDv7OVg2xylgYekN2bQMXtlNKw 



 This is a type of server action that performs multiple actions at a time.


Thus here, we can choose the actions that need to be executed simultaneously. 


 https://lh6.googleusercontent.com/G0SLsyzRTOQSfbvxkfhaz_Tcrr9fil7Wtatc09SB2VRld-onBqLXAR9ibdtP_f4o5YOFA1tPyEhQh3Jq3vKfwRP7TUvBYBG3g33zCfZUvnaNtgURjci3KhzHXFKZkRa7N2EhaBxmW6W5gNppSv2NhtM 



After creating this record, a contextual action will be created, and the listed child actions will be executed simultaneously when the action is selected.
This type of action is declared in the XML as;


<field name="state">multi</field>
	

Send Email


This is used to send emails to our partner from a specified model. Once this type of action is selected, then a field will be displayed to select the email template.


 https://lh6.googleusercontent.com/CIeEcXJe-N1n_MA1vfObzmKMGdigbRC9FKxrYS49S2s73rfVJB-Ri2UvRCcehf81hubCPeVycRjYQ2cBhf8Q3bTudiGQ6jEZlj9fdblb8QVJi64suH_xwhv3xDIvf41CMWTUVDqFggR4pHah1b7Q9IY 




Here is another option to select the mode of sending the template. Either it can be sent as an ‘Email’ or ‘ Post as Message’ or ‘post as Note.
Its declaration in the code is;


<field name="state">email</field>
	



Add Followers


This is used to add followers to the specified model. 


 https://lh4.googleusercontent.com/M3ziw9_SPEF2Wnmiu4uHO_ordn0PVtc6pWlwcknOHOaFHEJ7ENaNhiXeY4ZMiQT0paGEWiarNDQ7miKG9rqOf-guuqnba_5cr-_QwRRtJkCvSgF7836y1rhhsLypWy10YLfGDSrv1_t5mXnx8d8RfrI 



After creating this server action, a similar contextual action will be created, and the selected followers will be added to the corresponding model.


In the XML, this type if defined as followers;
<field name="state">followers</field>
	

Create Next Activity


These types of actions are used to schedule the next activities based on a model.


 https://lh5.googleusercontent.com/Ibh0kXXSXLO28zCZHj7PZr5WwxAyCCPjv0PA9kQ3sDhYuCXZI9JdX_zQ9vRR7UOrj9IXyyV5GQ374aWzYEvKuNvTVVPxiq-J45ou46KaU-ccwUNaSmWo4a1tHSwKKPkJvxhRiGSL5RiTvpGPtOxP-Ew 



This will create a contextual action to schedule the action that is mentioned in the record for server action. 


In the XML code, it is defined as;


<field name="state">next_activity</field>
	

Send SMS Text Message


This type of server action is used to send text messages in bulk.


The field ‘state’ is declared as ‘SMS’ here;


<field name="state">sms</field>
	

 https://lh6.googleusercontent.com/6luA8gBO55SA88xi6XxmqUN-Bt03h3pmViELTp5A7X3v_nWfZoVlWBDOi22kgpY7jZM17B6L3nl4lssKNPUUtEwHHHtNsDGEJIPCN9bhKei8n7urrZi4oYiyYSU-nAglBL3fCU5kUvBoWBH_vzekBFc 



Once the action type is selected, a field for selecting the template and the field to set the mode of sending the text message will appear. Thus once the contextual action is created, then the text message will be sent based on the model.


Python code server actions


Python code server actions are the most flexible kind of actions that helps users to meet their requirements through python code. It’s useful because of the capabilities to bring advanced logic to Odoo from the front end itself. Let’s have a look at the way in which the python code server actions are implemented;


After enabling the developer mode go to Settings > Technical > Automation > Automated Actions. Then create a new action.
For example, Let’s see how a warning is set on the record during creation.

 https://lh4.googleusercontent.com/-TX4zoDwd9qGA8E9V_mvsUh3KB79kSidD6gGaZ85-hD6W0b5E3Ad8Of0td2x8bK-lckGOo_J9ECLry-8mP9VFL1z_YxV0rAiR3nBDHQNsVyxLPh-eCZGD2QxAv1HE1HctXqDDPBUhf7rB2TMheSAuEA 


This is a basic example to show the python code server actions. The fields that are used here;


Model: model upon which this action needs to be executed.
Action to do: type of action to be performed
Trigger: triggering conditions like on update, create, deletion, etc.
Apply on: condition specified before executing the action
Python Code: python code is explained here.


  https://lh4.googleusercontent.com/Ei2HYHxyE9CZ9kWXMRmrUY-b5eYyxZ0U6aLAXBa8kTLBdXS-g0p2Uea48Lxj2eM2YAM8XXdgKACbemVH2tvwtD8nafPnSdjpmOMETMvXNxGZQtwt9mkwvIMUEGxSpxVNXJwzP0gkGBOnV3t3aHedfBw 


After saving the action, it will be necessary to add an email while creating any contact. Otherwise, it will show UserError according to the python code server action.


Automated actions on time conditions


Automated actions can be triggered based on time conditions. Thus if an operation needs to be performed at a specific time, then the automated actions are able to perform it. 
Let’s see how this is implemented in Odoo;
Once you enable the developer mode, then go to the menu Settings > Technical > Automation > Automated Actions. Then let’s create a new record on that. 


 https://lh6.googleusercontent.com/Ta-QsoYvciJa3ROhv8w7TyXLDEFvBE9wj-ND2_1ZakAf6Vt9JFInPjDL8jSKdO1Y-VOPbaRlMrTFtAxf7h03-6B4_PDiSjQamcVPgu0x3F7RNuV9p28yIqKjOom9ZEehrWNrBQgaKt2iEiW5IJwkPBU 



Model: Model on which the action needs to be performed.
Action To do: Select the type of action.
Trigger: Select the triggering type. Here it will be “Based on Time condition”
Apply on: conditions executed before the action
Email Template: email template to be used. It needs to be selected if the type is “send Email”
Trigger Date: it decides when the action should be triggered.
Delay after trigger date: it can have negative values so that the action will be triggered before the trigger date.


Automated actions on event conditions


Automated actions can be set to trigger the action based on a specific event. Let’s check if its working by using an example;
Let's consider that the user can update the project status only if they have access rights to the project manager and project leader. 
Now let’s create a server action based on a python code to show user error. It checks if the logged-in user and the project manager are the same or not. 
If it fails, then it will raise an error message.


 https://lh3.googleusercontent.com/BU2KCNEUmyhR-gwp6qAZItcBQQOavmeD0r-oU_B8exnu73NhAEeOrr_HT8P_4oe7VVijhdnnpdmvop4o0vyrI_PE4L5QVPaU3CNMKdmJ--gmjIk1Mzy98o97ZqSKohXJdnPfjM3nG7pfxHU91R10t-E 



Now let’s create another action for executing this action while on its update.
It will be like this;
 https://lh5.googleusercontent.com/Pe4g51FF7xQBE0uJXOaWjWRY0PeJdXFfnY-5ALyhEFXWiAZ5svipKzQm4WioOXKMulu5nix9RbMF8KUp8yK5uqVf3NdJtFlQw748FtZuntAeMOzzgp9kSdfVt4E4sb6PoYrsZCGyzi6vPB0rV4Id_HQ 

Here, The fields are explained like;
Model: The required model upon which the action will be performed.
Trigger: Triggering condition of the action.
Trigger fields: If any fields are mentioned, then the action will be based on the update on these fields.
Before update domain: If any conditions are mentioned here they will be satisfied before the update of the record
Apply on: If any conditions are specified on the field they will be satisfied before the action rule.
Action to do: The type of action is specified here.


After adding these requirements, when going to the project and trying to update the record, then, there will raise an error if the user is not the project manager for that particular project.


 https://lh5.googleusercontent.com/oLnIw0wDsyvotbqZqrGnO_D0taHeAtdWIjYBrIhyrWS6sUxv58XCxEyBXoPmmIN6rYJzXaeQ5IhBzsYt2rrUOEakXAPDMWp6Mc076yvEcW8rfuVvzLBQGaKDDZ4pHoroXqZvrCyRRuBXxV3pX69sU7A 




Dynamic record stages


Stages are used in Odoo to specify the record's current state. In many cases, these fields are static and cannot be changed. Thus it is possible to use many2one fields to give access to update and create new states in accordance with. Let’s understand how it works, along with an example. 


In order to manage the stages individually, let’s create a new model;


class DynamicStages(models.Model):
  _name = "dynamic.stages"
  _rec_name = 'name'

  name = fields.Char(string='Name')
  sequence = fields.integer(string='Sequence')
  fold = fields.Boolean(string='Folded in Kanban')
  name = fields.Char(string='Sequence')
	

This model needs to be added in the required parent model in a many2one relation. 


def _get_stage_id(self):
  dynamic_stages = self.env['dynamic.stages'].search([], limit=1)
  return dynamic_stages.id

stage_id = fields.Many2one('dynamic.stages', string="Dynamic State", default='_get_stage_id', readonly=True,
                         required=True, help="Employee")
	

Now this field can be added to the view as the following;


<header>
  <field name="stage_id" widget="statusbar" options="{'clickable': '1', 'fold_field': 'fold'}"/>
</header>
	

Once the fields are declared as such, we can then change and fold the stages. In this way, the stage definitions can be manipulated.